[
  {
    "text": "Financial Toolbox™\nUser's Guide\nR 2025 b",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 1,
      "section_heading": "Financial Toolbox™",
      "captions": ""
    }
  },
  {
    "text": "How to Contact MathWorks\nLatest news: www.mathworks.com\nSales and services: www.mathworks.com/sales_and_services\nUser community: www.mathworks.com/matlabcentral\nTechnical support: www.mathworks.com/support/contact_us\nPhone: 508-647-7000\nThe MathWorks, Inc. 1 Apple Hill Drive Natick, MA 01760-2098\nFinancial Toolbox™ User's Guide\n© COPYRIGHT 1995–2025 by The MathWorks, Inc.\nThe software described in this document is furnished under a license agreement. The software may be used or copied only under the terms of the license agreement. No part of this manual may be photocopied or reproduced in any form without prior written consent from The MathWorks, Inc.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 2,
      "section_heading": "How to Contact MathWorks",
      "captions": ""
    }
  },
  {
    "text": "FEDERAL ACQUISITION: This provision applies to all acquisitions of the Program and Documentation by, for, or through the federal government of the United States. By accepting delivery of the Program or Documentation, the government hereby agrees that this software or documentation qualifies as commercial computer software or commercial computer software documentation as such terms are used or defined in FAR 12.212, DFARS Part 227.72, and DFARS 252.227-7014. Accordingly, the terms and conditions of this Agreement and only those rights specified in this Agreement, shall pertain to and govern the use, modification, reproduction, release, performance, display, and disclosure of the Program and Documentation by the federal government (or other entity acquiring for or through the federal government) and shall supersede any conflicting contractual terms or conditions. If this License fails to meet the government's needs or is inconsistent in any respect with federal procurement law, the",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 2,
      "section_heading": "How to Contact MathWorks",
      "captions": ""
    }
  },
  {
    "text": "and shall supersede any conflicting contractual terms or conditions. If this License fails to meet the government's needs or is inconsistent in any respect with federal procurement law, the government agrees to return the Program and Documentation, unused, to The MathWorks, Inc.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 2,
      "section_heading": "How to Contact MathWorks",
      "captions": ""
    }
  },
  {
    "text": "Trademarks\nMATLAB and Simulink are registered trademarks of The MathWorks, Inc. See www.mathworks.com/trademarks  for a list of additional trademarks. Other product or brand names may be trademarks or registered trademarks of their respective holders.\nPatents\nMathWorks products are protected by one or more U.S. patents. Please see  www.mathworks.com/patents  for more information.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 2,
      "section_heading": "How to Contact MathWorks",
      "captions": ""
    }
  },
  {
    "text": "Revision History",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 3,
      "section_heading": "October 1995",
      "captions": ""
    }
  },
  {
    "text": "October 1995 First printing January 1998 Second printing Revised for Version 1.1 January 1999 Third printing Revised for Version 2.0 (Release 11) November 2000 Fourth printing Revised for Version 2.1.2 (Release 12) May 2003 Online only Revised for Version 2.3 (Release 13) June 2004 Online only Revised for Version 2.4 (Release 14) August 2004 Online only Revised for Version 2.4.1 (Release 14+) September 2005 Fifth printing Revised for Version 2.5 (Release 14SP3) March 2006 Online only Revised for Version 3.0 (Release 2006a) September 2006 Sixth printing Revised for Version 3.1 (Release 2006b) March 2007 Online only Revised for Version 3.2 (Release 2007a) September 2007 Online only Revised for Version 3.3 (Release 2007b) March 2008 Online only Revised for Version 3.4 (Release 2008a) October 2008 Online only Revised for Version 3.5 (Release 2008b) March 2009 Online only Revised for Version 3.6 (Release 2009a) September 2009 Online only Revised for Version 3.7 (Release 2009b) March 2010",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 3,
      "section_heading": "October 1995",
      "captions": ""
    }
  },
  {
    "text": "2008 Online only Revised for Version 3.5 (Release 2008b) March 2009 Online only Revised for Version 3.6 (Release 2009a) September 2009 Online only Revised for Version 3.7 (Release 2009b) March 2010 Online only Revised for Version 3.7.1 (Release 2010a) September 2010 Online only Revised for Version 3.8 (Release 2010b) April 2011 Online only Revised for Version 4.0 (Release 2011a) September 2011 Online only Revised for Version 4.1 (Release 2011b) March 2012 Online only Revised for Version 4.2 (Release 2012a) September 2012 Online only Revised for Version 5.0 (Release 2012b) March 2013 Online only Revised for Version 5.1 (Release 2013a) September 2013 Online only Revised for Version 5.2 (Release 2013b) March 2014 Online only Revised for Version 5.3 (Release 2014a) October 2014 Online only Revised for Version 5.4 (Release 2014b) March 2015 Online only Revised for Version 5.5 (Release 2015a) September 2015 Online only Revised for Version 5.6 (Release 2015b) March 2016 Online only Revised",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 3,
      "section_heading": "October 1995",
      "captions": ""
    }
  },
  {
    "text": "for Version 5.4 (Release 2014b) March 2015 Online only Revised for Version 5.5 (Release 2015a) September 2015 Online only Revised for Version 5.6 (Release 2015b) March 2016 Online only Revised for Version 5.7 (Release 2016a) September 2016 Online only Revised for Version 5.8 (Release 2016b) March 2017 Online only Revised for Version 5.9 (Release 2017a) September 2017 Online only Revised for Version 5.10 (Release 2017b) March 2018 Online only Revised for Version 5.11 (Release 2018a) September 2018 Online only Revised for Version 5.12 (Release 2018b) March 2019 Online only Revised for Version 5.13 (Release 2019a) September 2019 Online only Revised for Version 5.14 (Release 2019b) March 2020 Online only Revised for Version 5.15 (Release 2020a) September 2020 Online only Revised for Version 6.0 (Release 2020b) March 2021 Online only Revised for Version 6.1 (Release 2021a) September 2021 Online only Revised for Version 6.2 (Release 2021b) March 2022 Online only Revised for Version 6.3",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 3,
      "section_heading": "October 1995",
      "captions": ""
    }
  },
  {
    "text": "6.0 (Release 2020b) March 2021 Online only Revised for Version 6.1 (Release 2021a) September 2021 Online only Revised for Version 6.2 (Release 2021b) March 2022 Online only Revised for Version 6.3 (Release 2022a) September 2022 Online only Revised for Version 6.4 (Release 2022b) March 2023 Online only Revised for Version 6.5 (Release 2023a) September 2023 Online only Revised for Version 23.2 (R2023b) March 2024 Online only Revised for Version 24.1 (R2024a) September 2024 Online only Revised for Version 24.2 (R2024b) March 2025 Online only Revised for Version 25.1 (R2025a) September 2025 Online only Rereleased for Version 25.2 (R2025b)",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 3,
      "section_heading": "October 1995",
      "captions": ""
    }
  },
  {
    "text": "Getting Started 1\nFinancial Toolbox Product Description  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-2\nExpected Users  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-3\nAnalyze Sets of Numbers Using Matrix Functions  . . . . . . . . . . . . . . . . . . . 1-4 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4 Key Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4 Referencing Matrix Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4 Transposing Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 5,
      "section_heading": "Contents",
      "captions": ""
    }
  },
  {
    "text": "Matrix Algebra Refresher  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7 Adding and Subtracting Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7 Multiplying Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8 Dividing Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-11 Solving Simultaneous Linear Equations . . . . . . . . . . . . . . . . . . . . . . . . . 1-11 Operating Element by Element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-13",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 5,
      "section_heading": "Contents",
      "captions": ""
    }
  },
  {
    "text": "Using Input and Output Arguments with Functions  . . . . . . . . . . . . . . . . . 1-15 Input Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-15 Output Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-16\nPerforming Common Financial Tasks 2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 5,
      "section_heading": "Contents",
      "captions": ""
    }
  },
  {
    "text": "Performing Common Financial Tasks 2\nHandle and Convert Dates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2 Date Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2 Date Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-3 Current Date and Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-7 Determining Specific Dates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8 Determining Holidays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8 Determining Cash-Flow Dates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 5,
      "section_heading": "Contents",
      "captions": ""
    }
  },
  {
    "text": "Analyzing and Computing Cash Flows  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11 Interest Rates/Rates of Return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11 Present or Future Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12 Depreciation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13 Annuities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\nv\nContents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 5,
      "section_heading": "Contents",
      "captions": ""
    }
  },
  {
    "text": "Pricing and Computing Yields for Fixed-Income Securities  . . . . . . . . . . 2-15 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15 Fixed-Income Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15 Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18 Default Parameter Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18 Coupon Date Calculations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20 Yield Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21 Pricing Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21 Yield Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21 Fixed-Income Sensitivities . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 6,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": "About Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44, Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46"
    }
  },
  {
    "text": ". . . . . . . 2-21 Yield Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21 Fixed-Income Sensitivities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-22",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 6,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": "About Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44, Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46"
    }
  },
  {
    "text": "Treasury Bills Defined  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-25\nComputing Treasury Bill Price and Yield  . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26 Treasury Bill Repurchase Agreements . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26 Treasury Bill Yields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\nTerm Structure of Interest Rates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-29",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 6,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": "About Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44, Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46"
    }
  },
  {
    "text": "Term Structure of Interest Rates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-29\nReturns with Negative Prices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-32 Negative Price Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-32 Analysis of Negative Price Returns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-33 Visualization of Complex Returns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-35 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 6,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": "About Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44, Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46"
    }
  },
  {
    "text": "Pricing and Analyzing Equity Derivatives  . . . . . . . . . . . . . . . . . . . . . . . . . 2-39 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39 Sensitivity Measures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39 Analysis Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-40\nAbout Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44\nCase Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46\nMachine Learning for Statistical Arbitrage: Introduction  . . . . . . . . . . . . 2-48",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 6,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": "About Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44, Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46"
    }
  },
  {
    "text": "Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46\nMachine Learning for Statistical Arbitrage: Introduction  . . . . . . . . . . . . 2-48\nMachine Learning for Statistical Arbitrage I: Data Management and Visualization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-50\nMachine Learning for Statistical Arbitrage II: Feature Engineering and Model Development  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-59\nMachine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-69\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-78\nvi Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 6,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": "About Life Tables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44 Life Tables Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44, Case Study for Life Tables Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46"
    }
  },
  {
    "text": "Portfolio Analysis 3\nAnalyzing Portfolios  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\nPortfolio Optimization Functions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3\nPortfolio Construction Examples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5 Efficient Frontier Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5\nPortfolio Selection and Risk Aversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7 Optimal Risky Portfolio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 7,
      "section_heading": "Portfolio Analysis",
      "captions": ""
    }
  },
  {
    "text": "portopt Migration to Portfolio Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11 Migrate portopt Without Output Arguments . . . . . . . . . . . . . . . . . . . . . . 3-11 Migrate portopt with Output Arguments . . . . . . . . . . . . . . . . . . . . . . . . . 3-12 Migrate portopt for Target Returns Within Range of Efficient Portfolio Returns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13 Migrate portopt for Target Return Outside Range of Efficient Portfolio Returns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14 Migrate portopt Using portcons Output for ConSet . . . . . . . . . . . . . . . . . 3-15 Integrate Output from portcons, pcalims, pcglims, and pcgcomp with a Portfolio Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 7,
      "section_heading": "Portfolio Analysis",
      "captions": ""
    }
  },
  {
    "text": "Constraint Specification Using a Portfolio Object  . . . . . . . . . . . . . . . . . . 3-19 Constraints for Efficient Frontier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19 Linear Constraint Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21 Specifying Group Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\nActive Returns and Tracking Error Efficient Frontier  . . . . . . . . . . . . . . . 3-27\nMean-Variance Portfolio Optimization Tools 4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 7,
      "section_heading": "Portfolio Analysis",
      "captions": ""
    }
  },
  {
    "text": "Active Returns and Tracking Error Efficient Frontier  . . . . . . . . . . . . . . . 3-27\nMean-Variance Portfolio Optimization Tools 4\nPortfolio Optimization Theory  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4 Portfolio Optimization Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4 Portfolio Problem Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4 Return Proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5 Risk Proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 7,
      "section_heading": "Portfolio Analysis",
      "captions": ""
    }
  },
  {
    "text": "Supported Constraints for Portfolio Optimization Using Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9 Linear Inequality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9 Linear Equality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10 'Simple' Bound Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10 'Conditional' Bound Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11 Budget Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11 Conditional Budget Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12 Group Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nvii",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 7,
      "section_heading": "Portfolio Analysis",
      "captions": ""
    }
  },
  {
    "text": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13 Average Turnover Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14 One-Way Turnover Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14 Tracking Error Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15 Cardinality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\nDefault Portfolio Problem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\nPortfolio Object Workflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 8,
      "section_heading": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20 Portfolio Object Properties and Functions . . . . . . . . . . . . . . . . . . . . . . . . 4-20 Working with Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20 Setting and Getting Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20 Displaying Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21 Saving and Loading Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21 Estimating Efficient Portfolios and Frontiers . . . . . . . . . . . . . . . . . . . . . . 4-21 Arrays of Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22 Subclassing Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23 Conventions for Representation of Data . . . . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 8,
      "section_heading": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": ". . 4-22 Subclassing Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23 Conventions for Representation of Data . . . . . . . . . . . . . . . . . . . . . . . . . 4-23",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 8,
      "section_heading": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Creating the Portfolio Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25 Portfolio Problem Sufficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25 Portfolio Function Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-26\nCommon Operations on the Portfolio Object  . . . . . . . . . . . . . . . . . . . . . . 4-33 Naming a Portfolio Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-33 Configuring the Assets in the Asset Universe . . . . . . . . . . . . . . . . . . . . . 4-33 Setting Up a List of Asset Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-33 Truncating and Padding Asset Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-35",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 8,
      "section_heading": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Setting Up an Initial or Current Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . . 4-37\nSetting Up a Tracking Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-40\nAsset Returns and Moments of Asset Returns Using Portfolio Object  . . 4-42 Assignment Using the Portfolio Function . . . . . . . . . . . . . . . . . . . . . . . . 4-42 Assignment Using the setAssetMoments Function . . . . . . . . . . . . . . . . . 4-43 Scalar Expansion of Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-44 Estimating Asset Moments from Prices or Returns . . . . . . . . . . . . . . . . . 4-45 Estimating Asset Moments with Missing Data . . . . . . . . . . . . . . . . . . . . . 4-47 Estimating Asset Moments from Time Series Data . . . . . . . . . . . . . . . . . 4-49\nWorking with a Riskless Asset  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-52",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 8,
      "section_heading": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Working with a Riskless Asset  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-52\nWorking with Transaction Costs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-54 Setting Transaction Costs Using the Portfolio Function . . . . . . . . . . . . . . 4-54 Setting Transaction Costs Using the setCosts Function . . . . . . . . . . . . . . 4-54 Setting Transaction Costs with Scalar Expansion . . . . . . . . . . . . . . . . . . 4-56\nWorking with Portfolio Constraints Using Defaults  . . . . . . . . . . . . . . . . . 4-58 Setting Default Constraints for Portfolio Weights Using Portfolio Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-58\nviii Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 8,
      "section_heading": "Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Working with 'Simple' Bound Constraints Using Portfolio Object  . . . . . 4-62 Setting 'Simple' Bounds Using the Portfolio Function . . . . . . . . . . . . . . . 4-62 Setting 'Simple' Bounds Using the setBounds Function . . . . . . . . . . . . . . 4-62 Setting 'Simple' Bounds Using the Portfolio Function or setBounds Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-63\nWorking with Budget Constraints Using Portfolio Object  . . . . . . . . . . . . 4-65 Setting Budget Constraints Using the Portfolio Function . . . . . . . . . . . . . 4-65 Setting Budget Constraints Using the setBudget Function . . . . . . . . . . . 4-65",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 9,
      "section_heading": "Working with 'Simple' Bound Constraints Using Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Working with Conditional Budget Constraints Using Portfolio Object  . . 4-67 Setting Conditional Budget Constraints Using the Portfolio Function . . . 4-67 Setting Conditional Budget Constraints Using the setConditionalBudget Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-67\nWorking with Group Constraints Using Portfolio Object  . . . . . . . . . . . . . 4-69 Setting Group Constraints Using the Portfolio Function . . . . . . . . . . . . . 4-69 Setting Group Constraints Using the setGroups and addGroups Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-69",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 9,
      "section_heading": "Working with 'Simple' Bound Constraints Using Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Working with Group Ratio Constraints Using Portfolio Object  . . . . . . . . 4-72 Setting Group Ratio Constraints Using the Portfolio Function . . . . . . . . . 4-72 Setting Group Ratio Constraints Using the setGroupRatio and addGroupRatio Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-73\nWorking with Linear Equality Constraints Using Portfolio Object  . . . . . 4-75 Setting Linear Equality Constraints Using the Portfolio Function . . . . . . 4-75 Setting Linear Equality Constraints Using the setEquality and addEquality Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-75\nWorking with Linear Inequality Constraints Using Portfolio Object  . . . . 4-78 Setting Linear Inequality Constraints Using the Portfolio Function . . . . . 4-78 Setting Linear Inequality Constraints Using the setInequality and addInequality Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-78",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 9,
      "section_heading": "Working with 'Simple' Bound Constraints Using Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Working with 'Conditional' BoundType, MinNumAssets, and MaxNumAssets Constraints Using Portfolio Objects  . . . . . . . . . . . . . . 4-81 Setting 'Conditional' BoundType Constraints Using the setBounds Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-81 Setting the Limits on the Number of Assets Invested Using the setMinMaxNumAssets Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-82\nWorking with Average Turnover Constraints Using Portfolio Object  . . . 4-85 Setting Average Turnover Constraints Using the Portfolio Function . . . . 4-85 Setting Average Turnover Constraints Using the setTurnover Function . . 4-85\nWorking with One-Way Turnover Constraints Using Portfolio Object  . . . 4-88 Setting One-Way Turnover Constraints Using the Portfolio Function . . . . 4-88 Setting Turnover Constraints Using the setOneWayTurnover Function . . 4-88",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 9,
      "section_heading": "Working with 'Simple' Bound Constraints Using Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Working with Tracking Error Constraints Using Portfolio Object  . . . . . . 4-91 Setting Tracking Error Constraints Using the Portfolio Function . . . . . . . 4-91 Setting Tracking Error Constraints Using the setTrackingError Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-91\nix",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 9,
      "section_heading": "Working with 'Simple' Bound Constraints Using Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Validate the Portfolio Problem for Portfolio Object  . . . . . . . . . . . . . . . . . 4-94 Validating a Portfolio Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-94 Validating Portfolios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-95\nEstimate Efficient Portfolios for Entire Efficient Frontier for Portfolio Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-98\nObtaining Portfolios Along the Entire Efficient Frontier  . . . . . . . . . . . . . 4-99\nObtaining Endpoints of the Efficient Frontier  . . . . . . . . . . . . . . . . . . . . 4-102\nObtaining Efficient Portfolios for Target Returns  . . . . . . . . . . . . . . . . . 4-105\nObtaining Efficient Portfolios for Target Risks  . . . . . . . . . . . . . . . . . . . . 4-108\nEfficient Portfolio That Maximizes Sharpe Ratio  . . . . . . . . . . . . . . . . . . 4-111",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 10,
      "section_heading": "Validate the Portfolio Problem for Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Obtaining Efficient Portfolios for Target Risks  . . . . . . . . . . . . . . . . . . . . 4-108\nEfficient Portfolio That Maximizes Sharpe Ratio  . . . . . . . . . . . . . . . . . . 4-111\nChoosing and Controlling the Solver for Mean-Variance Portfolio Optimization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-114 Using 'lcprog' and 'quadprog' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-114 Using the Mixed Integer Nonlinear Programming (MINLP) Solver . . . . 4-115 Solver Guidelines for Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . 4-115 Solver Guidelines for Custom Objective Problems Using Portfolio Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-119",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 10,
      "section_heading": "Validate the Portfolio Problem for Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Estimate Efficient Frontiers for Portfolio Object  . . . . . . . . . . . . . . . . . . 4-122 Obtaining Portfolio Risks and Returns . . . . . . . . . . . . . . . . . . . . . . . . . . 4-122\nPlotting the Efficient Frontier for a Portfolio Object  . . . . . . . . . . . . . . . 4-125\nPostprocessing Results to Set Up Tradable Portfolios  . . . . . . . . . . . . . . 4-130\nWhen to Use Portfolio Objects Over Optimization Toolbox  . . . . . . . . . . 4-132 Always Use Portfolio, PortfolioCVaR, or PortfolioMAD Object . . . . . . . . 4-134 Preferred Use of Portfolio, PortfolioCVaR, or PortfolioMAD Object . . . . 4-135 Use Optimization Toolbox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-136\nComparison of Methods for Covariance Estimation  . . . . . . . . . . . . . . . . 4-138\nChoose MINLP Solvers for Portfolio Problems  . . . . . . . . . . . . . . . . . . . . 4-140",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 10,
      "section_heading": "Validate the Portfolio Problem for Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Troubleshooting Portfolio Optimization Results  . . . . . . . . . . . . . . . . . . 4-145 Portfolio Object Destroyed When Modifying . . . . . . . . . . . . . . . . . . . . . 4-145 Optimization Fails with “Bad Pivot” Message . . . . . . . . . . . . . . . . . . . . 4-145 Speed of Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-145 Matrix Incompatibility and \"Non-Conformable\" Errors . . . . . . . . . . . . . 4-145 Missing Data Estimation Fails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-145 mv_optim_transform Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-145 solveContinuousCustomObjProb or solveMICustomObjProb Errors . . . . 4-146 Efficient Portfolios Do Not Make Sense . . . . . . . . . . . . . . . . . . . . . . . . . 4-146 Efficient Frontiers Do Not Make Sense . . . . . . . . . . . . . . . . . . . . . . . . . 4-146 Troubleshooting estimateCustomObjectivePortfolio . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 10,
      "section_heading": "Validate the Portfolio Problem for Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": ". . . . . . . . . . 4-146 Efficient Frontiers Do Not Make Sense . . . . . . . . . . . . . . . . . . . . . . . . . 4-146 Troubleshooting estimateCustomObjectivePortfolio . . . . . . . . . . . . . . . 4-148 Troubleshooting for Setting 'Conditional' BoundType, MinNumAssets, and MaxNumAssets Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-148",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 10,
      "section_heading": "Validate the Portfolio Problem for Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "x Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 10,
      "section_heading": "Validate the Portfolio Problem for Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Role of Convexity in Portfolio Problems  . . . . . . . . . . . . . . . . . . . . . . . . . 4-157 Examples of Convex Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-158 Examples of Concave Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-159 Examples of Nonconvex Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-159\nPortfolio Optimization Examples Using Financial Toolbox  . . . . . . . . . . 4-161\nAsset Allocation Case Study  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-180\nPortfolio Optimization with Semicontinuous and Cardinality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-190\nPortfolio Optimization Against a Benchmark  . . . . . . . . . . . . . . . . . . . . . 4-202\nPortfolio Analysis with Turnover Constraints  . . . . . . . . . . . . . . . . . . . . . 4-211",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 11,
      "section_heading": "Role of Convexity in Portfolio Problems",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Optimization Against a Benchmark  . . . . . . . . . . . . . . . . . . . . . 4-202\nPortfolio Analysis with Turnover Constraints  . . . . . . . . . . . . . . . . . . . . . 4-211\nLeverage in Portfolio Optimization with a Risk-Free Asset  . . . . . . . . . . 4-217\nBlack-Litterman Portfolio Optimization Using Financial Toolbox  . . . . . 4-222\nPortfolio Optimization Using Factor Models  . . . . . . . . . . . . . . . . . . . . . . 4-231\nBacktest Investment Strategies Using Financial Toolbox  . . . . . . . . . . . 4-238\nBacktest Investment Strategies with Trading Signals  . . . . . . . . . . . . . . 4-251\nPortfolio Optimization Using Social Performance Measure  . . . . . . . . . 4-264\nDiversify ESG Portfolios  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-271\nRisk Budgeting Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-286",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 11,
      "section_heading": "Role of Convexity in Portfolio Problems",
      "captions": ""
    }
  },
  {
    "text": "Risk Budgeting Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-286\nBacktest Using Risk-Based Equity Indexation  . . . . . . . . . . . . . . . . . . . . 4-291\nCreate Hierarchical Risk Parity Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . 4-296\nBacktest Strategies Using Deep Learning  . . . . . . . . . . . . . . . . . . . . . . . . 4-302\nBacktest with Brinson Attribution to Evaluate Portfolio Performance 4-315\nAnalyze Performance Attribution Using Brinson Model  . . . . . . . . . . . . 4-323\nDiversify Portfolios Using Custom Objective  . . . . . . . . . . . . . . . . . . . . . . 4-331\nSolve Tracking Error Portfolio Problems  . . . . . . . . . . . . . . . . . . . . . . . . . 4-343\nSolve Problem for Minimum Tracking Error with Net Return Constraint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-349",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 11,
      "section_heading": "Role of Convexity in Portfolio Problems",
      "captions": ""
    }
  },
  {
    "text": "Solve Problem for Minimum Tracking Error with Net Return Constraint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-349\nSolve Robust Portfolio Maximum Return Problem with Ellipsoidal Uncertainty  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-351\nRisk Parity or Budgeting with Constraints  . . . . . . . . . . . . . . . . . . . . . . . 4-357\nxi",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 11,
      "section_heading": "Role of Convexity in Portfolio Problems",
      "captions": ""
    }
  },
  {
    "text": "Single Period Goal-Based Wealth Management  . . . . . . . . . . . . . . . . . . . 4-362\nDynamic Portfolio Allocation in Goal-Based Wealth Management for Multiple Time Periods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-367\nMultiperiod Goal-Based Wealth Management Using Reinforcement Learning  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-379\nCompare Performance of Covariance Denoising with Factor Modeling Using Backtesting  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-394\nMixed-Integer Mean-Variance Portfolio Optimization Problem  . . . . . . 4-402\nDeep Reinforcement Learning for Optimal Trade Execution  . . . . . . . . . 4-407\nBacktest Investment Strategies Using datetime and calendarDuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-451",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 12,
      "section_heading": "CVaR Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Backtest Investment Strategies Using datetime and calendarDuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-451\nAdding Constraints to Satisfy UCITS Directive  . . . . . . . . . . . . . . . . . . . . 4-457\nCVaR Portfolio Optimization Tools 5\nPortfolio Optimization Theory  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3 Portfolio Optimization Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3 Portfolio Problem Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3 Return Proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4 Risk Proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 12,
      "section_heading": "CVaR Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Supported Constraints for Portfolio Optimization Using PortfolioCVaR Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8 Linear Inequality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8 Linear Equality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9 'Simple' Bound Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9 'Conditional' Bound Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10 Budget Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10 Conditional Budget Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11 Group Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11 Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 12,
      "section_heading": "CVaR Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11 Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12 Average Turnover Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13 One-way Turnover Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13 Cardinality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 12,
      "section_heading": "CVaR Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Default Portfolio Problem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\nPortfolioCVaR Object Workflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\nPortfolioCVaR Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17 PortfolioCVaR Object Properties and Functions . . . . . . . . . . . . . . . . . . . . 5-17 Working with PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17 Setting and Getting Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18 Displaying PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\nxii Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 12,
      "section_heading": "CVaR Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Saving and Loading PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . . 5-18 Estimating Efficient Portfolios and Frontiers . . . . . . . . . . . . . . . . . . . . . . 5-18 Arrays of PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19 Subclassing PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20 Conventions for Representation of Data . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\nCreating the PortfolioCVaR Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22 PortfolioCVaR Problem Sufficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22 PortfolioCVaR Function Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 13,
      "section_heading": "Saving and Loading PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Common Operations on the PortfolioCVaR Object  . . . . . . . . . . . . . . . . . . 5-29 Naming a PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-29 Configuring the Assets in the Asset Universe . . . . . . . . . . . . . . . . . . . . . 5-29 Setting Up a List of Asset Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-29 Truncating and Padding Asset Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-31\nSetting Up an Initial or Current Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . . 5-33",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 13,
      "section_heading": "Saving and Loading PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Asset Returns and Scenarios Using PortfolioCVaR Object  . . . . . . . . . . . . 5-36 How Stochastic Optimization Works . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-36 What Are Scenarios? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-36 Setting Scenarios Using the PortfolioCVaR Function . . . . . . . . . . . . . . . . 5-37 Setting Scenarios Using the setScenarios Function . . . . . . . . . . . . . . . . . 5-38 Estimating the Mean and Covariance of Scenarios . . . . . . . . . . . . . . . . . 5-38 Simulating Normal Scenarios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-39 Simulating Normal Scenarios from Returns or Prices . . . . . . . . . . . . . . . 5-39 Simulating Normal Scenarios with Missing Data . . . . . . . . . . . . . . . . . . . 5-40 Simulating Normal Scenarios from Time Series Data . . . . . . . . . . . . . . . 5-42 Simulating Normal Scenarios with Mean and Covariance . . . . . . . . . . . . 5-44",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 13,
      "section_heading": "Saving and Loading PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Working with a Riskless Asset  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-46\nWorking with Transaction Costs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-47 Setting Transaction Costs Using the PortfolioCVaR Function . . . . . . . . . . 5-47 Setting Transaction Costs Using the setCosts Function . . . . . . . . . . . . . . 5-47 Setting Transaction Costs with Scalar Expansion . . . . . . . . . . . . . . . . . . 5-49\nWorking with CVaR Portfolio Constraints Using Defaults  . . . . . . . . . . . . 5-51 Setting Default Constraints for Portfolio Weights Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-51",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 13,
      "section_heading": "Saving and Loading PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Working with 'Simple' Bound Constraints Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-55 Setting 'Simple' Bounds Using the PortfolioCVaR Function . . . . . . . . . . . 5-55 Setting 'Simple' Bounds Using the setBounds Function . . . . . . . . . . . . . . 5-55 Setting 'Simple' Bounds Using the PortfolioCVaR Function or setBounds Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-56\nWorking with Budget Constraints Using PortfolioCVaR Object  . . . . . . . . 5-58 Setting Budget Constraints Using the PortfolioCVaR Function . . . . . . . . 5-58 Setting Budget Constraints Using the setBudget Function . . . . . . . . . . . 5-58\nxiii",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 13,
      "section_heading": "Saving and Loading PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Working with Conditional Budget Constraints Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-60 Setting Conditional Budget Constraints Using the PortfolioCVaR Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-60 Setting Conditional Budget Constraints Using the setConditionalBudget Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-60\nWorking with Group Constraints Using PortfolioCVaR Object  . . . . . . . . 5-62 Setting Group Constraints Using the PortfolioCVaR Function . . . . . . . . . 5-62 Setting Group Constraints Using the setGroups and addGroups Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-62",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 14,
      "section_heading": "Working with Conditional Budget Constraints Using PortfolioCVaR Object",
      "captions": ""
    }
  },
  {
    "text": "Working with Group Ratio Constraints Using PortfolioCVaR Object  . . . 5-65 Setting Group Ratio Constraints Using the PortfolioCVaR Function . . . . . 5-65 Setting Group Ratio Constraints Using the setGroupRatio and addGroupRatio Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-66\nWorking with Linear Equality Constraints Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-68 Setting Linear Equality Constraints Using the PortfolioCVaR Function . . 5-68 Setting Linear Equality Constraints Using the setEquality and addEquality Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-68",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 14,
      "section_heading": "Working with Conditional Budget Constraints Using PortfolioCVaR Object",
      "captions": ""
    }
  },
  {
    "text": "Working with Linear Inequality Constraints Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-70 Setting Linear Inequality Constraints Using the PortfolioCVaR Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-70 Setting Linear Inequality Constraints Using the setInequality and addInequality Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-70",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 14,
      "section_heading": "Working with Conditional Budget Constraints Using PortfolioCVaR Object",
      "captions": ""
    }
  },
  {
    "text": "Working with 'Conditional' BoundType, MinNumAssets, and MaxNumAssets Constraints Using PortfolioCVaR Objects  . . . . . . . . . . 5-72 Setting 'Conditional' BoundType Constraints Using the setBounds Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-72 Setting the Limits on the Number of Assets Invested Using the setMinMaxNumAssets Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-73\nWorking with Average Turnover Constraints Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-75 Setting Average Turnover Constraints Using the PortfolioCVaR Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-75 Setting Average Turnover Constraints Using the setTurnover Function . . 5-75",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 14,
      "section_heading": "Working with Conditional Budget Constraints Using PortfolioCVaR Object",
      "captions": ""
    }
  },
  {
    "text": "Working with One-Way Turnover Constraints Using PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-78 Setting One-Way Turnover Constraints Using the PortfolioCVaR Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-78 Setting Turnover Constraints Using the setOneWayTurnover Function . . 5-78\nValidate the CVaR Portfolio Problem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-81 Validating a CVaR Portfolio Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-81 Validating CVaR Portfolios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-82\nEstimate Efficient Portfolios for Entire Frontier for PortfolioCVaR Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-85\nxiv Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 14,
      "section_heading": "Working with Conditional Budget Constraints Using PortfolioCVaR Object",
      "captions": ""
    }
  },
  {
    "text": "Obtaining Portfolios Along the Entire Efficient Frontier  . . . . . . . . . . . . . 5-86\nObtaining Endpoints of the Efficient Frontier  . . . . . . . . . . . . . . . . . . . . . 5-89\nObtaining Efficient Portfolios for Target Returns  . . . . . . . . . . . . . . . . . . 5-92\nObtaining Efficient Portfolios for Target Risks  . . . . . . . . . . . . . . . . . . . . . 5-95\nChoosing and Controlling the Solver for PortfolioCVaR Optimizations  . 5-98 Using 'TrustRegionCP', 'ExtendedCP', and 'cuttingplane' SolverTypes . . . 5-98 Using 'fmincon' SolverType . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-99 Using the Mixed Integer Nonlinear Programming (MINLP) Solver . . . . 5-100 Solver Guidelines for PortfolioCVaR Objects . . . . . . . . . . . . . . . . . . . . . 5-100",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 15,
      "section_heading": "MAD Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Estimate Efficient Frontiers for PortfolioCVaR Object  . . . . . . . . . . . . . . 5-105 Obtaining CVaR Portfolio Risks and Returns . . . . . . . . . . . . . . . . . . . . . 5-105 Obtaining Portfolio Standard Deviation and VaR . . . . . . . . . . . . . . . . . . 5-106\nPlotting the Efficient Frontier for a PortfolioCVaR Object  . . . . . . . . . . 5-109\nPostprocessing Results to Set Up Tradable Portfolios  . . . . . . . . . . . . . . 5-115\nWorking with Other Portfolio Objects  . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-118",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 15,
      "section_heading": "MAD Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Postprocessing Results to Set Up Tradable Portfolios  . . . . . . . . . . . . . . 5-115\nWorking with Other Portfolio Objects  . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-118\nTroubleshooting CVaR Portfolio Optimization Results  . . . . . . . . . . . . . . 5-121 PortfolioCVaR Object Destroyed When Modifying . . . . . . . . . . . . . . . . . 5-121 Matrix Incompatibility and \"Non-Conformable\" Errors . . . . . . . . . . . . . 5-121 CVaR Portfolio Optimization Warns About “Max Iterations” . . . . . . . . . . 5-121 CVaR Portfolio Optimization Errors with “Could Not Solve” Message . . 5-122 Missing Data Estimation Fails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-122 cvar_optim_transform Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-122 Efficient Portfolios Do Not Make Sense . . . . . . . . . . . . . . . . . . . . . . . . . 5-123\nHedging Using CVaR Portfolio Optimization  . . . . . . . . . . . . . . . . . . . . . 5-125",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 15,
      "section_heading": "MAD Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Hedging Using CVaR Portfolio Optimization  . . . . . . . . . . . . . . . . . . . . . 5-125\nCompute Maximum Reward-to-Risk Ratio for CVaR Portfolio  . . . . . . . . 5-137\nMixed-Integer CVaR Portfolio Optimization Problem  . . . . . . . . . . . . . . 5-141\nBond Portfolio CVaR Optimization Using Diebold-Li Model  . . . . . . . . . 5-146\nMAD Portfolio Optimization Tools 6\nPortfolio Optimization Theory  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3 Portfolio Optimization Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3 Portfolio Problem Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3 Return Proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4 Risk Proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-5\nxv",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 15,
      "section_heading": "MAD Portfolio Optimization Tools",
      "captions": ""
    }
  },
  {
    "text": "Supported Constraints for Portfolio Optimization Using PortfolioMAD Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8 Linear Inequality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8 Linear Equality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-9 'Simple' Bound Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-9 'Conditional' Bound Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-10 Budget Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-10 Conditional Budget Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-11 Group Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-11 Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-11 Group Ratio Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-12 Average Turnover Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13 One-way Turnover Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13 Cardinality Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "Default Portfolio Problem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-15\nPortfolioMAD Object Workflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-16",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "PortfolioMAD Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-17 PortfolioMAD Object Properties and Functions . . . . . . . . . . . . . . . . . . . . 6-17 Working with PortfolioMAD Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-17 Setting and Getting Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18 Displaying PortfolioMAD Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18 Saving and Loading PortfolioMAD Objects . . . . . . . . . . . . . . . . . . . . . . . 6-18 Estimating Efficient Portfolios and Frontiers . . . . . . . . . . . . . . . . . . . . . . 6-18 Arrays of PortfolioMAD Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19 Subclassing PortfolioMAD Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-20 Conventions for Representation of Data . . . . . . . . . . . . . . . . . . . . . . . . . 6-20",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "Creating the PortfolioMAD Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22 PortfolioMAD Problem Sufficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22 PortfolioMAD Function Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-23\nCommon Operations on the PortfolioMAD Object  . . . . . . . . . . . . . . . . . . 6-29 Naming a PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-29 Configuring the Assets in the Asset Universe . . . . . . . . . . . . . . . . . . . . . 6-29 Setting Up a List of Asset Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-29 Truncating and Padding Asset Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-31\nSetting Up an Initial or Current Portfolio  . . . . . . . . . . . . . . . . . . . . . . . . . 6-33",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "Asset Returns and Scenarios Using PortfolioMAD Object  . . . . . . . . . . . . 6-35 How Stochastic Optimization Works . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-35 What Are Scenarios? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-35 Setting Scenarios Using the PortfolioMAD Function . . . . . . . . . . . . . . . . 6-36 Setting Scenarios Using the setScenarios Function . . . . . . . . . . . . . . . . . 6-37 Estimating the Mean and Covariance of Scenarios . . . . . . . . . . . . . . . . . 6-37 Simulating Normal Scenarios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-38 Simulating Normal Scenarios from Returns or Prices . . . . . . . . . . . . . . . 6-38 Simulating Normal Scenarios with Missing Data . . . . . . . . . . . . . . . . . . . 6-39 Simulating Normal Scenarios from Time Series Data . . . . . . . . . . . . . . . 6-41 Simulating Normal Scenarios with Mean and Covariance . . . . . . . . . . . . 6-43",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "Working with a Riskless Asset  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-45\nxvi Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 16,
      "section_heading": "Supported Constraints for Portfolio Optimization Using PortfolioMAD",
      "captions": ""
    }
  },
  {
    "text": "Working with Transaction Costs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-46 Setting Transaction Costs Using the PortfolioMAD Function . . . . . . . . . . 6-46 Setting Transaction Costs Using the setCosts Function . . . . . . . . . . . . . . 6-46 Setting Transaction Costs with Scalar Expansion . . . . . . . . . . . . . . . . . . 6-48\nWorking with MAD Portfolio Constraints Using Defaults  . . . . . . . . . . . . 6-50 Setting Default Constraints for Portfolio Weights Using PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-50",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 17,
      "section_heading": "Working with Transaction Costs",
      "captions": ""
    }
  },
  {
    "text": "Working with 'Simple' Bound Constraints Using PortfolioMAD Object  . 6-54 Setting 'Simple' Bounds Using the PortfolioMAD Function . . . . . . . . . . . 6-54 Setting 'Simple' Bounds Using the setBounds Function . . . . . . . . . . . . . . 6-54 Setting 'Simple' Bounds Using the PortfolioMAD Function or setBounds Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-55\nWorking with Budget Constraints Using PortfolioMAD Object  . . . . . . . . 6-57 Setting Budget Constraints Using the PortfolioMAD Function . . . . . . . . . 6-57 Setting Budget Constraints Using the setBudget Function . . . . . . . . . . . 6-57",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 17,
      "section_heading": "Working with Transaction Costs",
      "captions": ""
    }
  },
  {
    "text": "Working with Conditional Budget Constraints Using PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-59 Setting Conditional Budget Constraints Using the PortfolioMAD Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-59 Setting Conditional Budget Constraints Using the setConditionalBudget Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-59\nWorking with Group Constraints Using PortfolioMAD Object  . . . . . . . . . 6-61 Setting Group Constraints Using the PortfolioMAD Function . . . . . . . . . 6-61 Setting Group Constraints Using the setGroups and addGroups Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-61",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 17,
      "section_heading": "Working with Transaction Costs",
      "captions": ""
    }
  },
  {
    "text": "Working with Group Ratio Constraints Using PortfolioMAD Object  . . . . 6-64 Setting Group Ratio Constraints Using the PortfolioMAD Function . . . . . 6-64 Setting Group Ratio Constraints Using the setGroupRatio and addGroupRatio Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-65\nWorking with Linear Equality Constraints Using PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-67 Setting Linear Equality Constraints Using the PortfolioMAD Function . . 6-67 Setting Linear Equality Constraints Using the setEquality and addEquality Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-67",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 17,
      "section_heading": "Working with Transaction Costs",
      "captions": ""
    }
  },
  {
    "text": "Working with Linear Inequality Constraints Using PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-69 Setting Linear Inequality Constraints Using the PortfolioMAD Function . 6-69 Setting Linear Inequality Constraints Using the setInequality and addInequality Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-69\nWorking with 'Conditional' BoundType, MinNumAssets, and MaxNumAssets Constraints Using PortfolioMAD Objects  . . . . . . . . . . 6-71 Setting 'Conditional' BoundType Constraints Using the setBounds Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-71 Setting the Limits on the Number of Assets Invested Using the setMinMaxNumAssets Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-72\nxvii",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 17,
      "section_heading": "Working with Transaction Costs",
      "captions": ""
    }
  },
  {
    "text": "Working with Average Turnover Constraints Using PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-74 Setting Average Turnover Constraints Using the PortfolioMAD Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-74 Setting Average Turnover Constraints Using the setTurnover Function . . 6-74\nWorking with One-Way Turnover Constraints Using PortfolioMAD Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-77 Setting One-Way Turnover Constraints Using the PortfolioMAD Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-77 Setting Turnover Constraints Using the setOneWayTurnover Function . . 6-77",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 18,
      "section_heading": "Working with Average Turnover Constraints Using PortfolioMAD Object",
      "captions": ""
    }
  },
  {
    "text": "Validate the MAD Portfolio Problem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-80 Validating a MAD Portfolio Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-80 Validating MAD Portfolios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-81\nEstimate Efficient Portfolios Along the Entire Frontier for PortfolioMAD Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-84\nObtaining Portfolios Along the Entire Efficient Frontier  . . . . . . . . . . . . . 6-85\nObtaining Endpoints of the Efficient Frontier  . . . . . . . . . . . . . . . . . . . . . 6-87\nMixed-Integer MAD Portfolio Optimization Problem  . . . . . . . . . . . . . . . . 6-89\nObtaining Efficient Portfolios for Target Returns  . . . . . . . . . . . . . . . . . . 6-93\nObtaining Efficient Portfolios for Target Risks  . . . . . . . . . . . . . . . . . . . . . 6-96",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 18,
      "section_heading": "Working with Average Turnover Constraints Using PortfolioMAD Object",
      "captions": ""
    }
  },
  {
    "text": "Obtaining Efficient Portfolios for Target Returns  . . . . . . . . . . . . . . . . . . 6-93\nObtaining Efficient Portfolios for Target Risks  . . . . . . . . . . . . . . . . . . . . . 6-96\nChoosing and Controlling the Solver for PortfolioMAD Optimizations  . 6-99 Using 'TrustRegionCP' and 'ExtendedCP' SolverTypes . . . . . . . . . . . . . . 6-99 Using 'fmincon' SolverType . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-100 Using the Mixed Integer Nonlinear Programming (MINLP) Solver . . . . 6-101 Solver Guidelines for PortfolioMAD Objects . . . . . . . . . . . . . . . . . . . . . 6-101\nEstimate Efficient Frontiers for PortfolioMAD Object  . . . . . . . . . . . . . . 6-105 Obtaining MAD Portfolio Risks and Returns . . . . . . . . . . . . . . . . . . . . . 6-105 Obtaining the PortfolioMAD Standard Deviation . . . . . . . . . . . . . . . . . . 6-106\nPlotting the Efficient Frontier for a PortfolioMAD Object  . . . . . . . . . . . 6-108",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 18,
      "section_heading": "Working with Average Turnover Constraints Using PortfolioMAD Object",
      "captions": ""
    }
  },
  {
    "text": "Plotting the Efficient Frontier for a PortfolioMAD Object  . . . . . . . . . . . 6-108\nPostprocessing Results to Set Up Tradable Portfolios  . . . . . . . . . . . . . . 6-113\nWorking with Other Portfolio Objects  . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-115\nTroubleshooting MAD Portfolio Optimization Results  . . . . . . . . . . . . . . 6-118 PortfolioMAD Object Destroyed When Modifying . . . . . . . . . . . . . . . . . 6-118 Matrix Incompatibility and \"Non-Conformable\" Errors . . . . . . . . . . . . . 6-118 Missing Data Estimation Fails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-118 mad_optim_transform Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-118 Efficient Portfolios Do Not Make Sense . . . . . . . . . . . . . . . . . . . . . . . . . 6-119\nxviii Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 18,
      "section_heading": "Working with Average Turnover Constraints Using PortfolioMAD Object",
      "captions": ""
    }
  },
  {
    "text": "Investment Performance Metrics 7\nPerformance Metrics Overview  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-2 Performance Metrics Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-2\nPerformance Metrics Illustration  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-3\nUsing the Sharpe Ratio  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-5\nUsing the Information Ratio  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nUsing Tracking Error  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-8\nUsing Risk-Adjusted Return  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 19,
      "section_heading": "Investment Performance Metrics",
      "captions": ""
    }
  },
  {
    "text": "Using Risk-Adjusted Return  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-9\nUsing Sample and Expected Lower Partial Moments  . . . . . . . . . . . . . . . . 7-11 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11 Sample Lower Partial Moments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11 Expected Lower Partial Moments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nUsing Maximum and Expected Maximum Drawdown  . . . . . . . . . . . . . . . . 7-14 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14 Maximum Drawdown . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14 Expected Maximum Drawdown . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-16\nCredit Risk Analysis 8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 19,
      "section_heading": "Investment Performance Metrics",
      "captions": ""
    }
  },
  {
    "text": "Estimation of Transition Probabilities  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2 Estimate Transition Probabilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2 Estimate Transition Probabilities for Different Rating Scales . . . . . . . . . . 8-4 Working with a Transition Matrix Containing NR Rating . . . . . . . . . . . . . . 8-6 Estimate Point-in-Time and Through-the-Cycle Probabilities . . . . . . . . . . 8-10 Estimate t-Year Default Probabilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12 Estimate Bootstrap Confidence Intervals . . . . . . . . . . . . . . . . . . . . . . . . 8-13 Group Credit Ratings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15 Work with Nonsquare Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17 Remove Outliers . . . . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 19,
      "section_heading": "Investment Performance Metrics",
      "captions": ""
    }
  },
  {
    "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15 Work with Nonsquare Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17 Remove Outliers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-18 Estimate Probabilities for Different Segments . . . . . . . . . . . . . . . . . . . . . 8-19 Work with Large Datasets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 19,
      "section_heading": "Investment Performance Metrics",
      "captions": ""
    }
  },
  {
    "text": "Forecasting Corporate Default Rates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-23\nCredit Quality Thresholds  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-45 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-45 Compute Credit Quality Thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-45 Visualize Credit Quality Thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-46\nxix",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 19,
      "section_heading": "Investment Performance Metrics",
      "captions": ""
    }
  },
  {
    "text": "About Credit Scorecards  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-49 What Is a Credit Scorecard? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-49 Credit Scorecard Development Process . . . . . . . . . . . . . . . . . . . . . . . . . 8-50\nCredit Scorecard Modeling Workflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-52\nCredit Scorecard Modeling Using Observation Weights  . . . . . . . . . . . . . 8-55\nCredit Scorecard Modeling with Missing Values  . . . . . . . . . . . . . . . . . . . 8-57",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 20,
      "section_heading": "Regression with Missing Data",
      "captions": ""
    }
  },
  {
    "text": "Credit Scorecard Modeling Using Observation Weights  . . . . . . . . . . . . . 8-55\nCredit Scorecard Modeling with Missing Values  . . . . . . . . . . . . . . . . . . . 8-57\nTroubleshooting Credit Scorecard Results  . . . . . . . . . . . . . . . . . . . . . . . . 8-64 Predictor Name Is Unspecified and the Parser Returns an Error . . . . . . . 8-64 Using bininfo or plotbins Before Binning . . . . . . . . . . . . . . . . . . . . . . . . . 8-64 If Categorical Data Is Given as Numeric . . . . . . . . . . . . . . . . . . . . . . . . . 8-66 NaNs Returned When Scoring a “Test” Dataset . . . . . . . . . . . . . . . . . . . 8-68\nCase Study for Credit Scorecard Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . 8-71\nCredit Scorecards with Constrained Logistic Regression Coefficients  . . 8-91\nCredit Default Swap (CDS)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-100",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 20,
      "section_heading": "Regression with Missing Data",
      "captions": ""
    }
  },
  {
    "text": "Credit Scorecards with Constrained Logistic Regression Coefficients  . . 8-91\nCredit Default Swap (CDS)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-100\nBootstrapping a Default Probability Curve  . . . . . . . . . . . . . . . . . . . . . . . 8-101\nFinding Breakeven Spread for New CDS Contract  . . . . . . . . . . . . . . . . . 8-104\nValuing an Existing CDS Contract  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-107\nConverting from Running to Upfront  . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-109\nBootstrapping from Inverted Market Curves  . . . . . . . . . . . . . . . . . . . . . 8-111\nVisualize Transitions Data for transprob  . . . . . . . . . . . . . . . . . . . . . . . . . 8-114\nImpute Missing Data in the Credit Scorecard Workflow Using the k- Nearest Neighbors Algorithm  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-121",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 20,
      "section_heading": "Regression with Missing Data",
      "captions": ""
    }
  },
  {
    "text": "Impute Missing Data in the Credit Scorecard Workflow Using the k- Nearest Neighbors Algorithm  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-121\nImpute Missing Data in the Credit Scorecard Workflow Using the Random Forest Algorithm  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-127\nTreat Missing Data in a Credit Scorecard Workflow Using MATLAB fillmissing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-132\nRegression with Missing Data 9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 20,
      "section_heading": "Regression with Missing Data",
      "captions": ""
    }
  },
  {
    "text": "Regression with Missing Data 9\nMultivariate Normal Regression  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-2 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-2 Multivariate Normal Linear Regression . . . . . . . . . . . . . . . . . . . . . . . . . . 9-2 Maximum Likelihood Estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3 Special Case of Multiple Linear Regression Model . . . . . . . . . . . . . . . . . . 9-4\nxx Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 20,
      "section_heading": "Regression with Missing Data",
      "captions": ""
    }
  },
  {
    "text": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4 Mean and Covariance Estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4 Convergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4 Fisher Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4 Statistical Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Maximum Likelihood Estimation with Missing Data  . . . . . . . . . . . . . . . . . 9-7 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-7 ECM Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-7 Standard Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-8 Data Augmentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Multivariate Normal Regression Functions  . . . . . . . . . . . . . . . . . . . . . . . 9-10 Multivariate Normal Regression Without Missing Data . . . . . . . . . . . . . . 9-11 Multivariate Normal Regression With Missing Data . . . . . . . . . . . . . . . . 9-11 Least-Squares Regression With Missing Data . . . . . . . . . . . . . . . . . . . . . 9-11 Multivariate Normal Parameter Estimation With Missing Data . . . . . . . . 9-12 Support Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-12",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Multivariate Normal Regression Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-13 Regressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-13 Multivariate Normal Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-13 Multivariate Normal Regression Without Missing Data . . . . . . . . . . . . . . 9-13 Multivariate Normal Regression With Missing Data . . . . . . . . . . . . . . . . 9-14 Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-14 Least-Squares Regression Without Missing Data . . . . . . . . . . . . . . . . . . . 9-14 Least-Squares Regression With Missing Data . . . . . . . . . . . . . . . . . . . . . 9-14 Covariance-Weighted Least Squares . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-14 Covariance-Weighted Least Squares Without Missing Data . . . . . . . . . . . 9-15 Covariance-Weighted Least Squares With Missing Data . . . . . . .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": ". . . . . . . . . . . . . . . . . . . . . . . 9-14 Covariance-Weighted Least Squares Without Missing Data . . . . . . . . . . . 9-15 Covariance-Weighted Least Squares With Missing Data . . . . . . . . . . . . . 9-15 Feasible Generalized Least Squares . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-15 Feasible Generalized Least Squares Without Missing Data . . . . . . . . . . . 9-15 Feasible Generalized Least Squares With Missing Data . . . . . . . . . . . . . . 9-16 Seemingly Unrelated Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-16 Seemingly Unrelated Regression Without Missing Data . . . . . . . . . . . . . 9-17 Seemingly Unrelated Regression With Missing Data . . . . . . . . . . . . . . . . 9-17 Mean and Covariance Parameter Estimation . . . . . . . . . . . . . . . . . . . . . . 9-17",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Troubleshooting Multivariate Normal Regression  . . . . . . . . . . . . . . . . . . 9-18 Biased Estimates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-18 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-18 Slow Convergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-18 Nonrandom Residuals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-19 Nonconvergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-19\nPortfolios with Missing Data  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-21",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Portfolios with Missing Data  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-21\nValuation with Missing Data  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-26 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-26 Capital Asset Pricing Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-26 Estimation of the CAPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-27 Estimation with Missing Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-27 Estimation of Some Technology Stock Betas . . . . . . . . . . . . . . . . . . . . . . 9-27 Grouped Estimation of Some Technology Stock Betas . . . . . . . . . . . . . . . 9-30 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-32\nxxi",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 21,
      "section_heading": "Least-Squares Regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": ""
    }
  },
  {
    "text": "Capital Asset Pricing Model with Missing Data  . . . . . . . . . . . . . . . . . . . . 9-34\nSolving Sample Problems 10\nSensitivity of Bond Prices to Interest Rates  . . . . . . . . . . . . . . . . . . . . . . . 10-2\nBond Portfolio for Hedging Duration and Convexity  . . . . . . . . . . . . . . . . 10-6\nBond Prices and Yield Curve Parallel Shifts  . . . . . . . . . . . . . . . . . . . . . . . 10-9\nBond Prices and Yield Curve Nonparallel Shifts  . . . . . . . . . . . . . . . . . . . 10-12\nGreek-Neutral Portfolios of European Stock Options  . . . . . . . . . . . . . . . 10-14\nTerm Structure Analysis and Interest-Rate Swaps  . . . . . . . . . . . . . . . . . 10-18\nPlotting an Efficient Frontier Using portopt  . . . . . . . . . . . . . . . . . . . . . . 10-22\nPlotting Sensitivities of an Option  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-25\nPlotting Sensitivities of a Portfolio of Options  . . . . . . . . . . . . . . . . . . . . 10-27",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 22,
      "section_heading": "Solving Sample Problems",
      "captions": ""
    }
  },
  {
    "text": "Plotting Sensitivities of an Option  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-25\nPlotting Sensitivities of a Portfolio of Options  . . . . . . . . . . . . . . . . . . . . 10-27\nBond Portfolio Optimization Using Portfolio Object  . . . . . . . . . . . . . . . 10-30\nHedge Options Using Reinforcement Learning Toolbox  . . . . . . . . . . . . 10-40\nHedge Using Monte Carlo Simulation  . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-49\nUsing Extreme Value Theory and Copula Fitting to Generate Synthetic Data  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-61\nUsing Financial Timetables 11",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 22,
      "section_heading": "Solving Sample Problems",
      "captions": ""
    }
  },
  {
    "text": "Using Financial Timetables 11\nConvert Financial Time Series Objects (fints) to Timetables  . . . . . . . . . 11-2 Create Time Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-2 Index an Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3 Transform Time Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3 Convert Time Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4 Merge Time Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5 Analyze Time Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5 Data Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-6\nUse Timetables in Finance  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\nxxii Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 22,
      "section_heading": "Solving Sample Problems",
      "captions": ""
    }
  },
  {
    "text": "Trading Date Utilities 12\nTrading Calendars User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nUICalendar User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4 Using UICalendar in Standalone Mode . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4 Using UICalendar with an Application . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\nTechnical Analysis 13\nTechnical Indicators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-2\nStochastic Differential Equations 14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 23,
      "section_heading": "Trading Date Utilities",
      "captions": ""
    }
  },
  {
    "text": "Technical Analysis 13\nTechnical Indicators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-2\nStochastic Differential Equations 14\nSDEs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2 SDE Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2 Trials vs. Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-3 NTrials, NPeriods, and NSteps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-3\nSDE Class Hierarchy  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 23,
      "section_heading": "Trading Date Utilities",
      "captions": ""
    }
  },
  {
    "text": "SDE Class Hierarchy  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-5\nSDE Models  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-7 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-7 Creating SDE Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-7 Drift and Diffusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-10 Available SDE Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11 SDE Simulation and Interpolation Methods . . . . . . . . . . . . . . . . . . . . . . 14-13",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 23,
      "section_heading": "Trading Date Utilities",
      "captions": ""
    }
  },
  {
    "text": "Base SDE Models  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-16 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-16 Specify Base Stochastic Differential Equation (SDE) Model . . . . . . . . . . 14-16\nDrift and Diffusion Models  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19 Specify Drift and Diffusion Rate Functions . . . . . . . . . . . . . . . . . . . . . . 14-19 Specify SDEDDO with Drift and Diffusion Functions . . . . . . . . . . . . . . . 14-20",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 23,
      "section_heading": "Trading Date Utilities",
      "captions": ""
    }
  },
  {
    "text": "Linear Drift Models  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22 Specify SDELD Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\nParametric Models  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-24 Creating Brownian Motion (BM) Models . . . . . . . . . . . . . . . . . . . . . . . . 14-24 Specify Brownian Motion Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-24 Creating Constant Elasticity of Variance (CEV) Models . . . . . . . . . . . . . 14-25\nxxiii",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 23,
      "section_heading": "Trading Date Utilities",
      "captions": ""
    }
  },
  {
    "text": "Creating Geometric Brownian Motion (GBM) Models . . . . . . . . . . . . . . 14-25 Creating Stochastic Differential Equations from Mean-Reverting Drift (SDEMRD) Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-26 Creating Cox-Ingersoll-Ross (CIR) Square Root Diffusion Models . . . . . 14-27 Creating Hull-White/Vasicek (HWV) Gaussian Diffusion Models . . . . . . . 14-28 Creating Heston Stochastic Volatility Models . . . . . . . . . . . . . . . . . . . . 14-29\nSimulating Equity Prices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-31 Simulating Multidimensional Market Models . . . . . . . . . . . . . . . . . . . . 14-31 Induce Dependence and Correlation Between States . . . . . . . . . . . . . . 14-41 Dynamic Behavior of Market Parameters . . . . . . . . . . . . . . . . . . . . . . . 14-43 Price European Stock Options Using Monte Carlo Simulation . . . . . . . . 14-47",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 24,
      "section_heading": "Functions",
      "captions": ""
    }
  },
  {
    "text": "Simulating Interest Rates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-50 Simulate Interest Rates Through Interpolation . . . . . . . . . . . . . . . . . . . 14-50 Simulate Positive Interest Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-54\nStratified Sampling  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-58\nQuasi-Monte Carlo Simulation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-63\nPerformance Considerations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-65 Managing Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-65 Enhancing Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-66 Optimizing Accuracy: About Solution Precision and Error . . . . . . . . . . . 14-66",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 24,
      "section_heading": "Functions",
      "captions": ""
    }
  },
  {
    "text": "Price American Basket Options Using Standard Monte Carlo and Quasi- Monte Carlo Simulation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-71\nVolatility Modeling for Soft Commodities  . . . . . . . . . . . . . . . . . . . . . . . . 14-88\nImproving Performance of Monte Carlo Simulation with Parallel Computing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-111\nFunctions 15\nBibliography A",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 24,
      "section_heading": "Functions",
      "captions": ""
    }
  },
  {
    "text": "Functions 15\nBibliography A\nBibliography  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-2 Bond Pricing and Yields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-2 Term Structure of Interest Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-2 Derivatives Pricing and Yields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-3 Portfolio Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-3 Investment Performance Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-3 Financial Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-4 Standard References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-4 Credit Risk Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-5\nxxiv Contents",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 24,
      "section_heading": "Functions",
      "captions": ""
    }
  },
  {
    "text": "Credit Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-5 Portfolio Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-5 Stochastic Differential Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-6 Life Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-6\nxxv",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 25,
      "section_heading": "Credit Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
      "captions": "Credit Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-5 Portfolio Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-5 Stochastic Differential Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-6 Life Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-6"
    }
  },
  {
    "text": "Getting Started\n• “Financial Toolbox Product Description” on page 1-2\n• “Expected Users” on page 1-3\n• “Analyze Sets of Numbers Using Matrix Functions” on page 1-4\n• “Matrix Algebra Refresher” on page 1-7\n• “Using Input and Output Arguments with Functions” on page 1-15\n1",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 27,
      "section_heading": "Getting Started",
      "captions": ""
    }
  },
  {
    "text": "Financial Toolbox Product Description Analyze financial data and develop financial models\nFinancial Toolbox provides functions for the mathematical modeling and statistical analysis of financial data. You can analyze, backtest, and optimize investment portfolios taking into account turnover, transaction costs, semi-continuous constraints, and minimum or maximum number of assets. The toolbox enables you to estimate risk, model credit scorecards, analyze yield curves, price fixed-income instruments and European options, and measure investment performance.\nStochastic differential equation (SDE) tools let you model and simulate a variety of stochastic processes. Time series analysis functions let you perform transformations or regressions with missing data and convert between different trading calendars and day-count conventions.\n1 Getting Started\n1-2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 28,
      "section_heading": "Financial Toolbox Product Description",
      "captions": ""
    }
  },
  {
    "text": "Expected Users\nIn general, this guide assumes experience working with financial derivatives and some familiarity with the underlying models.\nIn designing Financial Toolbox documentation, we assume that your title is like one of these:\n• Analyst, quantitative analyst\n• Risk manager\n• Portfolio manager\n• Asset allocator\n• Financial engineer\n• Trader\n• Student, professor, or other academic\nWe also assume that your background, education, training, and responsibilities match some aspects of this profile:\n• Finance, economics, perhaps accounting\n• Engineering, mathematics, physics, other quantitative sciences\n• Focus on quantitative approaches to financial problems\nExpected Users\n1-3",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 29,
      "section_heading": "Expected Users",
      "captions": ""
    }
  },
  {
    "text": "Analyze Sets of Numbers Using Matrix Functions\nIn this section...\n“Introduction” on page 1-4\n“Key Definitions” on page 1-4\n“Referencing Matrix Elements” on page 1-4\n“Transposing Matrices” on page 1-5\nIntroduction\nMany financial analysis procedures involve  sets  of numbers; for example, a portfolio of securities at various prices and yields. Matrices, matrix functions, and matrix algebra are the most efficient ways to analyze sets of numbers and their relationships. Spreadsheets focus on individual cells and the relationships between cells. While you can think of a set of spreadsheet cells (a range of rows and columns) as a matrix, a matrix-oriented tool like MATLAB ®  software manipulates sets of numbers more quickly, easily, and naturally. For more information, see “Matrix Algebra Refresher” on page 1- 7.\nKey Definitions\nMatrix",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 30,
      "section_heading": "Analyze Sets of Numbers Using Matrix Functions",
      "captions": ""
    }
  },
  {
    "text": "Key Definitions\nMatrix\nA rectangular array of numeric or algebraic quantities subject to mathematical operations; the regular formation of elements into rows and columns. Described as a “ m -by- n ” matrix, with  m  the number of rows and  n  the number of columns. The description is always “row-by-column.” For example, here is a  2 -by- 3  matrix of two bonds (the rows) with different par values, coupon rates, and coupon payment frequencies per year (the columns) entered using MATLAB notation:\nBonds = [1000   0.06   2           500   0.055  4]\nVector\nA matrix with only one row or column. Described as a “ 1 -by- n ” or “ m -by- 1 ” matrix. The description is always “row-by-column.” For example, here is a  1 -by- 4  vector of cash flows in MATLAB notation:\nCash = [1500   4470   5280   -1299]\nScalar\nA  1 -by- 1  matrix; that is, a single number.\nReferencing Matrix Elements\nTo reference specific matrix elements, use (row, column) notation. For example:\nBonds(1,2)\nans =\n0.06",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 30,
      "section_heading": "Analyze Sets of Numbers Using Matrix Functions",
      "captions": ""
    }
  },
  {
    "text": "Scalar\nA  1 -by- 1  matrix; that is, a single number.\nReferencing Matrix Elements\nTo reference specific matrix elements, use (row, column) notation. For example:\nBonds(1,2)\nans =\n0.06\n1 Getting Started\n1-4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 30,
      "section_heading": "Analyze Sets of Numbers Using Matrix Functions",
      "captions": ""
    }
  },
  {
    "text": "Cash(3)\nans =\n5280.00\nYou can enlarge matrices using small matrices or vectors as elements. For example,\nAddBond = [1000   0.065   2]; Bonds = [Bonds; AddBond]\nadds another row to the matrix and creates\nBonds =\n1000   0.06    2         500   0.055   4        1000   0.065   2\nLikewise,\nPrices = [987.50           475.00           995.00]\nBonds = [Prices, Bonds]\nadds another column and creates\nBonds =\n987.50   1000   0.06    2     475.00    500   0.055   4     995.00   1000   0.065   2\nFinally, the colon ( : ) is important in generating and referencing matrix elements. For example, to reference the par value, coupon rate, and coupon frequency of the second bond:\nBondItems = Bonds(2, 2:4)\nBondItems =\n500.00   0.055   4\nTransposing Matrices\nSometimes matrices are in the wrong configuration for an operation. In MATLAB, the apostrophe or prime character ( ' ) transposes a matrix: columns become rows, rows become columns. For example,\nCash = [1500   4470   5280   -1299]'\nproduces\nCash =",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 31,
      "section_heading": "Transposing Matrices",
      "captions": ""
    }
  },
  {
    "text": "Cash = [1500   4470   5280   -1299]'\nproduces\nCash =\n1500         4470         5280        -1299\nAnalyze Sets of Numbers Using Matrix Functions\n1-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 31,
      "section_heading": "Transposing Matrices",
      "captions": ""
    }
  },
  {
    "text": "See Also\nMore About\n• “Matrix Algebra Refresher” on page 1-7\n• “Using Input and Output Arguments with Functions” on page 1-15\n1 Getting Started\n1-6",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 32,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Matrix Algebra Refresher\nIn this section...\n“Introduction” on page 1-7\n“Adding and Subtracting Matrices” on page 1-7\n“Multiplying Matrices” on page 1-8\n“Dividing Matrices” on page 1-11\n“Solving Simultaneous Linear Equations” on page 1-11\n“Operating Element by Element” on page 1-13\nIntroduction\nThe explanations in the sections that follow should help refresh your skills for using matrix algebra and using MATLAB functions.\nIn addition,  Macro-Investment Analysis  by William Sharpe also provides an excellent explanation of matrix algebra operations using MATLAB. It is available on the web at:\nhttps://www.stanford.edu/~wfsharpe/mia/mia.htm",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 33,
      "section_heading": "Matrix Algebra Refresher",
      "captions": ""
    }
  },
  {
    "text": "https://www.stanford.edu/~wfsharpe/mia/mia.htm\nTip  When you are setting up a problem, it helps to \"talk through\" the units and dimensions associated with each input and output matrix. In the example under “Multiplying Matrices” on page 1-8, one input matrix has five days' closing prices for three stocks, the other input matrix has shares of three stocks in two portfolios, and the output matrix therefore has five days' closing values for two portfolios. It also helps to name variables using descriptive terms.\nAdding and Subtracting Matrices",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 33,
      "section_heading": "Matrix Algebra Refresher",
      "captions": ""
    }
  },
  {
    "text": "Adding and Subtracting Matrices\nMatrix addition and subtraction operate element-by-element. The two input matrices must have the same dimensions. The result is a new matrix of the same dimensions where each element is the sum or difference of each corresponding input element. For example, consider combining portfolios of different quantities of the same stocks (“shares of stocks A, B, and C [the rows] in portfolios P and Q [the columns] plus shares of A, B, and C in portfolios R and S”).\nPortfolios_PQ = [100   200                  500   400                  300   150];\nPortfolios_RS = [175   125                  200   200                  100   500];\nNewPortfolios = Portfolios_PQ + Portfolios_RS\nNewPortfolios =\n275           325         700           600         400           650\nMatrix Algebra Refresher\n1-7",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 33,
      "section_heading": "Matrix Algebra Refresher",
      "captions": ""
    }
  },
  {
    "text": "Adding or subtracting a scalar and a matrix is allowed and also operates element-by-element.\nSmallerPortf = NewPortfolios-10\nSmallerPortf =         265.00        315.00         690.00        590.00         390.00        640.00\nMultiplying Matrices\nMatrix multiplication does  not  operate element-by-element. It operates according to the rules of linear algebra. In multiplying matrices, it helps to remember this key rule: the inner dimensions must be the same. That is, if the first matrix is  m -by- 3 , the second must be  3 -by- n . The resulting matrix is m -by- n . It also helps to “talk through” the units of each matrix, as mentioned in “Analyze Sets of Numbers Using Matrix Functions” on page 1-4.\nMatrix multiplication also is  not  commutative; that is, it is not independent of order. A*B does  not equal B*A. The dimension rule illustrates this property. If A is  1 -by- 3  matrix and B is  3 -by- 1  matrix, A*B yields a scalar ( 1 -by- 1 ) matrix but B*A yields a  3 -by- 3  matrix.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 34,
      "section_heading": "Multiplying Matrices",
      "captions": ""
    }
  },
  {
    "text": "Multiplying Vectors\nVector multiplication follows the same rules and helps illustrate the principles. For example, a stock portfolio has three different stocks and their closing prices today are:\nClosePrices = [42.5   15   78.875]\nThe portfolio contains these numbers of shares of each stock.\nNumShares = [100              500              300]\nTo find the value of the portfolio, multiply the vectors\nPortfValue = ClosePrices * NumShares\nwhich yields:\nPortfValue =\n3.5413e+004\nThe vectors are  1 -by- 3  and  3 -by- 1 ; the resulting vector is  1 -by- 1 , a scalar. Multiplying these vectors thus means multiplying each closing price by its respective number of shares and summing the result.\nTo illustrate order dependence, switch the order of the vectors\nValues = NumShares * ClosePrices\nValues =\n1.0e+004 *\n0.4250    0.1500    0.7887     2.1250    0.7500    3.9438     1.2750    0.4500    2.3663\n1 Getting Started\n1-8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 34,
      "section_heading": "Multiplying Matrices",
      "captions": ""
    }
  },
  {
    "text": "which shows the closing values of 100, 500, and 300 shares of each stock, not the portfolio value, and this is meaningless for this example.\nComputing Dot Products of Vectors\nIn matrix algebra, if  X  and  Y  are vectors of the same length\nY  =  y 1 ,  y 2 , …,  y n\nX  =  x 1 ,  x 2 , …,  x n\nthen the dot product\nX  ·  Y  =  x 1 y 1  +  x 2 y 2  + … +  x n y n\nis the scalar product of the two vectors. It is an exception to the commutative rule. To compute the dot product in MATLAB, use  sum(X .* Y)  or  sum(Y .* X) . Be sure that the two vectors have the same dimensions. To illustrate, use the previous vectors.\nValue = sum(NumShares .* ClosePrices')\nValue =\n3.5413e+004\nValue = sum(ClosePrices .* NumShares')\nValue =\n3.5413e+004\nAs expected, the value in these cases matches the  PortfValue  computed previously.\nMultiplying Vectors and Matrices",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 35,
      "section_heading": "which shows the closing values of 100, 500, and 300 shares of each stock, not the portfolio value, and",
      "captions": ""
    }
  },
  {
    "text": "Value =\n3.5413e+004\nValue = sum(ClosePrices .* NumShares')\nValue =\n3.5413e+004\nAs expected, the value in these cases matches the  PortfValue  computed previously.\nMultiplying Vectors and Matrices\nMultiplying vectors and matrices follows the matrix multiplication rules and process. For example, a portfolio matrix contains closing prices for a week. A second matrix (vector) contains the stock quantities in the portfolio.\nWeekClosePr = [42.5     15      78.875                42.125   15.5    78.75                42.125   15.125  79                42.625   15.25   78.875                43       15.25   78.625]; PortQuan = [100             500             300];\nTo see the closing portfolio value for each day, simply multiply\nWeekPortValue = WeekClosePr * PortQuan\nWeekPortValue =\n1.0e+004 *\n3.5412     3.5587\nMatrix Algebra Refresher\n1-9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 35,
      "section_heading": "which shows the closing values of 100, 500, and 300 shares of each stock, not the portfolio value, and",
      "captions": ""
    }
  },
  {
    "text": "3.5475     3.5550     3.5513\nThe prices matrix is  5 -by- 3 , the quantity matrix (vector) is  3 -by- 1 , so the resulting matrix (vector) is  5 - by- 1 .\nMultiplying Two Matrices\nMatrix multiplication also follows the rules of matrix algebra. In matrix algebra notation, if  A  is an  m - by- n  matrix and  B  is an  n -by- p  matrix\nA  =\na 11  a 12  ⋯ a 1 n ⋮ ⋮ ⋮ a i 1 a i 2  ⋯ a in ⋮ ⋮ ⋮ a m 1  a m 2  ⋯ a mn\n,    B  =\nb 11  ⋯ b 1  j  ⋯ b 1 p b 21  ⋯ b 2  j  ⋯ b 2 p ⋮ ⋮ ⋮ b n 1  ⋯ b n j  ⋯ b np\nthen  C = A * B  is an  m -by- p  matrix; and the element  c ij  in the  i th row and  j th column of  C  is\nc i j  =  a i 1 b 1  j  +  a i 2 b 12  + … +  a in b n j  .\nTo illustrate, assume that there are two portfolios of the same three stocks previously mentioned but with different quantities.\nPortfolios = [100   200               500   400               300   150];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 36,
      "section_heading": "The prices matrix is",
      "captions": ""
    }
  },
  {
    "text": "Portfolios = [100   200               500   400               300   150];\nMultiplying the  5 -by- 3  week's closing prices matrix by the  3 -by- 2  portfolios matrix yields a  5 -by- 2 matrix showing each day's closing value for both portfolios.\nPortfolioValues = WeekClosePr * Portfolios\nPortfolioValues =\n1.0e+004 *\n3.5412    2.6331     3.5587    2.6437     3.5475    2.6325     3.5550    2.6456     3.5513    2.6494\nMonday's values result from multiplying each Monday closing price by its respective number of shares and summing the result for the first portfolio, then doing the same for the second portfolio. Tuesday's values result from multiplying each Tuesday closing price by its respective number of shares and summing the result for the first portfolio, then doing the same for the second portfolio. And so on, through the rest of the week. With one simple command, MATLAB quickly performs many calculations.\nMultiplying a Matrix by a Scalar",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 36,
      "section_heading": "The prices matrix is",
      "captions": ""
    }
  },
  {
    "text": "Multiplying a Matrix by a Scalar\nMultiplying a matrix by a scalar is an exception to the dimension and commutative rules. It just operates element-by-element.\n1 Getting Started\n1-10",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 36,
      "section_heading": "The prices matrix is",
      "captions": ""
    }
  },
  {
    "text": "Portfolios = [100   200               500   400               300   150];\nDoublePort = Portfolios * 2\nDoublePort =         200           400        1000           800         600           300\nDividing Matrices\nMatrix division is useful primarily for solving equations, and especially for solving simultaneous linear equations (see “Solving Simultaneous Linear Equations” on page 1-11). For example, you want to solve for  X  in  A * X  =  B.\nIn ordinary algebra, you would divide both sides of the equation by  A , and  X  would equal  B/A . However, since matrix algebra is not commutative  (A * X  ≠  X * A) , different processes apply. In formal matrix algebra, the solution involves matrix inversion. MATLAB, however, simplifies the process by providing two matrix division symbols, left and right ( \\  and  / ). In general,\nX = A\\B  solves for  X  in  A * X = B  and\nX = B/A  solves for  X  in  X * A = B .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 37,
      "section_heading": "Dividing Matrices",
      "captions": ""
    }
  },
  {
    "text": "X = A\\B  solves for  X  in  A * X = B  and\nX = B/A  solves for  X  in  X * A = B .\nIn general, matrix  A  must be a nonsingular square matrix; that is, it must be invertible and it must have the same number of rows and columns. (Generally, a matrix is invertible if the matrix times its inverse equals the identity matrix. To understand the theory and proofs, consult a textbook on linear algebra such as  Elementary Linear Algebra  by Hill listed in “Bibliography” on page A-2.) MATLAB gives a warning message if the matrix is singular or nearly so.\nSolving Simultaneous Linear Equations\nMatrix division is especially useful in solving simultaneous linear equations. Consider this problem: Given two portfolios of mortgage-based instruments, each with certain yields depending on the prime rate, how do you weight the portfolios to achieve certain annual cash flows? The answer involves solving two linear equations.\nA linear equation is any equation of the form\na 1 x  +  a 2 y  =  b ,",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 37,
      "section_heading": "Dividing Matrices",
      "captions": ""
    }
  },
  {
    "text": "A linear equation is any equation of the form\na 1 x  +  a 2 y  =  b ,\nwhere  a 1 ,  a 2 , and  b  are constants (with  a 1  and  a 2  not both 0), and  x  and  y  are variables. (It is a linear equation because it describes a line in the  xy -plane. For example, the equation 2 x  +  y  = 8 describes a line such that if  x  = 2, then  y  = 4.)\nA system of linear equations is a set of linear equations that you usually want to solve at the same time; that is, simultaneously. A basic principle for exact answers in solving simultaneous linear equations requires that there be as many equations as there are unknowns. To get exact answers for x  and  y , there must be two equations. For example, to solve for  x  and  y  in the system of linear equations\n2 x  +  y  = 13 x  −3 y  = −18,\nMatrix Algebra Refresher\n1-11",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 37,
      "section_heading": "Dividing Matrices",
      "captions": ""
    }
  },
  {
    "text": "there must be two equations, which there are. Matrix algebra represents this system as an equation involving three matrices:  A  for the left-side constants,  X  for the variables, and  B  for the right-side constants\nA  =  2 1 1 −3  ,      X  =  x y   ,      B  = 13 −18  ,\nwhere  A * X  =  B .\nSolving the system simultaneously means solving for  X . Using MATLAB,\nA = [2  1      1 -3];\nB = [13     -18];\nX = A \\ B\nsolves for  X  in  A * X = B .\nX = [3 7]\nSo  x  = 3 and  y  = 7 in this example. In general, you can use matrix algebra to solve any system of linear equations such as\na 11 x 1  +  a 12 x 2  + … +  a 1 n x n  =  b 1 a 21 x 1  +  a 22 x 2  + … +  a 2 n x n  =  b 2 ⋮ a m 1 x 1  +  a m 2 x 2  + … +  a mn x n  =  b m\nby representing them as matrices\nA  =\na 11  a 12  ⋯ a 1 n a 21  a 22  ⋯ a 2 n ⋮ ⋮ ⋮\na m 1  a m 2  ⋯ a mn\n,       X  =\nx 1 x 2 ⋮ x n\n,       B  =\nb 1 b 2 ⋮ b m\nand solving for  X  in  A * X  =  B .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 38,
      "section_heading": "there must be two equations, which there are. Matrix algebra represents this system as an equation",
      "captions": ""
    }
  },
  {
    "text": "by representing them as matrices\nA  =\na 11  a 12  ⋯ a 1 n a 21  a 22  ⋯ a 2 n ⋮ ⋮ ⋮\na m 1  a m 2  ⋯ a mn\n,       X  =\nx 1 x 2 ⋮ x n\n,       B  =\nb 1 b 2 ⋮ b m\nand solving for  X  in  A * X  =  B .\nTo illustrate, consider this situation. There are two portfolios of mortgage-based instruments, M1 and M2. They have current annual cash payments of $100 and $70 per unit, respectively, based on today's prime rate. If the prime rate moves down one percentage point, their payments would be $80 and $40. An investor holds 10 units of M1 and 20 units of M2. The investor's receipts equal cash payments times units, or R = C * U, for each prime-rate scenario. As word equations:\nM1 M2\nPrime flat: $100 * 10 units + $70 * 20 units = $2400 receipts\nPrime down: $80 * 10 units + $40 * 20 units = $1600 receipts\nAs MATLAB matrices:\n1 Getting Started\n1-12",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 38,
      "section_heading": "there must be two equations, which there are. Matrix algebra represents this system as an equation",
      "captions": ""
    }
  },
  {
    "text": "Cash = [100  70          80  40];\nUnits = [10         20];\nReceipts = Cash * Units\nReceipts =\n2400        1600\nNow the investor asks this question: Given these two portfolios and their characteristics, how many units of each should they hold to receive $7000 if the prime rate stays flat and $5000 if the prime drops one percentage point? Find the answer by solving two linear equations.\nM1 M2\nPrime flat: $100 *  x  units + $70 *  y  units = $7000 receipts\nPrime down: $80 *  x  units + $40 *  y  units = $5000 receipts\nIn other words, solve for U (units) in the equation R (receipts) = C (cash) * U (units). Using MATLAB left division\nCash = [100  70          80  40];\nReceipts = [7000             5000];\nUnits = Cash \\ Receipts\nUnits =\n43.7500          37.5000\nThe investor should hold 43.75 units of portfolio M1 and 37.5 units of portfolio M2 to achieve the annual receipts desired.\nOperating Element by Element",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 39,
      "section_heading": "Operating Element by Element",
      "captions": ""
    }
  },
  {
    "text": "Units =\n43.7500          37.5000\nThe investor should hold 43.75 units of portfolio M1 and 37.5 units of portfolio M2 to achieve the annual receipts desired.\nOperating Element by Element\nFinally, element-by-element arithmetic operations are called operations. To indicate a MATLAB array operation, precede the operator with a period ( . ). Addition and subtraction, and matrix multiplication and division by a scalar, are already array operations so no period is necessary. When using array operations on two matrices, the dimensions of the matrices must be the same. For example, given vectors of stock dividends and closing prices\nDividends = [1.90  0.40  1.56  4.50]; Prices = [25.625  17.75  26.125  60.50];\nYields = Dividends ./ Prices\nMatrix Algebra Refresher\n1-13",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 39,
      "section_heading": "Operating Element by Element",
      "captions": ""
    }
  },
  {
    "text": "Yields =\n0.0741    0.0225    0.0597    0.0744\nSee Also\nMore About\n• “Analyze Sets of Numbers Using Matrix Functions” on page 1-4\n• “Using Input and Output Arguments with Functions” on page 1-15\n1 Getting Started\n1-14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 40,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Using Input and Output Arguments with Functions\nIn this section...\n“Input Arguments” on page 1-15\n“Output Arguments” on page 1-16\nInput Arguments\nVector and Matrix Input\nBy design, MATLAB software can efficiently perform repeated operations on collections of data stored in vectors and matrices. MATLAB code that is written to operate simultaneously on different arrays is said to be vectorized. Vectorized code is not only clean and concise, but is also efficiently processed by MATLAB.\nBecause MATLAB is optimized for processing vectorized code, many Financial Toolbox functions accept either vector or matrix input arguments, rather than single (scalar) values.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 41,
      "section_heading": "Using Input and Output Arguments with Functions",
      "captions": ""
    }
  },
  {
    "text": "Because MATLAB is optimized for processing vectorized code, many Financial Toolbox functions accept either vector or matrix input arguments, rather than single (scalar) values.\nOne example of such a function is the  irr  function, which computes the internal rate of return of a cash flow stream. If you input a vector of cash flows from a single cash flow stream, then  irr  returns a scalar rate of return. If you input a matrix of cash flows from multiple cash flow streams, where each matrix column represents a different stream, then  irr  returns a vector of internal rates of return, where the columns correspond to the columns of the input matrix. Many other Financial Toolbox functions work similarly.\nAs an example, suppose that you make an initial investment of $100, from which you then receive by a series of annual cash receipts of $10, $20, $30, $40, and $50. This cash flow stream is stored in a vector\nCashFlows = [-100 10 20 30 40 50]'",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 41,
      "section_heading": "Using Input and Output Arguments with Functions",
      "captions": ""
    }
  },
  {
    "text": "CashFlows = [-100 10 20 30 40 50]'\nCashFlows =   -100     10     20     30     40     50\nUse the  irr  function to compute the internal rate of return of the cash flow stream.\nRate = irr(CashFlows)\nRate =\n0.1201\nFor the single cash flow stream  CashFlows , the function returns a scalar rate of return of  0.1201 , or 12.01%.\nNow, use the  irr  function to compute internal rates of return for multiple cash flow streams.\nRate = irr([CashFlows CashFlows CashFlows])\nUsing Input and Output Arguments with Functions\n1-15",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 41,
      "section_heading": "Using Input and Output Arguments with Functions",
      "captions": ""
    }
  },
  {
    "text": "Rate =\n0.1201    0.1201    0.1201\nMATLAB performs the same computation on all the assets at once. For the three cash flow streams, the  irr  function returns a vector of three internal rates of return.\nIn the Financial Toolbox context, vectorized programming is useful in portfolio management. You can organize multiple assets into a single collection by placing data for each asset in a different matrix column or row, then pass the matrix to a Financial Toolbox function.\nCharacter Vector Input\nEnter MATLAB character vectors surrounded by single quotes ( 'character vector' ).\nA character vector is stored as a character array, one ASCII character per element. Thus, the date character vector is\nDateCharacterVector =  '9/16/2017'",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 42,
      "section_heading": "Output Arguments",
      "captions": ""
    }
  },
  {
    "text": "A character vector is stored as a character array, one ASCII character per element. Thus, the date character vector is\nDateCharacterVector =  '9/16/2017'\nThis date character vector is actually a  1 -by- 9  vector. If you create a vector or matrix of character vectors, each character vector must have the same length. Using a column vector to create a vector of character vectors can allow you to visually check that all character vectors are the same length. If your character vectors are not the same length, use spaces or zeros to make them the same length, as in the following code.\nDateFields = ['01/12/2017'               '02/14/2017'               '03/03/2017'               '06/14/2017'               '12/01/2017'];\nDateFields  is a  5 -by- 10  array of character vectors.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 42,
      "section_heading": "Output Arguments",
      "captions": ""
    }
  },
  {
    "text": "DateFields = ['01/12/2017'               '02/14/2017'               '03/03/2017'               '06/14/2017'               '12/01/2017'];\nDateFields  is a  5 -by- 10  array of character vectors.\nYou cannot mix numbers and character vectors in a vector or matrix. If you input a vector or matrix that contains a mix of numbers and character vectors, MATLAB treats every entry as a character. As an example, input the following code\nItem = [83  90  99  '14-Sep-1999' ]\nItem =\nSZc14-Sep-1999\nThe software understands the input not as a  1 -by- 4  vector, but as a  1 -by- 14  character array with the value  SZc14-Sep-1999 .\nOutput Arguments\nSome functions return no arguments, some return just one, and some return multiple arguments. Functions that return multiple arguments use the syntax\n[A, B, C] =  function (input_arguments ... )\nto return arguments  A ,  B , and  C . If you omit all but one, the function returns the first argument. Thus, for this example if you use the syntax",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 42,
      "section_heading": "Output Arguments",
      "captions": ""
    }
  },
  {
    "text": "[A, B, C] =  function (input_arguments ... )\nto return arguments  A ,  B , and  C . If you omit all but one, the function returns the first argument. Thus, for this example if you use the syntax\n1 Getting Started\n1-16",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 42,
      "section_heading": "Output Arguments",
      "captions": ""
    }
  },
  {
    "text": "X =  function (input_arguments ... )\nthe  function  returns a value for  A , but not for  B  or  C .\nSome functions that return vectors accept only scalars as arguments. Such functions cannot accept vectors as arguments and return matrices, where each column in the output matrix corresponds to an entry in the input. Output vectors can be variable length.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 43,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "For example, most functions that require asset life as an input, and return values corresponding to different periods over the asset life, cannot handle vectors or matrices as input arguments. These functions include  amortize ,  depfixdb ,  depgendb , and  depsoyd . For example, consider a car for which you want to compute the depreciation schedule. Use the  depfixdb  function to compute a stream of declining-balance depreciation values for the asset. Set the initial value of the asset and the lifetime of the asset. Note that in the returned vector, the asset lifetime determines the number of rows. Now consider a collection of cars with different lifetimes. Because  depfixdb  cannot output a matrix with an unequal number of rows in each column,  depfixdb  cannot accept a single input vector with values for each asset in the collection.\nSee Also\nRelated Examples\n• “Matrices and Arrays”\nMore About\n• “Analyze Sets of Numbers Using Matrix Functions” on page 1-4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 43,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "See Also\nRelated Examples\n• “Matrices and Arrays”\nMore About\n• “Analyze Sets of Numbers Using Matrix Functions” on page 1-4\n• “Matrix Algebra Refresher” on page 1-7\nUsing Input and Output Arguments with Functions\n1-17",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 43,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Performing Common Financial Tasks\n• “Handle and Convert Dates” on page 2-2\n• “Analyzing and Computing Cash Flows” on page 2-11\n• “Pricing and Computing Yields for Fixed-Income Securities” on page 2-15\n• “Treasury Bills Defined” on page 2-25\n• “Computing Treasury Bill Price and Yield” on page 2-26\n• “Term Structure of Interest Rates” on page 2-29\n• “Returns with Negative Prices” on page 2-32\n• “Pricing and Analyzing Equity Derivatives” on page 2-39\n• “About Life Tables” on page 2-44\n• “Case Study for Life Tables Analysis” on page 2-46\n• “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48\n• “Machine Learning for Statistical Arbitrage I: Data Management and Visualization” on page 2-50\n• “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59\n• “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 45,
      "section_heading": "Performing Common Financial Tasks",
      "captions": "• “About Life Tables” on page 2-44, • “Case Study for Life Tables Analysis” on page 2-46"
    }
  },
  {
    "text": "• “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69\n• “Backtest Deep Learning Model for Algorithmic Trading of Limit Order Book Data” on page 2-78\n2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 45,
      "section_heading": "Performing Common Financial Tasks",
      "captions": "• “About Life Tables” on page 2-44, • “Case Study for Life Tables Analysis” on page 2-46"
    }
  },
  {
    "text": "Handle and Convert Dates\nIn this section...\n“Date Formats” on page 2-2\n“Date Conversions” on page 2-3\n“Current Date and Time” on page 2-7\n“Determining Specific Dates” on page 2-8\n“Determining Holidays” on page 2-8\n“Determining Cash-Flow Dates” on page 2-9\nDate Formats\nVirtually all financial data derives from a time series, functions in Financial Toolbox have extensive date-handling capabilities. The toolbox functions support date or date-and-time formats as character vectors, datetime arrays, or serial date numbers.\n• Date character vectors are text that represent date and time, which you can use with multiple formats. For example,  'dd-mmm-yyyy HH:MM:SS' ,  'dd-mmm-yyyy' , and  'mm/dd/yyyy'  are all supported text formats for a date character vector. Most often, you work with date character vectors (such as  14-Sep-1999 ) when dealing with dates.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 46,
      "section_heading": "Handle and Convert Dates",
      "captions": ""
    }
  },
  {
    "text": "• Datetime arrays, created using  datetime , are the best data type for representing points in time. datetime  values have flexible display formats and up to nanosecond precision, and can account for time zones, daylight saving time, and leap seconds. When  datetime  objects are used as inputs to other Financial Toolbox functions, the format of the input  datetime  object is preserved. For example:\noriginalDate = datetime('now','Format','yyyy-MM-dd HH:mm:ss');    % Find the next business day    b = busdate(originalDate)\nb =\ndatetime\n2021-05-04 15:59:34",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 46,
      "section_heading": "Handle and Convert Dates",
      "captions": ""
    }
  },
  {
    "text": "originalDate = datetime('now','Format','yyyy-MM-dd HH:mm:ss');    % Find the next business day    b = busdate(originalDate)\nb =\ndatetime\n2021-05-04 15:59:34\n• Serial date numbers represent a calendar date as the number of days that have passed since a fixed base date. In MATLAB software, serial date number  1  is January 1,0000 A.D. Financial Toolbox works internally with serial date numbers (such as,  730377 ). MATLAB also uses serial time to represent fractions of days beginning at midnight. For example, 6 p.m. equals  0.75  serial days, so 6:00 p.m. on  14-Sep-1999 , in MATLAB, is serial date number  730377.75\nNote  If you specify a two-digit year, MATLAB assumes that the year lies within the 100-year period centered on the current year. See the function  datenum  for specific information. MATLAB internal date handling and calculations generate no ambiguous values. However, whenever possible, use serial date numbers or date character vectors containing four-digit years.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 46,
      "section_heading": "Handle and Convert Dates",
      "captions": ""
    }
  },
  {
    "text": "2 Performing Common Financial Tasks\n2-2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 46,
      "section_heading": "Handle and Convert Dates",
      "captions": ""
    }
  },
  {
    "text": "Many Financial Toolbox functions that require dates as input arguments accept date character vectors, datetime arrays, or serial date numbers. If you are dealing with a few dates at the MATLAB command-line level, date character vectors are more convenient. If you are using Financial Toolbox functions on large numbers of dates, as in analyzing large portfolios or cash flows, performance improves if you use datetime arrays or serial date numbers. For more information, see “Represent Dates and Times in MATLAB”.\nDate Conversions\nFinancial Toolbox provides functions that convert date character vectors to or from serial date numbers. In addition, you can convert character vectors or serial date numbers to datetime arrays.\nFunctions that convert between date formats are:\ndatedisp Displays a numeric matrix with date entries formatted as date character vectors.\ndatenum Converts a date character vector to a serial date number.\ndatestr Converts a serial date number to a date character vector.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 47,
      "section_heading": "Date Conversions",
      "captions": ""
    }
  },
  {
    "text": "datenum Converts a date character vector to a serial date number.\ndatestr Converts a serial date number to a date character vector.\ndatetime Converts from date character vectors or serial date numbers to create a datetime array.\ndatevec Converts a serial date number or date character vector to a date vector whose elements are  [Year Month Day Hour Minute Second] .\nm2xdate Converts MATLAB serial date number to Excel ®  serial date number.\nx2mdate Converts Microsoft ®  Excel serial date number to MATLAB serial date number.\nFor more information, see “Convert Between Text and datetime or duration Values”.\nConvert Between Datetime Arrays and Character Vectors\nA date can be a character vector composed of fields related to a specific date and time. There are several ways to represent dates and times in several text formats. For example, all the following are character vectors represent August 23, 2010 at 04:35:42 PM:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 47,
      "section_heading": "Date Conversions",
      "captions": ""
    }
  },
  {
    "text": "'23-Aug-2010 04:35:06 PM' 'Wednesday, August 23' '08/23/10 16:35' 'Aug 23 16:35:42.946'\nA date character vector includes characters that separate the fields, such as the hyphen, space, and colon used here:\nd =  '23-Aug-2010 16:35:42'\nConvert one or more date character vectors to a  datetime  array using the  datetime  function. For the best performance, specify the format of the input character vectors as an input to  datetime .\nNote  The specifiers that  datetime  uses to describe date and time formats differ from the specifiers that the  datestr ,  datevec , and  datenum  functions accept.\nHandle and Convert Dates\n2-3",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 47,
      "section_heading": "Date Conversions",
      "captions": ""
    }
  },
  {
    "text": "t = datetime(d, 'InputFormat' , 'dd-MMM-yyyy HH:mm:ss' )\nt =\n23-Aug-2010 16:35:42\nAlthough the date string,  d , and the  datetime  scalar,  t , look similar, they are not equal. View the size and data type of each variable.\nwhos  d   t\nName      Size            Bytes  Class       Attributes\nd         1x20               40  char                     t         1x1               121  datetime\nConvert a  datetime  array to a character vector that uses  char  or  cellstr . For example, convert the current date and time to a timestamp to append to a file name.\nt = datetime( 'now' , 'Format' , 'yyyy-MM-dd''T''HHmmss' )\nt =\ndatetime\n2016-12-11T125628\nS = char(t); filename = [ 'myTest_' ,S]\nfilename =\n'myTest_2016-12-11T125628'\nConvert Serial Date Numbers to Datetime Arrays\nSerial time can represent fractions of days beginning at midnight. For example, 6 p.m. equals  0.75 serial days, so the character vector  '31-Oct-2003, 6:00 PM'  in MATLAB is date number 731885.75 .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 48,
      "section_heading": "Although the date string,",
      "captions": ""
    }
  },
  {
    "text": "Serial time can represent fractions of days beginning at midnight. For example, 6 p.m. equals  0.75 serial days, so the character vector  '31-Oct-2003, 6:00 PM'  in MATLAB is date number 731885.75 .\nConvert one or more serial date numbers to a  datetime  array using the  datetime  function. Specify the type of date number that is being converted:\nt = datetime(731885.75, 'ConvertFrom' , 'datenum' )\nt =\ndatetime\n31-Oct-2003 18:00:00\nConvert Datetime Arrays to Numeric Values\nSome MATLAB functions accept numeric data types but not datetime values as inputs. To apply these functions to your date and time data, first, convert datetime values to meaningful numeric values, and then call the function. For example, the  log  function accepts  double  inputs but not  datetime inputs. Suppose that you have a  datetime  array of dates spanning the course of a research study or experiment.\n2 Performing Common Financial Tasks\n2-4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 48,
      "section_heading": "Although the date string,",
      "captions": ""
    }
  },
  {
    "text": "t = datetime(2014,6,18) + calmonths(1:4)\nt =\n1×4 datetime array\n18-Jul-2014   18-Aug-2014   18-Sep-2014   18-Oct-2014\nSubtract the origin value. For example, the origin value can be the starting day of an experiment.\ndt = t - datetime(2014,7,1)\ndt =\n1×4 duration array\n408:00:00   1152:00:00   1896:00:00   2616:00:00\ndt  is a  duration  array. Convert  dt  to a  double  array of values in units of years, days, hours, minutes, or seconds by using the  years ,  days ,  hours ,  minutes , or  seconds  function, respectively.\nx = hours(dt)\nx =\n408        1152        1896        2616\nPass the  double  array as the input to the  log  function.\ny = log(x)\ny =\n6.0113    7.0493    7.5475    7.8694\nInput Conversions with datenum",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 49,
      "section_heading": "Subtract the origin value. For example, the origin value can be the starting day of an experiment.",
      "captions": ""
    }
  },
  {
    "text": "x =\n408        1152        1896        2616\nPass the  double  array as the input to the  log  function.\ny = log(x)\ny =\n6.0113    7.0493    7.5475    7.8694\nInput Conversions with datenum\nThe  datenum  function is important for using Financial Toolbox software efficiently.  datenum  takes an input date character vector in any of several formats, with  'dd-mmm-yyyy' ,  'mm/dd/yyyy' , or 'dd-mmm-yyyy, hh:mm:ss.ss'  formats being the most common. The input date character vector can have up to six fields formed by letters and numbers separated by any other characters, such that:\n• The day field is an integer from  1  through  31 .\n• The month field is either an integer from  1  through  12  or an alphabetical character vector with at least three characters.\n• The year field is a nonnegative integer. If only two numbers are specified, then the year is assumed to lie within the 100-year period centered on the current year. If the year is omitted, the current year is the default.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 49,
      "section_heading": "Subtract the origin value. For example, the origin value can be the starting day of an experiment.",
      "captions": ""
    }
  },
  {
    "text": "• The hours, minutes, and seconds fields are optional. They are integers separated by colons or followed by  'am'  or  'pm' .\nFor example, if the current year is 1999, then all these dates are equivalent:\n'17-May-1999' '17-May-99' '17-may' 'May 17, 1999'\nHandle and Convert Dates\n2-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 49,
      "section_heading": "Subtract the origin value. For example, the origin value can be the starting day of an experiment.",
      "captions": ""
    }
  },
  {
    "text": "'5/17/99' '5/17'\nAlso, both of these formats represent the same time.\n'17-May-1999, 18:30' '5/17/99/6:30 pm'\nThe default format for numbers-only input follows the US convention. Therefore, 3/6 is March 6, not June 3.\nWith  datenum , you can convert dates into serial date format, store them in a matrix variable, and then later pass the variable to a function. Alternatively, you can use  datenum  directly in a function input argument list.\nFor example, consider the function  bndprice  that computes the price of a bond given the yield to maturity. First set up variables for the yield to maturity, coupon rate, and the necessary dates.\nYield       = 0.07; CouponRate  = 0.08; Settle      = datenum( '17-May-2000' ); Maturity    = datenum( '01-Oct-2000' );\nThen call the function with the variables.\nbndprice(Yield,CouponRate,Settle,Maturity)\nans =\n100.3503\nAlternatively, convert date character vectors to serial date numbers directly in the function input argument list.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 50,
      "section_heading": "Also, both of these formats represent the same time.",
      "captions": ""
    }
  },
  {
    "text": "bndprice(Yield,CouponRate,Settle,Maturity)\nans =\n100.3503\nAlternatively, convert date character vectors to serial date numbers directly in the function input argument list.\nbndprice(0.07,0.08,datenum( '17-May-2000' ), ...   datenum( '01-Oct-2000' ))\nans =\n100.3503\nbndprice  is an example of a function designed to detect the presence of date character vectors and make the conversion automatically. For functions like  bndprice , date character vectors can be passed directly.\nbndprice(0.07,0.08, '17-May-2000' , '01-Oct-2000' )\nans =\n100.3503",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 50,
      "section_heading": "Also, both of these formats represent the same time.",
      "captions": ""
    }
  },
  {
    "text": "bndprice(0.07,0.08, '17-May-2000' , '01-Oct-2000' )\nans =\n100.3503\nThe decision to represent dates as either date character vectors or serial date numbers is often a matter of convenience. For example, when formatting data for visual display or for debugging date- handling code, you can view dates more easily as date character vectors because serial date numbers are difficult to interpret. Alternately, serial date numbers are just another type of numeric data, which you can place in a matrix along with any other numeric data for convenient manipulation.\nRemember that if you create a vector of input date character vectors, use a column vector, and be sure that all character vectors are the same length. To ensure that the character vectors are the same\n2 Performing Common Financial Tasks\n2-6",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 50,
      "section_heading": "Also, both of these formats represent the same time.",
      "captions": ""
    }
  },
  {
    "text": "length, fill the character vectors with spaces or zeros. For more information, see “Character Vector Input” on page 1-16.\nOutput Conversions with datestr\nThe  datestr  function converts a serial date number to one of 19 different date character vector output formats showing date, time, or both. The default output for dates is a day-month-year character vector, for example,  24-Aug-2000 . The  datestr  function is useful for preparing output reports.\ndatestr  Format Description\n01-Mar-2000 15:45:17 day-month-year hour:minute:second\n01-Mar-2000 day-month-year\n03/01/00 month/day/year\nMar month, three letters\nM month, single letter\n3 month number\n03/01 month/day\n1 day of month\nWed day of week, three letters\nW day of week, single letter\n2000 year, four numbers\n99 year, two numbers\nMar01 month year\n15:45:17 hour:minute:second\n03:45:17 PM hour:minute:second AM or PM\n15:45 hour:minute\n03:45 PM hour:minute AM or PM\nQ1-99 calendar quarter-year\nQ1 calendar quarter\nCurrent Date and Time",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 51,
      "section_heading": "Current Date and Time",
      "captions": ""
    }
  },
  {
    "text": "15:45:17 hour:minute:second\n03:45:17 PM hour:minute:second AM or PM\n15:45 hour:minute\n03:45 PM hour:minute AM or PM\nQ1-99 calendar quarter-year\nQ1 calendar quarter\nCurrent Date and Time\nThe  today  and  now  functions return serial date numbers for the current date, and the current date and time, respectively.\ntoday\nans =\n736675\nnow\nans =\n7.3668e+05\nHandle and Convert Dates\n2-7",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 51,
      "section_heading": "Current Date and Time",
      "captions": ""
    }
  },
  {
    "text": "The MATLAB function  date  returns a character vector for the current date.\ndate\nans =\n'11-Dec-2016'\nDetermining Specific Dates\nFinancial Toolbox provides many functions for determining specific dates. For example, assume that you schedule an accounting procedure for the last Friday of every month. Use the  lweekdate function to return those dates for the year 2000. The input argument  6  specifies Friday.\nFridates = lweekdate(6,2000,1:12); Fridays = datestr(Fridates)\nFridays =\n12×11 char array\n'28-Jan-2000'     '25-Feb-2000'     '31-Mar-2000'     '28-Apr-2000'     '26-May-2000'     '30-Jun-2000'     '28-Jul-2000'     '25-Aug-2000'     '29-Sep-2000'     '27-Oct-2000'     '24-Nov-2000'     '29-Dec-2000'\nAnother example of needing specific dates could be that your company closes on Martin Luther King Jr. Day, which is the third Monday in January. You can use the  nweekdate  function to determine those specific dates for 2011 through 2014.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 52,
      "section_heading": "Determining Specific Dates",
      "captions": ""
    }
  },
  {
    "text": "MLKDates = nweekdate(3,2,2011:2014,1); MLKDays = datestr(MLKDates)\nMLKDays =\n4×11 char array\n'17-Jan-2011'     '16-Jan-2012'     '21-Jan-2013'     '20-Jan-2014'\nDetermining Holidays\nAccounting for holidays and other nontrading days is important when you examine financial dates. Financial Toolbox provides the  holidays  function, which contains holidays and special nontrading days for the New York Stock Exchange from 1950 through 2030, inclusive. In addition, you can use nyseclosures  to evaluate all known or anticipated closures of the New York Stock Exchange from\n2 Performing Common Financial Tasks\n2-8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 52,
      "section_heading": "Determining Specific Dates",
      "captions": ""
    }
  },
  {
    "text": "January 1, 1885, to December 31, 2050.  nyseclosures  returns a vector of serial date numbers corresponding to market closures between the dates  StartDate  and  EndDate , inclusive.\nIn this example, use  holidays  to determine the standard holidays in the last half of 2012.\nLHHDates = holidays( '1-Jul-2012' , '31-Dec-2012' ); LHHDays = datestr(LHHDates)\nLHHDays =\n6×11 char array\n'04-Jul-2012'     '03-Sep-2012'     '29-Oct-2012'     '30-Oct-2012'     '22-Nov-2012'     '25-Dec-2012'\nYou can then use the  busdate  function to determine the next business day in 2012 after these holidays.\nLHNextDates = busdate(LHHDates); LHNextDays = datestr(LHNextDates)\nLHNextDays =\n6×11 char array\n'05-Jul-2012'     '04-Sep-2012'     '31-Oct-2012'     '31-Oct-2012'     '23-Nov-2012'     '26-Dec-2012'\nDetermining Cash-Flow Dates",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 53,
      "section_heading": "Determining Cash-Flow Dates",
      "captions": ""
    }
  },
  {
    "text": "LHNextDays =\n6×11 char array\n'05-Jul-2012'     '04-Sep-2012'     '31-Oct-2012'     '31-Oct-2012'     '23-Nov-2012'     '26-Dec-2012'\nDetermining Cash-Flow Dates\nTo determine cash-flow dates for securities with periodic payments, use  cfdates . This function accounts for the coupons per year, the day-count basis, and the end-of-month rule. For example, you can determine the cash-flow dates for a security that pays four coupons per year on the last day of the month using an  actual/365  day-count basis. To do so, enter the settlement date, the maturity date, and the parameters for  Period ,  Basis , and  EndMonthRule .\nPayDates = cfdates( '14-Mar-2000' , '30-Nov-2001' ,4,3,1); PayDays = datestr(PayDates)\nPayDays =\n7×11 char array\n'31-May-2000'     '31-Aug-2000'     '30-Nov-2000'     '28-Feb-2001'     '31-May-2001'     '31-Aug-2001'     '30-Nov-2001'\nHandle and Convert Dates\n2-9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 53,
      "section_heading": "Determining Cash-Flow Dates",
      "captions": ""
    }
  },
  {
    "text": "See Also datedisp  |  datenum  |  datestr  |  datetime  |  datevec  |  format  |  date  |  holidays  | nyseclosures  |  busdate  |  cfdates  |  addBusinessCalendar\nRelated Examples\n• “Convert Between Text and datetime or duration Values”\n• “Read Collection or Sequence of Spreadsheet Files”\n• “Trading Calendars User Interface” on page 12-2\n• “UICalendar User Interface” on page 12-4\nMore About\n• “Convert Dates Between Microsoft Excel and MATLAB” (Spreadsheet Link)\nExternal Websites\n• Automated Data Cleaning and Preparation in MATLAB (43 min)\n2 Performing Common Financial Tasks\n2-10",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 54,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Analyzing and Computing Cash Flows\nIn this section...\n“Introduction” on page 2-11\n“Interest Rates/Rates of Return” on page 2-11\n“Present or Future Values” on page 2-12\n“Depreciation” on page 2-13\n“Annuities” on page 2-13\nIntroduction\nFinancial Toolbox cash-flow functions compute interest rates and rates of return, present or future values, depreciation streams, and annuities.\nSome examples in this section use this income stream: an initial investment of $20,000 followed by three annual return payments, a second investment of $5,000, then four more returns. Investments are negative cash flows, return payments are positive cash flows.\nStream = [-20000,  2000,  2500,  3500, -5000,  6500, ...             9500,  9500,  9500];\nInterest Rates/Rates of Return\nThis example shows how to compute the internal rate of return of the cash stream using  irr .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 55,
      "section_heading": "Analyzing and Computing Cash Flows",
      "captions": ""
    }
  },
  {
    "text": "Interest Rates/Rates of Return\nThis example shows how to compute the internal rate of return of the cash stream using  irr .\nSpecify the income stream as an initial investment of $20,000 followed by three annual return payments, a second investment of $5,000, then four more returns. Investments are negative cash flows, return payments are positive cash flows.\nStream = [-20000,  2000,  2500,  3500, -5000,  6500,  ...             9500,  9500,  9500];\nUse  irr  to compute the internal rate of return of the cash stream.\nROR = irr(Stream)\nROR =  0.1172\nThe rate of return is 11.72%.\nThe internal rate of return of a cash flow may not have a unique value. Every time the sign changes in a cash flow, the equation defining  irr  can give up to two additional answers. An  irr  computation requires solving a polynomial equation, and the number of real roots of such an equation can depend on the number of sign changes in the coefficients. The equation for internal rate of return is",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 55,
      "section_heading": "Analyzing and Computing Cash Flows",
      "captions": ""
    }
  },
  {
    "text": "where  Investment  is a (negative) initial cash outlay at time 0,  cf n is the cash flow in the  n th period, and  n  is the number of periods.  irr  finds the rate  r  such that the present value of the cash flow\nAnalyzing and Computing Cash Flows\n2-11",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 55,
      "section_heading": "Analyzing and Computing Cash Flows",
      "captions": ""
    }
  },
  {
    "text": "equals the initial investment. If all the cf n s are positive there is only one solution. Every time there is a change of sign between coefficients, up to two additional real roots are possible.\nAnother toolbox rate function,  effrr , calculates the effective rate of return given an annual interest rate (also known as nominal rate or annual percentage rate, APR) and number of compounding periods per year. To find the effective rate of a 9% APR compounded monthly, enter\nRate = effrr(0.09, 12)\nRate =  0.0938\nThe  Rate  is 9.38%.\nA companion function  nomrr  computes the nominal rate of return given the effective annual rate and the number of compounding periods.\nPresent or Future Values\nThis example shows how to compute the present or future value of cash flows at regular or irregular time intervals with equal or unequal payments.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 56,
      "section_heading": "Present or Future Values",
      "captions": ""
    }
  },
  {
    "text": "Present or Future Values\nThis example shows how to compute the present or future value of cash flows at regular or irregular time intervals with equal or unequal payments.\nTo compute the present or future value, you can use the following functuions:  fvfix ,  fvvar ,  pvfix , and  pvvar . The  -fix  functions assume equal cash flows at regular intervals, while the  -var functions allow irregular cash flows at irregular periods.\nSpecify the income stream as an initial investment of $20,000 followed by three annual return payments, a second investment of $5,000, then four more returns. Investments are negative cash flows, return payments are positive cash flows.\nStream = [-20000,  2000,  2500,  3500, -5000,  6500,  ...             9500,  9500,  9500];\nUse  irr  to compute the internal rate of return of the cash stream.\nROR = irr(Stream)\nROR =  0.1172",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 56,
      "section_heading": "Present or Future Values",
      "captions": ""
    }
  },
  {
    "text": "Stream = [-20000,  2000,  2500,  3500, -5000,  6500,  ...             9500,  9500,  9500];\nUse  irr  to compute the internal rate of return of the cash stream.\nROR = irr(Stream)\nROR =  0.1172\nCompute the net present value of the sample income stream for which you computed the internal rate of return. This exercise also serves as a check on that calculation because the net present value of a cash stream at its internal rate of return should be zero. Enter\nNPV = pvvar(Stream, ROR)\nNPV =  5.9117e-12\nThe  NPV  is very close to zero. The answer usually is not  exactly  zero due to rounding errors and the computational precision of the computer. Note, other toolbox functions behave similarly. The functions that compute a bond's yield, for example, often must solve a nonlinear equation. If you then use that yield to compute the net present value of the bond's income stream, it usually does not exactly  equal the purchase price, but the difference is negligible for practical applications.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 56,
      "section_heading": "Present or Future Values",
      "captions": ""
    }
  },
  {
    "text": "2 Performing Common Financial Tasks\n2-12",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 56,
      "section_heading": "Present or Future Values",
      "captions": ""
    }
  },
  {
    "text": "Depreciation\nThis example shows how to compute standard depreciation schedules using  depgendb .\nThe following code depreciates an automobile worth $15,000 over five years with a salvage value of $1,500. It computes the general declining balance using two different depreciation rates: 50% (or 1.5), and 100% (or 2.0, also known as double declining balance).\nDecline1 = depgendb(15000, 1500, 5, 1.5)\nDecline1 =  1×5 10 3  ×\n4.5000    3.1500    2.2050    1.5435    2.1015\nDecline2 = depgendb(15000, 1500, 5, 2.0)\nDecline2 =  1×5 10 3  ×\n6.0000    3.6000    2.1600    1.2960    0.4440\nThese results indicate the actual depreciation amount for the first four years and the remaining depreciable value as the entry for the fifth year.\nAnnuities\nThis example shows how to work with annuities using  annurate .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 57,
      "section_heading": "Depreciation",
      "captions": ""
    }
  },
  {
    "text": "Annuities\nThis example shows how to work with annuities using  annurate .\nThe following code shows how to compute the interest rate associated with a series of loan payments when only the payment amounts and principal are known. For a loan whose original value was $5000.00 and which was paid back monthly over four years at $130.00/month:\nRate = annurate(4*12, 130, 5000, 0, 0)\nRate =  0.0094\nThe function returns a rate of  0.0094  monthly, or about 11.28% annually.\nYou can use a present-value function ( pvfix ) to compute the initial principal when the payment and rate are known. For a loan paid at $300.00/month over four years at 11% annual interest:\nPrincipal = pvfix(0.11/12, 4*12, 300, 0, 0)\nPrincipal =  1.1607e+04\nThe function returns the original principal value of $11,607.43.\nAnalyzing and Computing Cash Flows\n2-13",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 57,
      "section_heading": "Depreciation",
      "captions": ""
    }
  },
  {
    "text": "You can compute an amortization schedule using  amortize  for a loan or annuity. For example, the original value was $5000.00 and was paid back over 12 months at an annual rate of 9%.\n[Prpmt, Intpmt, Balance, Payment] = amortize(0.09/12, 12, 5000, 0, 0)\nPrpmt =  1×12\n399.7574  402.7556  405.7762  408.8196  411.8857  414.9748  418.0872  421.2228  424.3820  427.5\nIntpmt =  1×12\n37.5000   34.5018   31.4812   28.4378   25.3717   22.2825   19.1702   16.0346   12.8754    9.6\nBalance =  1×12 10 3  ×\n4.6002    4.1975    3.7917    3.3829    2.9710    2.5560    2.1379    1.7167    1.2923    0.8\nPayment =  437.2574\nSee Also irr  |  effrr  |  nomrr  |  fvfix  |  fvvar  |  pvfix  |  pvvar\nRelated Examples\n• “Handle and Convert Dates” on page 2-2\n• “Pricing and Computing Yields for Fixed-Income Securities” on page 2-15\n2 Performing Common Financial Tasks\n2-14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 58,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Pricing and Computing Yields for Fixed-Income Securities\nIn this section...\n“Introduction” on page 2-15\n“Fixed-Income Terminology” on page 2-15\n“Framework” on page 2-18\n“Default Parameter Values” on page 2-18\n“Coupon Date Calculations” on page 2-20\n“Yield Conventions” on page 2-21\n“Pricing Functions” on page 2-21\n“Yield Functions” on page 2-21\n“Fixed-Income Sensitivities” on page 2-22\nIntroduction",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 59,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": ""
    }
  },
  {
    "text": "“Yield Functions” on page 2-21\n“Fixed-Income Sensitivities” on page 2-22\nIntroduction\nThe Financial Toolbox product provides functions for computing accrued interest, price, yield, convexity, and duration of fixed-income securities. Various conventions exist for determining the details of these computations. The Financial Toolbox software supports conventions specified by the Securities Industry and Financial Markets Association (SIFMA), used in the US markets, the International Capital Market Association (ICMA), used mainly in the European markets, and the International Swaps and Derivatives Association (ISDA). For historical reasons, SIFMA is referred to in Financial Toolbox documentation as SIA and ISMA is referred to as International Capital Market Association (ICMA). Financial Instruments Toolbox™supports additional functionality for pricing fixed-income securities. For more information, see “Price Interest-Rate Instruments” (Financial Instruments Toolbox).",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 59,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": ""
    }
  },
  {
    "text": "Fixed-Income Terminology\nSince terminology varies among texts on this subject, here are some basic definitions that apply to these Financial Toolbox functions.\nThe  settlement date  of a bond is the date when money first changes hands; that is, when a buyer pays for a bond. It need not coincide with the  issue date , which is the date a bond is first offered for sale.\nThe  first coupon date  and  last coupon date  are the dates when the first and last coupons are paid, respectively. Although bonds typically pay periodic annual or semiannual coupons, the length of the first and last coupon periods may differ from the standard coupon period. The toolbox includes price and yield functions that handle these odd first and/or last periods.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 59,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": ""
    }
  },
  {
    "text": "Successive  quasi-coupon dates  determine the length of the standard coupon period for the fixed income security of interest, and do not necessarily coincide with actual coupon payment dates. The toolbox includes functions that calculate both actual and quasi-coupon dates for bonds with odd first and/or last periods.\nFixed-income securities can be purchased on dates that do not coincide with coupon payment dates. In this case, the bond owner is not entitled to the full value of the coupon for that period. When a bond is purchased between coupon dates, the buyer must compensate the seller for the pro-rata share of the coupon interest earned from the previous coupon payment date. This pro-rata share of\nPricing and Computing Yields for Fixed-Income Securities\n2-15",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 59,
      "section_heading": "Pricing and Computing Yields for Fixed-Income Securities",
      "captions": ""
    }
  },
  {
    "text": "the coupon payment is called  accrued interest . The  purchase price , the price paid for a bond, is the quoted market price plus accrued interest.\nThe  maturity date  of a bond is the date when the issuer returns the final face value, also known as the redemption value  or  par value , to the buyer. The  yield-to-maturity  of a bond is the nominal compound rate of return that equates the present value of all future cash flows (coupons and principal) to the current market price of the bond.\nPeriod\nThe period of a bond refers to the frequency with which the issuer of a bond makes coupon payments to the holder.\nPeriod of a Bond\nPeriod Value Payment Schedule\n0 No coupons (Zero coupon bond)\n1 Annual\n2 Semiannual\n3 Tri-annual\n4 Quarterly\n6 Bi-monthly\n12 Monthly\nBasis",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 60,
      "section_heading": "the coupon payment is called",
      "captions": ""
    }
  },
  {
    "text": "Period of a Bond\nPeriod Value Payment Schedule\n0 No coupons (Zero coupon bond)\n1 Annual\n2 Semiannual\n3 Tri-annual\n4 Quarterly\n6 Bi-monthly\n12 Monthly\nBasis\nThe basis of a bond refers to the basis or day-count convention for a bond. Day count basis determines how interest accrues over time for various instruments and the amount transferred on interest payment dates. Basis is normally expressed as a fraction in which the numerator determines the number of days between two dates, and the denominator determines the number of days in the year.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 60,
      "section_heading": "the coupon payment is called",
      "captions": ""
    }
  },
  {
    "text": "For example, the numerator of  actual/actual  means that when determining the number of days between two dates, count the actual number of days; the denominator means that you use the actual number of days in the given year in any calculations (either 365 or 366 days depending on whether the given year is a leap year). The calculation of accrued interest for dates between payments also uses day count basis. Day count basis is a fraction of  Number of interest accrual days  /  Days in the relevant coupon period .\nNote  Although the concept of day count sounds deceptively simple, the actual calculation of day counts can be complex. You can find a good discussion of day counts and the formulas for calculating them in Chapter 5 of Stigum and Robinson,  Money Market and Bond Calculations  in “Bibliography” on page A-2. For more information on  Basis , see EMU and Market Conventions: Recent Developments.\nSupported day count conventions and basis values are:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 60,
      "section_heading": "the coupon payment is called",
      "captions": ""
    }
  },
  {
    "text": "Supported day count conventions and basis values are:\n2 Performing Common Financial Tasks\n2-16",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 60,
      "section_heading": "the coupon payment is called",
      "captions": ""
    }
  },
  {
    "text": "Basis Value\nDay Count Convention\n0 actual/actual  (default) — Number of days in both a period and a year is the actual number of days. Also, another common actual/actual basis is basis  12 .\n1 30/360 SIA  — Year fraction is calculated based on a 360 day year with 30-day months, after applying the following rules: If the first date and the second date are the last day of February, the second date is changed to the 30th. If the first date falls on the 31st or is the last day of February, it is changed to the 30th. If after the preceding test, the first day is the 30th and the second day is the 31st, then the second day is changed to the 30th.\n2 actual/360  — Number of days in a period is equal to the actual number of days, however the number of days in a year is 360.\n3 actual/365  — Number of days in a period is equal to the actual number of days, however the number of days in a year is 365 (even in a leap year).",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 61,
      "section_heading": "Basis",
      "captions": ""
    }
  },
  {
    "text": "3 actual/365  — Number of days in a period is equal to the actual number of days, however the number of days in a year is 365 (even in a leap year).\n4 30/360 PSA  — Number of days in every month is set to 30 (including February). If the start date of the period is either the 31st of a month or the last day of February, the start date is set to the 30th, while if the start date is the 30th of a month and the end date is the 31st, the end date is set to the 30th. The number of days in a year is 360.\n5 30/360 ISDA  — Number of days in every month is set to 30, except for February where it is the actual number of days. If the start date of the period is the 31st of a month, the start date is set to the 30th while if the start date is the 30th of a month and the end date is the 31st, the end date is set to the 30th. The number of days in a year is 360.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 61,
      "section_heading": "Basis",
      "captions": ""
    }
  },
  {
    "text": "6 30E /360  — Number of days in every month is set to 30 except for February where it is equal to the actual number of days. If the start date or the end date of the period is the 31st of a month, that date is set to the 30th. The number of days in a year is 360.\n7 actual/365 Japanese  — Number of days in a period is equal to the actual number of days, except for leap days (29th February) which are ignored. The number of days in a year is 365 (even in a leap year).\n8 actual/actual ICMA  — Number of days in both a period and a year is the actual number of days and the compounding frequency is annual.\n9 actual/360 ICMA  — Number of days in a period is equal to the actual number of days, however the number of days in a year is 360 and the compounding frequency is annual.\n10 actual/365 ICMA  — Number of days in a period is equal to the actual number of days, however the number of days in a year is 365 (even in a leap year) and the compounding frequency is annual.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 61,
      "section_heading": "Basis",
      "captions": ""
    }
  },
  {
    "text": "10 actual/365 ICMA  — Number of days in a period is equal to the actual number of days, however the number of days in a year is 365 (even in a leap year) and the compounding frequency is annual.\n11 30/360 ICMA  — Number of days in every month is set to 30, except for February where it is equal to the actual number of days. If the start date or the end date of the period is the 31st of a month, that date is set to the 30th. The number of days in a year is 360 and the compounding frequency is annual.\n12 actual/365 ISDA  — The day count fraction is calculated using the following formula: (Actual number of days in period that fall in a leap year / 366)  + (Actual number of days in period that fall in a normal year / 365) . Basis  12  is also referred to as actual/actual ISDA.\n13 bus/252  — The number of days in a period is equal to the actual number of business days. The number of business days in a year is 252.\nPricing and Computing Yields for Fixed-Income Securities\n2-17",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 61,
      "section_heading": "Basis",
      "captions": ""
    }
  },
  {
    "text": "End-of-Month Rule\nThe  end-of-month rule  affects a bond's coupon payment structure. When the rule is in effect, a security that pays a coupon on the last actual day of a month will always pay coupons on the last day of the month. This means, for example, that a semiannual bond that pays a coupon on February 28 in nonleap years will pay coupons on August 31 in all years and on February 29 in leap years.\nEnd-of-Month Rule\nEnd-of-Month Rule Value Meaning\n1  (default) Rule in effect.\n0 Rule not in effect.\nFramework\nAlthough not all Financial Toolbox functions require the same input arguments, they all accept the following common set of input arguments.\nCommon Input Arguments\nInput Meaning\nSettle Settlement date\nMaturity Maturity date\nPeriod Coupon payment period\nBasis Day-count basis\nEndMonthRule End-of-month payment rule\nIssueDate Bond issue date\nFirstCouponDate First coupon payment date\nLastCouponDate Last coupon payment date",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 62,
      "section_heading": "Framework",
      "captions": ""
    }
  },
  {
    "text": "Period Coupon payment period\nBasis Day-count basis\nEndMonthRule End-of-month payment rule\nIssueDate Bond issue date\nFirstCouponDate First coupon payment date\nLastCouponDate Last coupon payment date\nOf the common input arguments, only  Settle  and  Maturity  are required. All others are optional. They are set to the default values if you do not explicitly set them. By default, the  FirstCouponDate and  LastCouponDate  are nonapplicable. In other words, if you do not specify  FirstCouponDate and  LastCouponDate , the bond is assumed to have no odd first or last coupon periods. In this case, the bond is a standard bond with a coupon payment structure based solely on the maturity date.\nDefault Parameter Values\nTo illustrate the use of default values in Financial Toolbox functions, consider the  cfdates  function, which computes actual cash flow payment dates for a portfolio of fixed income securities regardless of whether the first and/or last coupon periods are normal, long, or short.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 62,
      "section_heading": "Framework",
      "captions": ""
    }
  },
  {
    "text": "The complete calling syntax with the full input argument list is\nCFlowDates = cfdates(Settle, Maturity, Period, Basis, ...  EndMonthRule, IssueDate, FirstCouponDate, LastCouponDate)\nwhile the minimal calling syntax requires only settlement and maturity dates\nCFlowDates = cfdates(Settle, Maturity)\n2 Performing Common Financial Tasks\n2-18",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 62,
      "section_heading": "Framework",
      "captions": ""
    }
  },
  {
    "text": "Single Bond Example\nAs an example, suppose that you have a bond with these characteristics:\nSettle          =  '20-Sep-1999' Maturity        =  '15-Oct-2007' Period          = 2 Basis           = 0 EndMonthRule    = 1 IssueDate       = NaN FirstCouponDate = NaN LastCouponDate  = NaN\nPeriod ,  Basis , and  EndMonthRule  are set to their default values, and  IssueDate , FirstCouponDate , and  LastCouponDate  are set to  NaN .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 63,
      "section_heading": "Single Bond Example",
      "captions": ""
    }
  },
  {
    "text": "Period ,  Basis , and  EndMonthRule  are set to their default values, and  IssueDate , FirstCouponDate , and  LastCouponDate  are set to  NaN .\nFormally, a  NaN  is an IEEE ®  arithmetic standard for  Not-a-Number  and is used to indicate the result of an undefined operation (for example, zero divided by zero). However,  NaN  is also a convenient placeholder. In the SIA functions of Financial Toolbox software,  NaN  indicates the presence of a nonapplicable value. It tells the Financial Toolbox functions to ignore the input value and apply the default. Setting  IssueDate ,  FirstCouponDate , and  LastCouponDate  to  NaN  in this example tells cfdates  to assume that the bond has been issued before settlement and that no odd first or last coupon periods exist.\nHaving set these values, all these calls to  cfdates  produce the same result.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 63,
      "section_heading": "Single Bond Example",
      "captions": ""
    }
  },
  {
    "text": "Having set these values, all these calls to  cfdates  produce the same result.\ncfdates(Settle, Maturity) cfdates(Settle, Maturity, Period) cfdates(Settle, Maturity, Period, []) cfdates(Settle, Maturity, [], Basis) cfdates(Settle, Maturity, [], []) cfdates(Settle, Maturity, Period, [], EndMonthRule) cfdates(Settle, Maturity, Period, [], NaN) cfdates(Settle, Maturity, Period, [], [], IssueDate) cfdates(Settle, Maturity, Period, [], [], IssueDate, [], []) cfdates(Settle, Maturity, Period, [], [], [], [],LastCouponDate) cfdates(Settle, Maturity, Period, Basis, EndMonthRule,  ...   IssueDate, FirstCouponDate, LastCouponDate)\nThus, leaving a particular input unspecified has the same effect as passing an empty matrix ( [] ) or passing a  NaN  – all three tell  cfdates  (and other Financial Toolbox functions) to use the default value for a particular input parameter.\nBond Portfolio Example",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 63,
      "section_heading": "Single Bond Example",
      "captions": ""
    }
  },
  {
    "text": "Bond Portfolio Example\nSince the previous example included only a single bond, there was no difference between passing an empty matrix or passing a  NaN  for an optional input argument. For a portfolio of bonds, however, using  NaN  as a placeholder is the only way to specify default acceptance for some bonds while explicitly setting nondefault values for the remaining bonds in the portfolio.\nNow suppose that you have a portfolio of two bonds.\nSettle   =  '20-Sep-1999' Maturity = [ '15-Oct-2007' ;  '15-Oct-2010' ]\nThese calls to  cfdates  all set the coupon period to its default value ( Period = 2 ) for both bonds.\nPricing and Computing Yields for Fixed-Income Securities\n2-19",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 63,
      "section_heading": "Single Bond Example",
      "captions": ""
    }
  },
  {
    "text": "cfdates(Settle, Maturity, 2) cfdates(Settle, Maturity, [2 2]) cfdates(Settle, Maturity, []) cfdates(Settle, Maturity, NaN) cfdates(Settle, Maturity, [NaN NaN]) cfdates(Settle, Maturity)\nThe first two calls explicitly set  Period = 2 . Since  Maturity  is a  2 -by- 1  vector of maturity dates, cfdates  knows that you have a two-bond portfolio.\nThe first call specifies a single (that is, scalar) 2 for  Period . Passing a scalar tells  cfdates  to apply the scalar-valued input to all bonds in the portfolio. This is an example of implicit scalar-expansion. The settlement date has been implicit scalar-expanded as well.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 64,
      "section_heading": "Coupon Date Calculations",
      "captions": ""
    }
  },
  {
    "text": "The second call also applies the default coupon period by explicitly passing a two-element vector of 2's. The third call passes an empty matrix, which  cfdates  interprets as an invalid period, for which the default value is used. The fourth call is similar, except that a  NaN  has been passed. The fifth call passes two  NaN 's, and has the same effect as the third. The last call passes the minimal input set.\nFinally, consider the following calls to  cfdates  for the same two-bond portfolio.\ncfdates(Settle, Maturity, [4 NaN]) cfdates(Settle, Maturity, [4 2])\nThe first call explicitly sets  Period = 4  for the first bond and implicitly sets the default  Period = 2 for the second bond. The second call has the same effect as the first but explicitly sets the periodicity for both bonds.\nThe optional input  Period  has been used for illustrative purpose only. The default-handling process illustrated in the examples applies to any of the optional input arguments.\nCoupon Date Calculations",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 64,
      "section_heading": "Coupon Date Calculations",
      "captions": ""
    }
  },
  {
    "text": "Coupon Date Calculations\nCalculating coupon dates, either actual or quasi dates, is notoriously complicated. Financial Toolbox software follows the SIA conventions in coupon date calculations.\nThe first step in finding the coupon dates associated with a bond is to determine the reference, or synchronization date (the  sync date ). Within the SIA framework, the order of precedence for determining the sync date is:\n1 The first coupon date\n2 The last coupon date\n3 The maturity date",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 64,
      "section_heading": "Coupon Date Calculations",
      "captions": ""
    }
  },
  {
    "text": "1 The first coupon date\n2 The last coupon date\n3 The maturity date\nIn other words, a Financial Toolbox function first examines the  FirstCouponDate  input. If FirstCouponDate  is specified, coupon payment dates and quasi-coupon dates are computed with respect to  FirstCouponDate ; if  FirstCouponDate  is unspecified, empty ( [] ), or  NaN , then the LastCouponDate  is examined. If  LastCouponDate  is specified, coupon payment dates and quasi- coupon dates are computed with respect to  LastCouponDate . If both  FirstCouponDate  and LastCouponDate  are unspecified, empty ( [] ), or  NaN , the  Maturity  (a required input argument) serves as the synchronization date.\n2 Performing Common Financial Tasks\n2-20",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 64,
      "section_heading": "Coupon Date Calculations",
      "captions": ""
    }
  },
  {
    "text": "Yield Conventions\nThere are two yield and time factor conventions that are used in the Financial Toolbox software – these are determined by the input  basis . Specifically, bases  0  to  7  are assumed to have semiannual compounding, while bases  8  to  12  are assumed to have annual compounding regardless of the period of the bond's coupon payments (including zero-coupon bonds). In addition, any yield-related sensitivity (that is, duration and convexity), when quoted on a periodic basis, follows this same convention. (See  bndconvp ,  bndconvy ,  bnddurp ,  bnddury , and  bndkrdur .)\nPricing Functions\nThis example shows how to compute the price of a bond with an odd first period using  bndprice .\nAssume that you have a bond with these characteristics:\nSettle          =  '11-Nov-1992' ; Maturity        =  '01-Mar-2005' ; IssueDate       =  '15-Oct-1992' ; FirstCouponDate =  '01-Mar-1993' ; CouponRate      = 0.0785; Yield           = 0.0625;",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 65,
      "section_heading": "Yield Conventions",
      "captions": ""
    }
  },
  {
    "text": "Settle          =  '11-Nov-1992' ; Maturity        =  '01-Mar-2005' ; IssueDate       =  '15-Oct-1992' ; FirstCouponDate =  '01-Mar-1993' ; CouponRate      = 0.0785; Yield           = 0.0625;\nAllow coupon payment period ( Period  =  2 ), day-count basis ( Basis  =  0 ), and end-of-month rule ( EndMonthRule  =  1 ) to assume the default values. Also, assume that there is no odd last coupon date and that the face value of the bond is $100. Calling the function:\n[Price, AccruedInt] = bndprice(Yield, CouponRate, Settle,  ...   Maturity, [], [], [], IssueDate, FirstCouponDate)\nPrice =  113.5977\nAccruedInt =  0.5855\nbndprice  returns a price of $113.60 and accrued interest of $0.59.\nNote,  bndprice  uses nonlinear formulas to compute the price of a security. For this reason, Financial Toolbox™ software uses Newton's method when solving for an independent variable within a formula.\nYield Functions",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 65,
      "section_heading": "Yield Conventions",
      "captions": ""
    }
  },
  {
    "text": "Yield Functions\nThis example shows how to use  bndyield  compute the yield of a bond that has odd first and last periods and settlement in the first period.\nSet up variables for settlement, maturity date, issue, first coupon, and a last coupon date.\nSettle          =  '12-Jan-2000' ; Maturity        =  '01-Oct-2001' ; IssueDate       =  '01-Jan-2000' ; FirstCouponDate =  '15-Jan-2000' ; LastCouponDate  =  '15-Apr-2000' ;\nPricing and Computing Yields for Fixed-Income Securities\n2-21",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 65,
      "section_heading": "Yield Conventions",
      "captions": ""
    }
  },
  {
    "text": "Assume a face value of $100. Specify a purchase price of $95.70, a coupon rate of 4%, quarterly coupon payments, and a 30/360 day-count convention ( Basis  =  1 ).\nPrice        = 95.7; CouponRate   = 0.04; Period       = 4; Basis        = 1; EndMonthRule = 1;\nCall the  bndyield  function.\nYield = bndyield(Price, CouponRate, Settle, Maturity, Period,  ...   Basis, EndMonthRule, IssueDate, FirstCouponDate, LastCouponDate)\nYield =  0.0659\nThe function returns a Yield =  0.0659  (6.60%).\nFixed-Income Sensitivities\nFinancial Toolbox software supports the following options for managing interest-rate risk for one or more bonds:\n• bnddurp  and  bnddury  support duration and convexity analysis based on market quotes and assume parallel shifts in the bond yield curve.\n• bndkrdur  supports key rate duration based on a market yield curve and can model nonparallel shifts in the bond yield curve.\nCalculating Duration and Convexity for Bonds",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 66,
      "section_heading": "Fixed-Income Sensitivities",
      "captions": ""
    }
  },
  {
    "text": "• bndkrdur  supports key rate duration based on a market yield curve and can model nonparallel shifts in the bond yield curve.\nCalculating Duration and Convexity for Bonds\nThis example shows how to compute the annualized Macaulay and modified durations and the periodic Macaulay duration for a bond.\nThe Macaulay duration of an income stream, such as a coupon bond, measures how long, on average, the owner waits before receiving a payment. It is the weighted average of the times payments are made, with the weights at time  T  equal to the present value of the money received at time  T . The modified duration is the Macaulay duration discounted by the per-period interest rate; that is, divided by (1+rate/frequency). The  Macaulay duration  is a measure of price sensitivity to yield changes. This duration is measured in years and is a weighted average-time-to-maturity of an instrument.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 66,
      "section_heading": "Fixed-Income Sensitivities",
      "captions": ""
    }
  },
  {
    "text": "To illustrate, the following code computes the annualized Macaulay and modified durations and the periodic Macaulay duration for a bond with settlement ( 12-Jan-2000 ) and maturity ( 01-Oct-2001 ) dates, a 5% coupon rate, and a 4.5% yield to maturity. For simplicity, any optional input arguments assume default values (that is, semiannual coupons, and day-count basis =  0  (actual/actual), coupon payment structure synchronized to the maturity date, and end-of-month payment rule in effect).\nCouponRate = 0.05; Yield = 0.045; Settle = datetime(2000,1,12); Maturity = datetime(2001,10,1);\n[ModDuration, YearDuration, PerDuration] = bnddury(Yield,  ...   CouponRate, Settle, Maturity)\n2 Performing Common Financial Tasks\n2-22",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 66,
      "section_heading": "Fixed-Income Sensitivities",
      "captions": ""
    }
  },
  {
    "text": "ModDuration =  1.6107\nYearDuration =  1.6470\nPerDuration =  3.2940\nThe durations are:\n• ModDuration = 1.6107 ( years )\n• YearDuration = 1.6470 ( years )\n• PerDuration = 3.2940 ( semiannual periods )\nNote that the semiannual periodic Macaulay duration ( PerDuration ) is twice the annualized Macaulay duration ( YearDuration ).\nCalculating Key Rate Durations for Bonds\nThis example shows how to compute the key rate duration of the US Treasury Bond.\nKey rate duration enables you to evaluate the sensitivity and price of a bond to nonparallel changes in the spot or zero curve by decomposing the interest rate risk along the spot or zero curve. Key rate duration refers to the process of choosing a set of key rates and computing a duration for each rate. Specifically, for each key rate, while the other rates are held constant, the key rate is shifted up and down (and intermediate cash flow dates are interpolated), and then the present value of the security given the shifted curves is computed.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 67,
      "section_heading": "The durations are:",
      "captions": ""
    }
  },
  {
    "text": "The calculation of  bndkrdur  supports\nWhere  PV  is the current value of the instrument,  PV_up  and  PV_down  are the new values after the discount curve has been shocked, and  ShiftValue  is the change in interest rate. For example, if key rates of 3 months, 1, 2, 3, 5, 7, 10, 15, 20, 25, 30 years were chosen, then a 30-year bond might have corresponding key rate durations of:\n3M 1Y 2Y 3Y 5Y 7Y 10Y 15Y 20Y 25Y 30Y\n.01 .04 .09 .21 .4 .65 1.27 1.71 1.68 1.83 7.03\nThe key rate durations add up to approximately equal the duration of the bond.\nCompute the key rate duration of the US Treasury Bond with maturity date of August 15, 2028 and coupon rate of 5.5%.\nSettle = datenum( '18-Nov-2008' );  CouponRate = 5.500/100; Maturity = datenum( '15-Aug-2028' );  Price = 114.83;\nPricing and Computing Yields for Fixed-Income Securities\n2-23",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 67,
      "section_heading": "The durations are:",
      "captions": ""
    }
  },
  {
    "text": "For the  ZeroData  information on the current spot curve for this bond, refer to https:// www.treasury.gov/resource-center/data-chart-center/interest-rates/Pages/TextView.aspx?data=yield.\nZeroDates = daysadd(Settle ,[30 90 180 360 360*2 360*3 360*5  ... 360*7 360*10 360*20 360*30]); ZeroRates = ([0.06 0.12 0.81 1.08 1.22 1.53 2.32 2.92 3.68 4.42 4.20]/100)';\nCompute the key rate duration using  bndkrdur  for a specific set of rates (choose this based on the maturities of the available hedging instruments).\nkrd = bndkrdur([ZeroDates ZeroRates],CouponRate,Settle,Maturity, 'keyrates' ,[2 5 10 20])\nkrd =  1×4\n0.2865    0.8729    2.6451    8.5778\nNote, the sum of the key rate durations approximately equals the duration of the bond.\n[sum(krd) bnddurp(Price,CouponRate,Settle,Maturity)]\nans =  1×2\n12.3823   12.3919\nSee Also bndconvp  |  bndconvy  |  bnddurp  |  bnddury  |  bndkrdur\nRelated Examples\n• “Handle and Convert Dates” on page 2-2\n• “Term Structure of Interest Rates” on page 2-29",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 68,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "12.3823   12.3919\nSee Also bndconvp  |  bndconvy  |  bnddurp  |  bnddury  |  bndkrdur\nRelated Examples\n• “Handle and Convert Dates” on page 2-2\n• “Term Structure of Interest Rates” on page 2-29\n• “Computing Treasury Bill Price and Yield” on page 2-26\nMore About\n• “Treasury Bills Defined” on page 2-25\n2 Performing Common Financial Tasks\n2-24",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 68,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Treasury Bills Defined\nTreasury bills are short-term securities (issued with maturities of one year or less) sold by the United States Treasury. Sales of these securities are frequent, usually weekly. From time to time, the Treasury also offers longer duration securities called Treasury notes and Treasury bonds.\nA Treasury bill is a discount security. The holder of the Treasury bill does not receive periodic interest payments. Instead, at the time of sale, a percentage discount is applied to the face value. At maturity, the holder redeems the bill for full face value.\nThe basis for Treasury bill interest calculation is actual/360. Under this system, interest accrues on the actual number of elapsed days between purchase and maturity, and each year contains 360 days.\nSee Also tbilldisc2yield  |  tbillprice  |  tbillrepo  |  tbillyield  |  tbillyield2disc  |  tbillval01  | tbl2bond  |  tr2bonds  |  zbtprice  |  zbtyield\nRelated Examples\n• “Handle and Convert Dates” on page 2-2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 69,
      "section_heading": "Treasury Bills Defined",
      "captions": ""
    }
  },
  {
    "text": "Related Examples\n• “Handle and Convert Dates” on page 2-2\n• “Term Structure of Interest Rates” on page 2-29\n• “Computing Treasury Bill Price and Yield” on page 2-26\nTreasury Bills Defined\n2-25",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 69,
      "section_heading": "Treasury Bills Defined",
      "captions": ""
    }
  },
  {
    "text": "Computing Treasury Bill Price and Yield\nIn this section...\n“Introduction” on page 2-26\n“Treasury Bill Repurchase Agreements” on page 2-26\n“Treasury Bill Yields” on page 2-27\nIntroduction\nFinancial Toolbox software provides the following suite of functions for computing price and yield on Treasury bills.\nTreasury Bill Functions\nFunction Purpose\ntbilldisc2yield Convert discount rate to yield.\ntbillprice Price Treasury bill given its yield or discount rate.\ntbillrepo Break-even discount of repurchase agreement.\ntbillyield Yield and discount of Treasury bill given its price.\ntbillyield2disc Convert yield to discount rate.\ntbillval01 The value of 1 basis point (one hundredth of one percentage point, or 0.0001) given the characteristics of the Treasury bill, as represented by its settlement and maturity dates. You can relate the basis point to discount, money-market, or bond-equivalent yield.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 70,
      "section_heading": "Computing Treasury Bill Price and Yield",
      "captions": ""
    }
  },
  {
    "text": "For all functions with yield in the computation, you can specify yield as money-market or bond- equivalent yield. The functions all assume a face value of $100 for each Treasury bill.\nTreasury Bill Repurchase Agreements\nThis example shows how to compute the break-even discount rate. This is the rate that correctly prices the Treasury bill such that the profit from selling the tail equals 0.\nMaturity =  '26-Dec-2002' ; InitialDiscount = 0.0161; PurchaseDate =  '26-Sep-2002' ; SaleDate =  '26-Oct-2002' ; RepoRate = 0.0149;\nBreakevenDiscount = tbillrepo(RepoRate, InitialDiscount,  ...   PurchaseDate, SaleDate, Maturity)\nBreakevenDiscount =  0.0167\nYou can check the result of this computation by examining the cash flows in and out from the repurchase transaction. First compute the price of the Treasury bill on the purchase date (September 26).\n2 Performing Common Financial Tasks\n2-26",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 70,
      "section_heading": "Computing Treasury Bill Price and Yield",
      "captions": ""
    }
  },
  {
    "text": "PriceOnPurchaseDate = tbillprice(InitialDiscount,  ...   PurchaseDate, Maturity, 3)\nPriceOnPurchaseDate =  99.5930\nCompute the interest due on the repurchase agreement.\nRepoInterest =  ...   RepoRate*PriceOnPurchaseDate*days360(PurchaseDate,SaleDate)/360\nRepoInterest =  0.1237\nRepoInterest  for a 1.49% 30-day term repurchase agreement (30/360 basis) is  0.1237 .\nCompute the price of the Treasury bill on the sale date (October 26).\nPriceOnSaleDate = tbillprice(BreakevenDiscount, SaleDate,  ...   Maturity, 3)\nPriceOnSaleDate =  99.7167\nExamining the cash flows, observe that the break-even discount causes the sum of the price on the purchase date plus the accrued 30-day interest to be equal to the price on sale date. The following table shows the cash flows:\nCash Flows from Repurchase Agreement\nDate Cash Out Flow Cash In Flow\n9/26/2002 Purchase T-bill 99.593 Repo money 99.593\n10/26/2002 Payment of repo 99.593 Sell T-bill 99.7168\nRepo interest 0.1238\nTotal 199.3098 199.3098",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 71,
      "section_heading": "Treasury Bill Yields",
      "captions": ""
    }
  },
  {
    "text": "Date Cash Out Flow Cash In Flow\n9/26/2002 Purchase T-bill 99.593 Repo money 99.593\n10/26/2002 Payment of repo 99.593 Sell T-bill 99.7168\nRepo interest 0.1238\nTotal 199.3098 199.3098\nTreasury Bill Yields\nThis example shows how to convert a Treasury bill discount to an equivalent yield.\nYou can examine the money-market and bond-equivalent yields of a Treasury bill at the time of purchase and sale. The function  tbilldisc2yield  can perform both computations at one time.\nMaturity =  '26-Dec-2002' ; InitialDiscount = 0.0161; PurchaseDate =  '26-Sep-2002' ; SaleDate =  '26-Oct-2002' ; RepoRate = 0.0149; BreakevenDiscount = tbillrepo(RepoRate, InitialDiscount,  ...   PurchaseDate, SaleDate, Maturity)\nBreakevenDiscount =  0.0167\nComputing Treasury Bill Price and Yield\n2-27",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 71,
      "section_heading": "Treasury Bill Yields",
      "captions": ""
    }
  },
  {
    "text": "[BEYield, MMYield] =  ... tbilldisc2yield([InitialDiscount; BreakevenDiscount],  ...   [PurchaseDate; SaleDate], Maturity)\nBEYield =  2×1\n0.0164     0.0170\nMMYield =  2×1\n0.0162     0.0168\nFor the short Treasury bill (fewer than 182 days to maturity), the money-market yield is 360/365 of the bond-equivalent yield, as this example shows.\nSee Also tbilldisc2yield  |  tbillprice  |  tbillrepo  |  tbillyield  |  tbillyield2disc  |  tbillval01  | tbl2bond  |  tr2bonds  |  zbtprice  |  zbtyield\nRelated Examples\n• “Handle and Convert Dates” on page 2-2\n• “Term Structure of Interest Rates” on page 2-29\nMore About\n• “Treasury Bills Defined” on page 2-25\n2 Performing Common Financial Tasks\n2-28",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 72,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Term Structure of Interest Rates\nThis example shows how to derive and analyze interest-rate curves, including data conversion and extrapolation, bootstrapping, and interest-rate curve conversions.\nOne of the first problems in analyzing the term structure of interest rates is dealing with market data reported in different formats. Treasury bills, for example, are quoted with bid and asked bank- discount rates. Treasury notes and bonds, on the other hand, are quoted with bid and asked prices based on $100 face value. To examine the full spectrum of Treasury securities, analysts must convert data to a single format. Financial Toolbox™ functions ease this conversion. The following code uses only one security each; analysts often use 30, 100, or more of each.\nFirst, capture Treasury bill quotes and Reasury bond quotes in their reported format.\n%        Maturity               Days  Bid     Ask     AskYield TBill = [datenum( '12/26/2000' )  53    0.0503  0.0499  0.0510];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 73,
      "section_heading": "Term Structure of Interest Rates",
      "captions": ""
    }
  },
  {
    "text": "%        Maturity               Days  Bid     Ask     AskYield TBill = [datenum( '12/26/2000' )  53    0.0503  0.0499  0.0510];\n%        Coupon   Maturity           Bid       Ask       AskYield TBond = [0.08875  datenum(2001,11,5) 103+4/32  103+6/32  0.0564];\nNote that these quotes are based on a November 3, 2000 settlement date.\nSettle = datenum( '3-Nov-2000' );\nUse the  tbl2bond  to convert the Treasury bill data to Treasury bond format.\nTBTBond = tbl2bond(TBill)\nTBTBond =  1×5 10 5  ×\n0    7.3085    0.0010    0.0010    0.0000\nThe second element of TBTBond is the serial date number for December 26, 2000.\nCombine short-term (Treasury bill) with long-term (Treasury bond) data to set up the overall term structure.\nTBondsAll = [TBTBond; TBond]\nTBondsAll =  2×5 10 5  ×\n0    7.3085    0.0010    0.0010    0.0000     0.0000    7.3116    0.0010    0.0010    0.0000",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 73,
      "section_heading": "Term Structure of Interest Rates",
      "captions": ""
    }
  },
  {
    "text": "TBondsAll = [TBTBond; TBond]\nTBondsAll =  2×5 10 5  ×\n0    7.3085    0.0010    0.0010    0.0000     0.0000    7.3116    0.0010    0.0010    0.0000\nUse  tr2bonds  to convert the bond data into a form ready for the bootstrapping functions.  tr2bonds generates a matrix of bond information sorted by maturity date, plus vectors of prices and yields.\n[Bonds, Prices, Yields] = tr2bonds(TBondsAll)\nBonds =  2×6 10 5  ×\nTerm Structure of Interest Rates\n2-29",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 73,
      "section_heading": "Term Structure of Interest Rates",
      "captions": ""
    }
  },
  {
    "text": "7.3085         0    0.0010         0         0    0.0000     7.3116    0.0000    0.0010    0.0000         0    0.0000\nPrices =  2×1\n99.2654   103.1875\nYields =  2×1\n0.0510     0.0564\nUse a bootstrapping function to derive an implied zero curve. Bootstrapping is a process whereby you begin with known data points and solve for unknown data points using an underlying arbitrage theory. Every coupon bond can be valued as a package of zero-coupon bonds which mimic its cash flow and risk characteristics. By mapping yields-to-maturity for each theoretical zero-coupon bond, to the dates spanning the investment horizon, you can create a theoretical zero-rate curve. The Financial Toolbox™ software provides two bootstrapping functions:  zbtprice  derives a zero curve from bond data and  prices , and  zbtyield  derives a zero curve from bond data and  yields . Using zbtprice\n[ZeroRates, CurveDates] = zbtprice(Bonds, Prices, Settle)\nZeroRates =  2×1\n0.0516     0.0558\nCurveDates =  2×1",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 74,
      "section_heading": "Use a bootstrapping function to derive an implied zero curve. Bootstrapping is a process whereby you",
      "captions": ""
    }
  },
  {
    "text": "[ZeroRates, CurveDates] = zbtprice(Bonds, Prices, Settle)\nZeroRates =  2×1\n0.0516     0.0558\nCurveDates =  2×1\n730846       731160\nCurveDates  gives the investment horizon.\ndatestr(CurveDates)\nans =  2×11 char array     '26-Dec-2000'     '05-Nov-2001'\nUse the functions  zero2disc ,  zero2fwd , and  zero2pyld  to construct discount, forward, and par yield curves from the zero curve, and vice versa.\n[DiscRates, CurveDates] = zero2disc(ZeroRates, CurveDates, Settle)\nDiscRates =  2×1\n0.9926     0.9462\n2 Performing Common Financial Tasks\n2-30",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 74,
      "section_heading": "Use a bootstrapping function to derive an implied zero curve. Bootstrapping is a process whereby you",
      "captions": ""
    }
  },
  {
    "text": "CurveDates =  2×1\n730846       731160\n[FwdRates, CurveDates] = zero2fwd(ZeroRates, CurveDates, Settle)\nFwdRates =  2×1\n0.0516     0.0565\nCurveDates =  2×1\n730846       731160\n[PYldRates, CurveDates] = zero2pyld(ZeroRates, CurveDates, Settle)\nPYldRates =  2×1\n0.0522     0.0557\nCurveDates =  2×1\n730846       731160\nSee Also tbilldisc2yield  |  tbillprice  |  tbillrepo  |  tbillyield  |  tbillyield2disc  |  tbillval01  | tbl2bond  |  tr2bonds  |  zbtprice  |  zbtyield\nRelated Examples\n• “Handle and Convert Dates” on page 2-2\n• “Computing Treasury Bill Price and Yield” on page 2-26\nMore About\n• “Treasury Bills Defined” on page 2-25\nTerm Structure of Interest Rates\n2-31",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 75,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Returns with Negative Prices\nOnce considered a mathematical impossibility, negative prices have become an established aspect of many financial markets. Negative prices arise in situations where investors determine that holding an asset entails more risk than the current value of the asset. For example, energy futures see negative prices because of costs associated with overproduction and limited storage capacity. In a different setting, central banks impose negative interest rates when national economies become deflationary, and the pricing of interest rate derivatives, traditionally based on positivity, have to be rethought (see “Work with Negative Interest Rates Using Functions” (Financial Instruments Toolbox)). A negative price encourages the buyer to take something from the seller, and the seller pays a fee for the service of divesting.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 76,
      "section_heading": "Returns with Negative Prices",
      "captions": ""
    }
  },
  {
    "text": "MathWorks ®  Computational Finance products support several functions for converting between price series  p ( t ) and return series  r ( t ). Price positivity is not a requirement. The returns computed from input negative prices can be unexpected, but they have mathematical meaning that can help you to understand price movements.\nNegative Price Conversion\nFinancial Toolbox functions  ret2tick  and  tick2ret  support converting between price series  p ( t ) and return series  r ( t ).\nFor simple returns (default), the functions implement the formulas\nr s ( t ) = p s ( t ) p s ( t  −1)  −1\np s ( t ) =  p s ( t  −1)( r s ( t ) + 1) .\nFor continuous returns, the functions implement the formulas\nr c ( t ) = log p c ( t ) p c ( t  −1)\np c ( t ) =  p c ( t  −1) e rc ( t )   .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 76,
      "section_heading": "Returns with Negative Prices",
      "captions": ""
    }
  },
  {
    "text": "p s ( t ) =  p s ( t  −1)( r s ( t ) + 1) .\nFor continuous returns, the functions implement the formulas\nr c ( t ) = log p c ( t ) p c ( t  −1)\np c ( t ) =  p c ( t  −1) e rc ( t )   .\nThe functions  price2ret  and  ret2price  implement the same formulas, but they divide by Δ t  in the return formulas and they multiply by Δ t  in the price formulas. A positive factor of Δ t  (enforced by required monotonic observation times) does not affect the behavior of the functions. Econometrics Toolbox™ calls simple returns  periodic , and continuous returns are the default. Otherwise, the functionality between the set of functions is identical. This example concentrates on the Financial Toolbox functions.\nIn the simple return formula,  r s ( t ) is the percentage change ( PC ) in  p s ( t  − 1) over the interval [ t  − 1, t ]\nPC  = p s ( t ) p s ( t  −1)  −1\np s ( t ) =  p s ( t  −1) +  PC  ⋅ p s ( t  −1) .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 76,
      "section_heading": "Returns with Negative Prices",
      "captions": ""
    }
  },
  {
    "text": "PC  = p s ( t ) p s ( t  −1)  −1\np s ( t ) =  p s ( t  −1) +  PC  ⋅ p s ( t  −1) .\nFor positive prices, the range of  PC  is (−1,∞), that is, anything from a 100% loss ( p s :  p s ( t  − 1) → 0) to unlimited gain. The recursion in the second equation gives the subsequent prices;  p s ( t ) is computed from  p s ( t  − 1) by adding a percentage of  p s ( t  − 1).\n2 Performing Common Financial Tasks\n2-32",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 76,
      "section_heading": "Returns with Negative Prices",
      "captions": ""
    }
  },
  {
    "text": "Furthermore, you can aggregate simple returns through time using the formula\np s ( T ) p s (1)  −1 =  ∏ t  = 2\nT\nr s ( t ) + 1 −1,\nwhere the left-hand side represents the simple return over the entire interval [0, T ].\nContinuous returns add 1 to  PC  to move the range to (0,∞), the domain of the real logarithm. Continuous returns have the time aggregation property\nlog   p c ( T ) p c (1)  −1 = log  ∏ t  = 2\nT p c ( t ) p c ( t  −1) =  ∑ t  = 2\nT log p c ( t ) p c ( t  −1)  =  ∑ t  = 2\nT r c ( t ) .\nThis transformation ensures additivity of compound returns.\nIf negative prices are allowed, the range of simple returns  PC  expands to (−∞,∞), that is, anything from unlimited loss to unlimited gain. In the formula for continuous returns, logarithms of negative numbers are unavoidable. The logarithm of a negative number is not a mathematical problem because the complex logarithm (the MATLAB default) interprets negative numbers as complex numbers with phase angle ± π , so that, for example,",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 77,
      "section_heading": "Analysis of Negative Price Returns",
      "captions": ""
    }
  },
  {
    "text": "−2 = 2 e iπ\nlog( −2) = 2 +  iπ\nIf  x  < 0, log( x ) = log(| x |) ±  iπ . The log of a negative number has an imaginary part of ± π . The log of 0 is undefined because the range of the exponential  e iθ  is positive. Therefore, zero prices (that is, free exchanges) are unsupported.\nAnalysis of Negative Price Returns\nTo illustrate negative price inputs, consider the following price series and its simple returns.\np = [3; 1; -2; -1; 1]\np =\n3      1     -2     -1      1\nrs = tick2ret(p)\nrs =\n-0.6667    -3.0000    -0.5000    -2.0000\nThis table summarizes the recursions.\nReturns with Negative Prices\n2-33",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 77,
      "section_heading": "Analysis of Negative Price Returns",
      "captions": ""
    }
  },
  {
    "text": "The returns have the correct size (66%, 300%, 50%, 200%), but do they have the correct sign? If you interpret negative returns as losses, as with the positive price series, the signs seem wrong—the last two returns should be gains (that is, if you interpret less negative to be a gain). However, if you interpret the negative returns by the formula\np s ( t ) =  p s ( t  −1) +  PC  ⋅ p s ( t  −1),\nwhich requires the signs, the last two negative percentage changes multiply  negative  prices  p s ( t  − 1), which produces  positive  additions to  p s ( t  − 1). Briefly, a negative return on a negative price produces a positive price movement. The returns are correct.\nThe round trip produced by  ret2tick  returns the original price series.\nps = ret2tick(rs,StartPrice=3)\nps =\n3      1     -2     -1      1\nAlso, the following computations shows that time aggregation holds.\np(5)/p(1) - 1\nans =\n-0.6667\nprod(rs + 1) - 1\nans =\n-0.6667",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 78,
      "section_heading": "The returns have the correct size (66%, 300%, 50%, 200%), but do they have the correct sign? If you",
      "captions": ""
    }
  },
  {
    "text": "ps = ret2tick(rs,StartPrice=3)\nps =\n3      1     -2     -1      1\nAlso, the following computations shows that time aggregation holds.\np(5)/p(1) - 1\nans =\n-0.6667\nprod(rs + 1) - 1\nans =\n-0.6667\nFor continuous returns, negative price ratios  p c ( t )/ p c ( t  − 1) are interpreted as complex numbers with phase angles ± π , and the complex logarithm is invoked.\nrc = tick2ret(p,Method= \"continuous\" )\nrc =\n-1.0986 + 0.0000i    0.6931 + 3.1416i   -0.6931 + 0.0000i    0.0000 - 3.1416i\nThis table summarizes the recursions.\n2 Performing Common Financial Tasks\n2-34",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 78,
      "section_heading": "The returns have the correct size (66%, 300%, 50%, 200%), but do they have the correct sign? If you",
      "captions": ""
    }
  },
  {
    "text": "The real part shows the trend in the absolute price series. When | p c ( t  − 1)| < | p c ( t )|, that is, when prices move away from zero,  r c ( t ) has a positive real part. When | p c ( t  − 1)| > | p c ( t )|, that is, when prices move toward zero,  r c ( t ) has a negative real part. When | p c ( t  − 1)| = | p c ( t )|, that is, when the absolute size of the prices is unchanged,  r c ( t ) has a zero real part. For positive price series, where the absolute series is the same as the series itself, the real part has its usual meaning.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 79,
      "section_heading": "Visualization of Complex Returns",
      "captions": ""
    }
  },
  {
    "text": "The imaginary part shows changes of sign in the price series. When  p c ( t  − 1) > 0 and  p c ( t ) < 0, that is, when prices move from investments to divestments,  r c ( t ) has a positive imaginary part (+ π ). When p c ( t  − 1) < 0 and  p c ( t ) > 0, that is, when prices move from divestments to investments,  r c ( t ) has a negative imaginary part (− π ). When the sign of the prices is unchanged,  r c ( t ) has a zero imaginary part. For positive price series, changes of sign are irrelevant, and the imaginary part conveys no information (0).\nVisualization of Complex Returns\nComplex continuous returns contain a lot of information. Visualizing the information can help you to interpret the complex returns. The following code plots the real and imaginary parts of the logarithm on either side of zero.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 79,
      "section_heading": "Visualization of Complex Returns",
      "captions": ""
    }
  },
  {
    "text": "p = -5:0.01:5; hold  on plot(p,real(log(p)), \"b\" ) plot(p,imag(log(p)), \"r\" ) xticks(-5:5) xlabel( \"Price (p)\" ) ylabel( \"Ordinate\" ) legend([ \"real(log(p))\"   \"imag(log(p))\" ],AutoUpdate=false) grid  minor\nReturns with Negative Prices\n2-35",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 79,
      "section_heading": "Visualization of Complex Returns",
      "captions": ""
    }
  },
  {
    "text": "Due to the following identity\nr c ( t ) = log p c ( t ) p c ( t  −1)\n=log( p c ( t )) −log( p c ( t  −1))\n= [real(log( p c ( t )) −real(log( p c ( t  −1)))] ⨉ blue curve + [imag(log( p c ( t ))) −imag(log( p c ( t  −1)))] ⨉ red curve ⋅ i ,\nyou can read the real part of a continuous return as a difference in ordinates on the blue graph, and you can read the imaginary part as a difference in ordinates on the red graph. Absolute price movements toward zero result in a negative real part and absolute price movements away from zero result in a positive real part. Likewise, changes of sign result in a jump of ± π  in the imaginary part, with the sign change depending on the direction of the move.\nFor example, the plot below superimposes the real and imaginary parts of the logarithm at prices  p  = −4 and  p  = 2, with lines to help visualize their differences.\np = [-4; 2]; plot(p,real(log(p)), \"bo-\" ,MarkerFaceColor= \"b\" ) plot(p,imag(log(p)), \"ro-\" ,MarkerFaceColor= \"r\" ) hold  off",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 80,
      "section_heading": "Due to the following identity",
      "captions": ""
    }
  },
  {
    "text": "p = [-4; 2]; plot(p,real(log(p)), \"bo-\" ,MarkerFaceColor= \"b\" ) plot(p,imag(log(p)), \"ro-\" ,MarkerFaceColor= \"r\" ) hold  off\n2 Performing Common Financial Tasks\n2-36",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 80,
      "section_heading": "Due to the following identity",
      "captions": ""
    }
  },
  {
    "text": "If  p c ( t  − 1) = −4 and  p c ( t ) = 2, the real part of log( p c ( t )) − log( p c ( t  − 1)) is negative (line slopes down), corresponding to a decrease in absolute price. The imaginary part is 0 –  π  = − π , corresponding to a change of sign from negative to positive. If the direction of the price movement is reversed, so that  p c ( t  − 1) = 2 and  p c ( t ) = −4, the positive difference in the real part corresponds to an increase in absolute price, and the positive difference in the imaginary part corresponds to a change of sign from positive to negative.\nIf you convert the continuous returns  r c ( t ) = log( p c ( t )/ p c ( t  − 1) ) to simple returns  r s  = ( p s ( t )/ p s ( t  − 1) − 1) by the following computation, the result is the same simple returns series as before.\nrs = exp(rc) - 1\nrs =\n-0.6667 + 0.0000i   -3.0000 + 0.0000i   -0.5000 + 0.0000i   -2.0000 - 0.0000i\nYou can complete the round trip, which results in the expected price series, by the computation",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 81,
      "section_heading": "− 1) = −4 and",
      "captions": ""
    }
  },
  {
    "text": "rs = exp(rc) - 1\nrs =\n-0.6667 + 0.0000i   -3.0000 + 0.0000i   -0.5000 + 0.0000i   -2.0000 - 0.0000i\nYou can complete the round trip, which results in the expected price series, by the computation\npc = ret2tick(rc,Method= \"continuous\" ,StartPrice=3)\npc =\n3.0000 + 0.0000i    1.0000 + 0.0000i   -2.0000 + 0.0000i   -1.0000 + 0.0000i    1.0000 + 0.0000i\nReturns with Negative Prices\n2-37",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 81,
      "section_heading": "− 1) = −4 and",
      "captions": ""
    }
  },
  {
    "text": "Conclusion\nComplex continuous returns are a necessary intermediary when considering logarithms of negative price ratios.  tick2ret  computes a continuous complex extension of the function on the positive real axis. The logarithm maintains the additivity property, used when computing multiperiod returns.\nBecause of the extensible logarithm implemented in MATLAB, current implementations of Computational Finance tools that accept prices and returns behave logically with negative prices. The interpretation of complex-valued results can be unfamiliar at first, but as shown, the results are meaningful and explicable.\nSee Also tick2ret  |  ret2tick\nMore About\n• “Work with Negative Interest Rates Using Functions” (Financial Instruments Toolbox)\n2 Performing Common Financial Tasks\n2-38",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 82,
      "section_heading": "Conclusion",
      "captions": ""
    }
  },
  {
    "text": "Pricing and Analyzing Equity Derivatives\nIn this section...\n“Introduction” on page 2-39\n“Sensitivity Measures” on page 2-39\n“Analysis Models” on page 2-40\nIntroduction\nThese toolbox functions compute prices, sensitivities, and profits for portfolios of options or other equity derivatives. They use the Black-Scholes model for European options and the binomial model for American options. Such measures are useful for managing portfolios and for executing collars, hedges, and straddles:\n• A collar is an interest-rate option that guarantees that the rate on a floating-rate loan will not exceed a certain upper level nor fall below a lower level. It is designed to protect an investor against wide fluctuations in interest rates.\n• A hedge is a securities transaction that reduces or offsets the risk on an existing investment position.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 83,
      "section_heading": "Pricing and Analyzing Equity Derivatives",
      "captions": ""
    }
  },
  {
    "text": "• A hedge is a securities transaction that reduces or offsets the risk on an existing investment position.\n• A straddle is a strategy used in trading options or futures. It involves simultaneously purchasing put and call options with the same exercise price and expiration date, and it is most profitable when the price of the underlying security is very volatile.\nSensitivity Measures\nThere are six basic sensitivity measures associated with option pricing: delta, gamma, lambda, rho, theta, and vega — the “greeks.” The toolbox provides functions for calculating each sensitivity and for implied volatility.\nDelta\nDelta of a derivative security is the rate of change of its price relative to the price of the underlying asset. It is the first derivative of the curve that relates the price of the derivative to the price of the underlying security. When delta is large, the price of the derivative is sensitive to small changes in the price of the underlying security.\nGamma",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 83,
      "section_heading": "Pricing and Analyzing Equity Derivatives",
      "captions": ""
    }
  },
  {
    "text": "Gamma\nGamma of a derivative security is the rate of change of delta relative to the price of the underlying asset; that is, the second derivative of the option price relative to the security price. When gamma is small, the change in delta is small. This sensitivity measure is important for deciding how much to adjust a hedge position.\nLambda\nLambda, also known as the elasticity of an option, represents the percentage change in the price of an option relative to a 1% change in the price of the underlying security.\nRho\nRho is the rate of change in option price relative to the risk-free interest rate.\nPricing and Analyzing Equity Derivatives\n2-39",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 83,
      "section_heading": "Pricing and Analyzing Equity Derivatives",
      "captions": ""
    }
  },
  {
    "text": "Theta\nTheta is the rate of change in the price of a derivative security relative to time. Theta is usually small or negative since the value of an option tends to drop as it approaches maturity.\nVega\nVega is the rate of change in the price of a derivative security relative to the volatility of the underlying security. When vega is large the security is sensitive to small changes in volatility. For example, options traders often must decide whether to buy an option to hedge against vega or gamma. The hedge selected usually depends upon how frequently one rebalances a hedge position and also upon the standard deviation of the price of the underlying asset (the volatility). If the standard deviation is changing rapidly, balancing against vega is preferable.\nImplied Volatility",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 84,
      "section_heading": "Analysis Models",
      "captions": ""
    }
  },
  {
    "text": "Implied Volatility\nThe implied volatility of an option is the standard deviation that makes an option price equal to the market price. It helps determine a market estimate for the future volatility of a stock and provides the input volatility (when needed) to the other Black-Scholes functions.\nAnalysis Models\nToolbox functions for analyzing equity derivatives use the Black-Scholes model for European options and the binomial model for American options. The Black-Scholes model makes several assumptions about the underlying securities and their behavior. The Black-Scholes model was the first complete mathematical model for pricing options, developed by Fischer Black and Myron Scholes. It examines market price, strike price, volatility, time to expiration, and interest rates. It is limited to only certain kinds of options.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 84,
      "section_heading": "Analysis Models",
      "captions": ""
    }
  },
  {
    "text": "The binomial model, on the other hand, makes far fewer assumptions about the processes underlying an option. A binomial model is a method of pricing options or other equity derivatives in which the probability over time of each possible price follows a binomial distribution. The basic assumption is that prices can move to only two values (one higher and one lower) over any short time period. For further explanation, see  Options, Futures, and Other Derivatives  by John Hull in “Bibliography” on page A-2.\nBlack-Scholes Model\nThis example shows how to compute the call and put prices of a European option and its delta, gamma, lambda, and implied volatility.\nUsing the Black-Scholes model entails several assumptions:\n• The prices of the underlying asset follow an Ito process. (See “Derivatives Pricing and Yields” on page A-3, page 222.)\n• The option can be exercised only on its expiration date (European option).\n• Short selling is permitted.\n• There are no transaction costs.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 84,
      "section_heading": "Analysis Models",
      "captions": ""
    }
  },
  {
    "text": "• The option can be exercised only on its expiration date (European option).\n• Short selling is permitted.\n• There are no transaction costs.\n• All securities are divisible.\n• There is no riskless arbitrage (where  arbitrage  is the purchase of securities on one market for immediate resale on another market to profit from a price or currency discrepancy).\n2 Performing Common Financial Tasks\n2-40",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 84,
      "section_heading": "Analysis Models",
      "captions": ""
    }
  },
  {
    "text": "• Trading is a continuous process.\n• The risk-free interest rate is constant and remains the same for all maturities.\nIf any of these assumptions is untrue, Black-Scholes may not be an appropriate model.\nTo illustrate toolbox Black-Scholes functions ( blsprice ,  blsdelta ,  blsgamma ,  blsvega , and blslambda ) this example computes the call and put prices of a European option and its delta, gamma, lambda, and implied volatility. The asset price is $100.00, the exercise price is $95.00, the risk-free interest rate is 10%, the time to maturity is 0.25 years, the volatility is 0.50, and the dividend rate is 0.\n[OptCall, OptPut] = blsprice(100, 95, 0.10, 0.25, 0.50, 0)\nOptCall =  13.6953\nOptPut =  6.3497\n[CallVal, PutVal] = blsdelta(100, 95, 0.10, 0.25, 0.50, 0)\nCallVal =  0.6665\nPutVal =  -0.3335\nGammaVal = blsgamma(100, 95, 0.10, 0.25, 0.50, 0)\nGammaVal =  0.0145\nVegaVal = blsvega(100, 95, 0.10, 0.25, 0.50, 0)\nVegaVal =  18.1843",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 85,
      "section_heading": "Trading is a continuous process.",
      "captions": ""
    }
  },
  {
    "text": "CallVal =  0.6665\nPutVal =  -0.3335\nGammaVal = blsgamma(100, 95, 0.10, 0.25, 0.50, 0)\nGammaVal =  0.0145\nVegaVal = blsvega(100, 95, 0.10, 0.25, 0.50, 0)\nVegaVal =  18.1843\n[LamCall, LamPut] = blslambda(100, 95, 0.10, 0.25, 0.50, 0)\nLamCall =  4.8664\nLamPut =  -5.2528\nTo summarize:\n• The option call price  OptCall  =  $13.70\n• The option put price  OptPut  =  $6.35\n• delta for a call  CallVal  =  0.6665  and delta for a put PutVal =  -0.3335\n• gamma  GammaVal  =  0.0145\n• vega  VegaVal  =  18.1843\n• lambda for a call  LamCal l =  4.8664  and lambda for a put  LamPut  =  –5.2528\nAs a computation check, find the implied volatility of the option using the call option price from blsprice .\nPricing and Analyzing Equity Derivatives\n2-41",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 85,
      "section_heading": "Trading is a continuous process.",
      "captions": ""
    }
  },
  {
    "text": "Volatility = blsimpv(100, 95, 0.10, 0.25, OptCall)\nVolatility =  0.5000\nThe function returns an implied volatility of  0.500 , the original  blsprice  input.\nBinomial Model\nThis example shows how to price an American call option using a binomial model.\nThe binomial model for pricing options or other equity derivatives assumes that the probability over time of each possible price follows a binomial distribution. The basic assumption is that prices can move to only two values, one up and one down, over any short time period. Plotting the two values, and then the subsequent two values each, and then the subsequent two values each, and so on over time, is known as \"building a binomial tree.\". This model applies to American options, which can be exercised any time up to and including their expiration date.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 86,
      "section_heading": "The function returns an implied volatility of",
      "captions": ""
    }
  },
  {
    "text": "This example prices an American call option using a binomial model. The asset price is $100.00, the exercise price is $95.00, the risk-free interest rate is 10%, and the time to maturity is 0.25 years. The function  binprice  computes the tree in increments of 0.05 years, so there are 0.25/0.05 = 5 periods in the example. The volatility is 0.50, this is a call ( flag  =  1 ), the dividend rate is 0, and it pays a dividend of $5.00 after three periods (an ex-dividend date).\n[StockPrice, OptionPrice] = binprice(100, 95, 0.10, 0.25,  ...   0.05,  0.50, 1, 0, 5.0, 3)\nStockPrice =  6×6\n100.0000  111.2713  123.8732  137.9629  148.6915  166.2807          0   89.9677  100.0495  111.3211  118.8981  132.9629          0         0   80.9994   90.0175   95.0744  106.3211          0         0         0   72.9825   76.0243   85.0175          0         0         0         0   60.7913   67.9825          0         0         0         0         0   54.3608\nOptionPrice =  6×6",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 86,
      "section_heading": "The function returns an implied volatility of",
      "captions": ""
    }
  },
  {
    "text": "OptionPrice =  6×6\n12.1011   19.1708   29.3470   42.9629   54.1653   71.2807          0    5.3068    9.4081   16.3211   24.3719   37.9629          0         0    1.3481    2.7402    5.5698   11.3211          0         0         0         0         0         0          0         0         0         0         0         0          0         0         0         0         0         0\nThe output from the binomial function is a binary tree. Read the  StockPrice  matrix this way: column 1 shows the price for period 0, column 2 shows the up and down prices for period 1, column 3 shows the up-up, up-down, and down-down prices for period 2, and so on. Ignore the zeros. The OptionPrice  matrix gives the associated option value for each node in the price tree. Ignore the zeros that correspond to a zero in the price tree.\n2 Performing Common Financial Tasks\n2-42",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 86,
      "section_heading": "The function returns an implied volatility of",
      "captions": ""
    }
  },
  {
    "text": "See Also blsprice  |  binprice  |  blkimpv  |  blkprice  |  blsdelta  |  blsgamma  |  blsimpv  |  blslambda  | blsrho  |  blstheta  |  blsvega  |  opprofit\nRelated Examples\n• “Handle and Convert Dates” on page 2-2\n• “Greek-Neutral Portfolios of European Stock Options” on page 10-14\n• “Plotting Sensitivities of an Option” on page 10-25\n• “Plotting Sensitivities of a Portfolio of Options” on page 10-27\nPricing and Analyzing Equity Derivatives\n2-43",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 87,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "About Life Tables\nLife tables are used for life insurance and work with the probability distribution of human mortality. This distribution, which is age-dependent, has several characteristic features that are consequences of biological, cultural, and behavioral factors. Usually, the practitioners of life studies use life tables that contain age-dependent series for specific demographics. The tables are in a standard format with standard notation that is specific to the life studies field. An example of a life table is shown in Table 1 from CDC life tables for the United States.\nOften, these life tables can have numerous variations such as abridged tables (which pose challenges due to the granularity of the data) and different termination criteria (that can make it difficult to compare tables or to compute life expectancies).",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 88,
      "section_heading": "About Life Tables",
      "captions": "About Life Tables, Life tables are used for life insurance and work with the probability distribution of human mortality. This distribution, which is age-dependent, has several characteristic features that are consequences of biological, cultural, and behavioral factors. Usually, the practitioners of life studies use life tables that contain age-dependent series for specific demographics. The tables are in a standard format with standard notation that is specific to the life studies field. An example of a life table is shown in Table 1 from CDC life tables for the United States., Life Tables Theory"
    }
  },
  {
    "text": "Most raw life tables have one or more of the first three series in this table ( q x ,  l x , and  d x ) and the notation for these three series is standard in the field.\n• The  q x  series is basically the discrete hazard function for human mortality.\n• The  l x  series is the survival function multiplied by a radix of 100,000.\n• The  d x  series is the discrete probability density for the distribution as a function of age.\nFinancial Toolbox can handle arbitrary life table data supporting several standard models of mortality and provides various interpolation methods to calibrate and analyze the life table data.\nAlthough primarily designed for life insurance applications, the life tables functions ( lifetableconv ,  lifetablefit , and  lifetablegen  can also be used by social scientists, behavioral psychologists, public health officials, and medical researchers.\nLife Tables Theory",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 88,
      "section_heading": "About Life Tables",
      "captions": "About Life Tables, Life tables are used for life insurance and work with the probability distribution of human mortality. This distribution, which is age-dependent, has several characteristic features that are consequences of biological, cultural, and behavioral factors. Usually, the practitioners of life studies use life tables that contain age-dependent series for specific demographics. The tables are in a standard format with standard notation that is specific to the life studies field. An example of a life table is shown in Table 1 from CDC life tables for the United States., Life Tables Theory"
    }
  },
  {
    "text": "Life Tables Theory\nLife tables are based on hazard functions and survival functions which are, in turn, derived from probability distributions. Specifically, given a continuous probability distribution, its cumulative distribution function is F( x ) and its probability density function is f( x ) = d F( x )/d x .\nFor the analysis of mortality, the random variable of interest  X  is the distribution of ages at which individuals die within a population. So, the probability that someone dies by age  x  is\nPr[ X  ≤ x ] =  F ( x )\nThe survival function, ( s(x) ), which characterizes the probability that an individual lives beyond a specified age  x  >  0 , is\n2 Performing Common Financial Tasks\n2-44",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 88,
      "section_heading": "About Life Tables",
      "captions": "About Life Tables, Life tables are used for life insurance and work with the probability distribution of human mortality. This distribution, which is age-dependent, has several characteristic features that are consequences of biological, cultural, and behavioral factors. Usually, the practitioners of life studies use life tables that contain age-dependent series for specific demographics. The tables are in a standard format with standard notation that is specific to the life studies field. An example of a life table is shown in Table 1 from CDC life tables for the United States., Life Tables Theory"
    }
  },
  {
    "text": "s ( x ) =  Pr [ X  >  x ] = 1 − F ( x )\nFor a continuous probability distribution, the hazard function is a function of the survival function with\nh ( x ) = lim Δx 0\nPr [ x  ≤ X  <  x  +  Δx X  ≥ x ] Δx\n= − 1 s ( x )\nd ( s ( x )) dx\nand the survival functions is a function of the hazard function with\ns ( x ) = exp − ∫ 0\nx h ( ξ ) dξ\nLife table models generally specify either the hazard function or the survival function. However, life tables are discrete and work with discrete versions of the hazard and survival functions. Three series are used for life tables and the notation is the convention. The discrete hazard function is denoted as\nq x  ≈ h ( x )\n= 1 − s ( x  + 1) s ( x )\nwhich is the probability a person at age  x  dies by age  x  +  1  (where  x  is in years). The discrete survival function is presented in terms of an initial number of survivors at birth called the life table radix (which is usually 100,000 individuals) and is denoted as\nl x  =  l 0 s ( x )",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 89,
      "section_heading": "See Also",
      "captions": "• “Case Study for Life Tables Analysis” on page 2-46, About Life Tables"
    }
  },
  {
    "text": "l x  =  l 0 s ( x )\nwith radix  l 0  =  100000 . This number,  l x , represents the number of individuals out of 100,000 at birth who are still alive at age  x .\nA third series is related to the probability density function which is the number of \"standardized\" deaths in a given year denoted as\nd x  =  l x  − l x  + 1\nBased on a few additional rules about how to initialize and terminate these series, any one series can be derived from any of the other series.\nSee Also lifetableconv  |  lifetablefit  |  lifetablegen\nRelated Examples\n• “Case Study for Life Tables Analysis” on page 2-46\nAbout Life Tables\n2-45",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 89,
      "section_heading": "See Also",
      "captions": "• “Case Study for Life Tables Analysis” on page 2-46, About Life Tables"
    }
  },
  {
    "text": "Case Study for Life Tables Analysis\nThis example shows how to use the basic workflow for life tables.\nLoad the life table data file.\nload  us_lifetable_2009\nCalibrate life table from survival data with the default  heligman-pollard  parametric model.\na = lifetablefit(x, lx);\nGenerate life table series from the calibrated mortality model.\nqx = lifetablegen((0:100), a); display(qx(1:40,:))",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 90,
      "section_heading": "Case Study for Life Tables Analysis",
      "captions": "Case Study for Life Tables Analysis"
    }
  },
  {
    "text": "0.0063    0.0069    0.0057     0.0005    0.0006    0.0004     0.0002    0.0003    0.0002     0.0002    0.0002    0.0002     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0001    0.0001    0.0001     0.0002    0.0002    0.0001     0.0002    0.0002    0.0002     0.0002    0.0003    0.0002     0.0003    0.0004    0.0002     0.0004    0.0005    0.0002     0.0005    0.0006    0.0003     0.0006    0.0008    0.0003     0.0007    0.0009    0.0003     0.0008    0.0011    0.0003     0.0008    0.0012    0.0004     0.0009    0.0013    0.0004     0.0009    0.0014    0.0005     0.0010    0.0014    0.0005     0.0010    0.0015    0.0005     0.0010    0.0015    0.0006     0.0010    0.0015    0.0006     0.0010    0.0015    0.0007     0.0010    0.0014    0.0007     0.0011    0.0014    0.0007     0.0011    0.0014    0.0008     0.0011",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 90,
      "section_heading": "Case Study for Life Tables Analysis",
      "captions": "Case Study for Life Tables Analysis"
    }
  },
  {
    "text": "0.0010    0.0015    0.0006     0.0010    0.0015    0.0006     0.0010    0.0015    0.0007     0.0010    0.0014    0.0007     0.0011    0.0014    0.0007     0.0011    0.0014    0.0008     0.0011    0.0014    0.0008     0.0011    0.0014    0.0009     0.0011    0.0014    0.0009     0.0012    0.0015    0.0010     0.0012    0.0015    0.0011     0.0013    0.0016    0.0011     0.0014    0.0017    0.0012     0.0015    0.0018    0.0013",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 90,
      "section_heading": "Case Study for Life Tables Analysis",
      "captions": "Case Study for Life Tables Analysis"
    }
  },
  {
    "text": "2 Performing Common Financial Tasks\n2-46",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 90,
      "section_heading": "Case Study for Life Tables Analysis",
      "captions": "Case Study for Life Tables Analysis"
    }
  },
  {
    "text": "Plot the  qx  series and display the legend. The series  qx  is the conditional probability that a person at age  x  will die between age  x  and the next age in the series\nplot((0:100), log(qx)); legend(series,  'location' ,  'southeast' ); title( 'Conditional Probability of Dying within One Year of Current Age' ); xlabel( 'Age' ); ylabel( 'Log Probability' );\nSee Also lifetableconv  |  lifetablefit  |  lifetablegen\nMore About\n• “About Life Tables” on page 2-44\nCase Study for Life Tables Analysis\n2-47",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 91,
      "section_heading": "See Also",
      "captions": "• “About Life Tables” on page 2-44, Case Study for Life Tables Analysis"
    }
  },
  {
    "text": "Machine Learning for Statistical Arbitrage: Introduction\nMachine learning techniques for processing large amounts of data are broadly applicable in computational finance. The series of examples introduced in this topic provides a general workflow, illustrating how capabilities in MATLAB apply to a specific problem in financial engineering. The workflow is problem-oriented, exploratory, and guided by the data and the resulting analysis. The overall approach, however, is useful for constructing applications in many areas.\nThe workflow consists of these actions:\n• Formulate a simple approach to algorithmic trading, through an analysis of market microstructure, with the goal of identifying real-time arbitrage opportunities.\n• Use a large sample of exchange data to track order dynamics of a single security on a single day, selectively processing the data to develop relevant statistical measures.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 92,
      "section_heading": "Machine Learning for Statistical Arbitrage: Introduction",
      "captions": ""
    }
  },
  {
    "text": "• Use a large sample of exchange data to track order dynamics of a single security on a single day, selectively processing the data to develop relevant statistical measures.\n• Create a model of intraday dynamics conditioned on a selection of hyperparameters introduced during feature engineering and development.\n• Evaluate hyperparameter tunings using a supervising objective that computes cash returned on a model-based trading strategy.\n• Optimize the trading strategy using different machine learning algorithms.\n• Suggest modifications for further development.\nThe workflow is separated into three examples:\n2 Performing Common Financial Tasks\n2-48",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 92,
      "section_heading": "Machine Learning for Statistical Arbitrage: Introduction",
      "captions": ""
    }
  },
  {
    "text": "1 “Machine Learning for Statistical Arbitrage I: Data Management and Visualization” on page 2- 50\n2 “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59\n3 “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69\nFor more information about general workflows for machine learning, see:\n• “Machine Learning in MATLAB”\n• “Supervised Learning Workflow and Algorithms”\nMachine Learning for Statistical Arbitrage: Introduction\n2-49",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 93,
      "section_heading": "“Machine Learning for Statistical Arbitrage I: Data Management and Visualization” on page 2-",
      "captions": ""
    }
  },
  {
    "text": "Machine Learning for Statistical Arbitrage I: Data Management and Visualization\nThis example shows techniques for managing, processing, and visualizing large amounts of financial data in MATLAB®. It is part of a series of related examples on machine learning for statistical arbitrage (see “Machine Learning Applications”).\nWorking with Big Data\nFinancial markets, with electronic exchanges such as NASDAQ executing orders on a timescale of milliseconds, generate vast amounts of data. Data streams can be mined for statistical arbitrage opportunities, but traditional methods for processing and storing dynamic analytic information can be overwhelmed by big data. Fortunately, new computational approaches have emerged, and MATLAB has an array of tools for implementing them.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 94,
      "section_heading": "Machine Learning for Statistical Arbitrage I: Data Management",
      "captions": ""
    }
  },
  {
    "text": "Main computer memory provides high-speed access but limited capacity, whereas external storage offers low-speed access but potentially unlimited capacity. Computation takes place in memory. The computer recalls data and results from external storage.\nData Files\nThis example uses one trading day of NASDAQ exchange data [2] on one security (INTC) in a sample provided by LOBSTER [1] and included with Financial Toolbox™ documentation in the zip file LOBSTER_SampleFile_INTC_2012-06-21_5.zip . Extract the contents of the zip file into your current folder. The expanded files, including two CSV files of data and the text file LOBSTER_SampleFiles_ReadMe.txt , consume 93.7 MB of memory.\nunzip( \"LOBSTER_SampleFile_INTC_2012-06-21_5.zip\" );",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 94,
      "section_heading": "Machine Learning for Statistical Arbitrage I: Data Management",
      "captions": ""
    }
  },
  {
    "text": "unzip( \"LOBSTER_SampleFile_INTC_2012-06-21_5.zip\" );\nThe data describes the intraday evolution of the  limit order book  (LOB), which is the record of  market orders  (best price),  limit orders  (designated price), and resulting buys and sells. The data includes the precise time of these events, with orders tracked from arrival until cancellation or execution. At each moment in the trading day, orders on both the buy and sell side of the LOB exist at various  levels away from the midprice between the lowest ask (order to sell) and the highest bid (order to buy).\nLevel 5 data (five levels away from the midprice on either side) is contained in two CSV files. Extract the trading date from the message file name.\nMSGFileName =  \"INTC_2012-06-21_34200000_57600000_message_5.csv\" ;    % Message file (description of LOBFileName =  \"INTC_2012-06-21_34200000_57600000_orderbook_5.csv\" ;  % Data file\n[ticker,rem] = strtok(MSGFileName, '_' ); date = strtok(rem, '_' );\nData Storage",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 94,
      "section_heading": "Machine Learning for Statistical Arbitrage I: Data Management",
      "captions": ""
    }
  },
  {
    "text": "[ticker,rem] = strtok(MSGFileName, '_' ); date = strtok(rem, '_' );\nData Storage\nDaily data streams accumulate and need to be stored. A  datastore  is a repository for collections of data that are too big to fit in memory.\nUse  tabularTextDatastore  to create datastores for the message and data files. Because the files contain data with different formats, create the datastores separately. Ignore generic column headers (for example,  VarName1 ) by setting the  'ReadVariableNames'  name-value argument to  false . Replace the headers with descriptive variable names obtained from\n2 Performing Common Financial Tasks\n2-50",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 94,
      "section_heading": "Machine Learning for Statistical Arbitrage I: Data Management",
      "captions": ""
    }
  },
  {
    "text": "LOBSTER_SampleFiles_ReadMe.txt . Set the  'ReadSize'  name-value argument to  'file'  to allow similarly formatted files to be appended to existing datastores at the end of each trading day.\nDSMSG = tabularTextDatastore(MSGFileName, 'ReadVariableNames' ,false, 'ReadSize' , 'file' ); DSMSG.VariableNames = [ \"Time\" , \"Type\" , \"OrderID\" , \"Size\" , \"Price\" , \"Direction\" ];\nDSLOB = tabularTextDatastore(LOBFileName, 'ReadVariableNames' ,false, 'ReadSize' , 'file' ); DSLOB.VariableNames = [ \"AskPrice1\" , \"AskSize1\" , \"BidPrice1\" , \"BidSize1\" , ...                         \"AskPrice2\" , \"AskSize2\" , \"BidPrice2\" , \"BidSize2\" , ...                         \"AskPrice3\" , \"AskSize3\" , \"BidPrice3\" , \"BidSize3\" , ...                         \"AskPrice4\" , \"AskSize4\" , \"BidPrice4\" , \"BidSize4\" , ...                         \"AskPrice5\" , \"AskSize5\" , \"BidPrice5\" , \"BidSize5\" ];\nCreate a combined datastore by selecting  Time  and the level 3 data.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 95,
      "section_heading": "LOBSTER_SampleFiles_ReadMe.txt",
      "captions": ""
    }
  },
  {
    "text": "Create a combined datastore by selecting  Time  and the level 3 data.\nTimeVariable =  \"Time\" ; DSMSG.SelectedVariableNames = TimeVariable;\nLOB3Variables = [ \"AskPrice1\" , \"AskSize1\" , \"BidPrice1\" , \"BidSize1\" , ...                   \"AskPrice2\" , \"AskSize2\" , \"BidPrice2\" , \"BidSize2\" , ...                   \"AskPrice3\" , \"AskSize3\" , \"BidPrice3\" , \"BidSize3\" ]; DSLOB.SelectedVariableNames = LOB3Variables;                                 DS = combine(DSMSG,DSLOB);\nYou can preview the first few rows in the combined datastore without loading data into memory.\nDSPreview = preview(DS); LOBPreview = DSPreview(:,1:5)\nLOBPreview= 8×5 table     Time     AskPrice1    AskSize1    BidPrice1    BidSize1     _____    _________    ________    _________    ________",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 95,
      "section_heading": "LOBSTER_SampleFiles_ReadMe.txt",
      "captions": ""
    }
  },
  {
    "text": "DSPreview = preview(DS); LOBPreview = DSPreview(:,1:5)\nLOBPreview= 8×5 table     Time     AskPrice1    AskSize1    BidPrice1    BidSize1     _____    _________    ________    _________    ________\n34200    2.752e+05       66       2.751e+05      400        34200    2.752e+05      166       2.751e+05      400        34200    2.752e+05      166       2.751e+05      400        34200    2.752e+05      166       2.751e+05      400        34200    2.752e+05      166       2.751e+05      300        34200    2.752e+05      166       2.751e+05      300        34200    2.752e+05      166       2.751e+05      300        34200    2.752e+05      166       2.751e+05      300\nThe preview shows asks and bids  at the touch , meaning the level 1 data, which is closest to the midprice. Time units are seconds after midnight, price units are dollar amounts times 10,000, and size units are the number of shares (see  LOBSTER_SampleFiles_ReadMe.txt ).\nTall Arrays and Timetables",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 95,
      "section_heading": "LOBSTER_SampleFiles_ReadMe.txt",
      "captions": ""
    }
  },
  {
    "text": "Tall Arrays and Timetables\nTall arrays work with out-of-memory data backed by a datastore using the MapReduce technique (see “Tall Arrays for Out-of-Memory Data”). When you use MapReduce, tall arrays remain unevaluated until you execute specific computations that use the data.\nSet the execution environment for MapReduce to the local MATLAB session, instead of using Parallel Computing Toolbox™, by calling  mapreducer(0) . Then, create a tall array from the datastore  DS  by using  tall . Preview the data in the tall array.\nMachine Learning for Statistical Arbitrage I: Data Management and Visualization\n2-51",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 95,
      "section_heading": "LOBSTER_SampleFiles_ReadMe.txt",
      "captions": ""
    }
  },
  {
    "text": "mapreducer(0) DT = tall(DS);\nDTPreview = DT(:,1:5)\nDTPreview =\nM×5 tall table\nTime     AskPrice1    AskSize1    BidPrice1    BidSize1     _____    _________    ________    _________    ________\n34200    2.752e+05       66       2.751e+05      400        34200    2.752e+05      166       2.751e+05      400        34200    2.752e+05      166       2.751e+05      400        34200    2.752e+05      166       2.751e+05      400        34200    2.752e+05      166       2.751e+05      300        34200    2.752e+05      166       2.751e+05      300        34200    2.752e+05      166       2.751e+05      300        34200    2.752e+05      166       2.751e+05      300          :          :           :            :           :       :          :           :            :           :\nTimetables allow you to perform operations specific to time series (see “Create Timetables”). Because the LOB data consists of concurrent time series, convert  DT  to a tall timetable.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 96,
      "section_heading": "Timetables allow you to perform operations specific to time series (see “Create Timetables”). Because",
      "captions": ""
    }
  },
  {
    "text": "Timetables allow you to perform operations specific to time series (see “Create Timetables”). Because the LOB data consists of concurrent time series, convert  DT  to a tall timetable.\nDT.Time = seconds(DT.Time);  % Cast time as a duration from midnight. DTT = table2timetable(DT);\nDTTPreview = DTT(:,1:4)\nDTTPreview =\nM×4 tall timetable\nTime       AskPrice1    AskSize1    BidPrice1    BidSize1     _________    _________    ________    _________    ________",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 96,
      "section_heading": "Timetables allow you to perform operations specific to time series (see “Create Timetables”). Because",
      "captions": ""
    }
  },
  {
    "text": "DTTPreview = DTT(:,1:4)\nDTTPreview =\nM×4 tall timetable\nTime       AskPrice1    AskSize1    BidPrice1    BidSize1     _________    _________    ________    _________    ________\n34200 sec    2.752e+05       66       2.751e+05      400        34200 sec    2.752e+05      166       2.751e+05      400        34200 sec    2.752e+05      166       2.751e+05      400        34200 sec    2.752e+05      166       2.751e+05      400        34200 sec    2.752e+05      166       2.751e+05      300        34200 sec    2.752e+05      166       2.751e+05      300        34200 sec    2.752e+05      166       2.751e+05      300        34200 sec    2.752e+05      166       2.751e+05      300            :            :           :            :           :         :            :           :            :           :\nDisplay all variables in the MATLAB workspace.\nwhos\nName               Size            Bytes  Class                                       Attribute",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 96,
      "section_heading": "Timetables allow you to perform operations specific to time series (see “Create Timetables”). Because",
      "captions": ""
    }
  },
  {
    "text": "Display all variables in the MATLAB workspace.\nwhos\nName               Size            Bytes  Class                                       Attribute\nDS                 1x1                 8  matlab.io.datastore.CombinedDatastore                   DSLOB              1x1                 8  matlab.io.datastore.TabularTextDatastore                DSMSG              1x1                 8  matlab.io.datastore.TabularTextDatastore                DSPreview          8x13             4899  table\n2 Performing Common Financial Tasks\n2-52",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 96,
      "section_heading": "Timetables allow you to perform operations specific to time series (see “Create Timetables”). Because",
      "captions": ""
    }
  },
  {
    "text": "DT                 Mx13             5292  tall                                                    DTPreview          Mx5              2926  tall                                                    DTT                Mx12             5056  tall                                                    DTTPreview         Mx4              2704  tall                                                    LOB3Variables      1x12              952  string                                                  LOBFileName        1x1               262  string                                                  LOBPreview         8x5              2331  table                                                   MSGFileName        1x1               246  string                                                  TimeVariable       1x1               166  string                                                  date               1x1               182  string                                                  rem",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 97,
      "section_heading": "Because all the data is in the datastore, the workspace uses little memory.",
      "captions": ""
    }
  },
  {
    "text": "1x1               166  string                                                  date               1x1               182  string                                                  rem                1x1               246  string                                                  ticker             1x1               166  string",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 97,
      "section_heading": "Because all the data is in the datastore, the workspace uses little memory.",
      "captions": ""
    }
  },
  {
    "text": "Because all the data is in the datastore, the workspace uses little memory.\nPreprocess and Evaluate Data\nTall arrays allow preprocessing, or  queuing , of computations before they are evaluated, which improves memory management in the workspace.\nMidprice  S  and imbalance index  I  are used to model LOB dynamics. To queue their computations, define them, and the time base, in terms of  DTT .\ntimeBase = DTT.Time; MidPrice = (DTT.BidPrice1 + DTT.AskPrice1)/2;\n% LOB level 3 imbalance index:\nlambda  = 0.5;  % Hyperparameter weights = exp(-(lambda)*[0 1 2]); VAsk = weights(1)*DTT.AskSize1 + weights(2)*DTT.AskSize2 + weights(3)*DTT.AskSize3; VBid = weights(1)*DTT.BidSize1 + weights(2)*DTT.BidSize2 + weights(3)*DTT.BidSize3; ImbalanceIndex = (VBid-VAsk)./(VBid+VAsk);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 97,
      "section_heading": "Because all the data is in the datastore, the workspace uses little memory.",
      "captions": ""
    }
  },
  {
    "text": "The imbalance index is a weighted average of ask and bid volumes on either side of the midprice [3]. The imbalance index is a potential indicator of future price movements. The variable  lambda  is a hyperparameter , which is a parameter specified before training rather than estimated by the machine learning algorithm. A hyperparameter can influence the performance of the model.  Feature engineering  is the process of choosing domain-specific hyperparameters to use in machine learning algorithms. You can tune hyperparameters to optimize a trading strategy.\nTo bring preprocessed expressions into memory and evaluate them, use the  gather  function. This process is called  deferred evaluation .\n[t,S,I] = gather(timeBase,MidPrice,ImbalanceIndex);\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 4.5 sec Evaluation completed in 5 sec\nA single call to  gather  evaluates multiple preprocessed expressions with a single pass through the datastore.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 97,
      "section_heading": "Because all the data is in the datastore, the workspace uses little memory.",
      "captions": ""
    }
  },
  {
    "text": "A single call to  gather  evaluates multiple preprocessed expressions with a single pass through the datastore.\nDetermine the sample size, which is the number of  ticks , or updates, in the data.\nnumTicks = length(t)\nMachine Learning for Statistical Arbitrage I: Data Management and Visualization\n2-53",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 97,
      "section_heading": "Because all the data is in the datastore, the workspace uses little memory.",
      "captions": ""
    }
  },
  {
    "text": "numTicks =  581030\nThe daily LOB data contains 581,030 ticks.\nCheckpoint Data\nYou can save both unevaluated and evaluated data to external storage for later use.\nPrepend the time base with the date, and cast the result as a datetime array. Save the resulting datetime array,  MidPrice , and  ImbalanceIndex  to a MAT-file in a specified location.\ndateTimeBase = datetime(date) + timeBase;  Today = timetable(dateTimeBase,MidPrice,ImbalanceIndex)\nToday =\n581,030×2 tall timetable\ndateTimeBase         MidPrice     ImbalanceIndex     ____________________    __________    ______________",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 98,
      "section_heading": "The daily LOB data contains 581,030 ticks.",
      "captions": ""
    }
  },
  {
    "text": "Today =\n581,030×2 tall timetable\ndateTimeBase         MidPrice     ImbalanceIndex     ____________________    __________    ______________\n21-Jun-2012 09:30:00    2.7515e+05         -0.205        21-Jun-2012 09:30:00    2.7515e+05       -0.26006        21-Jun-2012 09:30:00    2.7515e+05       -0.26006        21-Jun-2012 09:30:00    2.7515e+05      -0.086772        21-Jun-2012 09:30:00    2.7515e+05       -0.15581        21-Jun-2012 09:30:00    2.7515e+05       -0.35382        21-Jun-2012 09:30:00    2.7515e+05       -0.19084        21-Jun-2012 09:30:00    2.7515e+05       -0.19084                 :                  :               :              :                  :               :\nlocation = fullfile(pwd, \"ExchangeData\" ,ticker,date); write(location,Today, 'FileType' , 'mat' )",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 98,
      "section_heading": "The daily LOB data contains 581,030 ticks.",
      "captions": ""
    }
  },
  {
    "text": "location = fullfile(pwd, \"ExchangeData\" ,ticker,date); write(location,Today, 'FileType' , 'mat' )\nWriting tall data to folder C:\\TEMP\\tp5b508469\\finance-ex97702880\\ExchangeData\\INTC\\2012-06-21 Evaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 5.8 sec Evaluation completed in 6.7 sec\nThe file is written once, at the end of each trading day. The code saves the data to a file in a date- stamped folder. The series of  ExchangeData  subfolders serves as a historical data repository.\nAlternatively, you can save workspace variables evaluated with  gather  directly to a MAT-file in the current folder.\nsave( \"LOBVars.mat\" , \"t\" , \"S\" , \"I\" )\nIn preparation for model validation later on, evaluate and add market order prices to the same file.\n[MOBid,MOAsk] = gather(DTT.BidPrice1,DTT.AskPrice1);\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 4.1 sec Evaluation completed in 4.2 sec",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 98,
      "section_heading": "The daily LOB data contains 581,030 ticks.",
      "captions": ""
    }
  },
  {
    "text": "[MOBid,MOAsk] = gather(DTT.BidPrice1,DTT.AskPrice1);\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 4.1 sec Evaluation completed in 4.2 sec\nsave( \"LOBVars.mat\" , \"MOBid\" , \"MOAsk\" , \"-append\" )\n2 Performing Common Financial Tasks\n2-54",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 98,
      "section_heading": "The daily LOB data contains 581,030 ticks.",
      "captions": ""
    }
  },
  {
    "text": "The remainder of this example uses only the unevaluated tall timetable DTT. Clear other variables from the workspace.\nclearvars  -except   DTT   whos\nName            Size            Bytes  Class    Attributes\nDTT       581,030x12             5056  tall\nData Visualization\nTo visualize large amounts of data, you must summarize, bin, or sample the data in some way to reduce the number of points plotted on the screen.\nLOB Snapshot\nOne method of visualization is to evaluate only a selected subsample of the data. Create a snapshot of the LOB at a specific time of day (11 AM).\nsampleTimeTarget = seconds(11*60*60);                % Seconds after midnight sampleTimes = withtol(sampleTimeTarget,seconds(1));  % 1 second tolerance sampleLOB = DTT(sampleTimes,:);\nnumTimes = gather(size(sampleLOB,1))\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 4.1 sec Evaluation completed in 4.4 sec\nnumTimes =  23",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 99,
      "section_heading": "The remainder of this example uses only the unevaluated tall timetable DTT. Clear other variables",
      "captions": ""
    }
  },
  {
    "text": "numTimes = gather(size(sampleLOB,1))\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 4.1 sec Evaluation completed in 4.4 sec\nnumTimes =  23\nThere are 23 ticks within one second of 11 AM. For the snapshot, use the tick closest to the midtime.\nsampleLOB = sampleLOB(round(numTimes/2),:); sampleTime = sampleLOB.Time;\nsampleBidPrices = [sampleLOB.BidPrice1,sampleLOB.BidPrice2,sampleLOB.BidPrice3]; sampleBidSizes  = [sampleLOB.BidSize1,sampleLOB.BidSize2,sampleLOB.BidSize3]; sampleAskPrices = [sampleLOB.AskPrice1,sampleLOB.AskPrice2,sampleLOB.AskPrice3]; sampleAskSizes  = [sampleLOB.AskSize1,sampleLOB.AskSize2,sampleLOB.AskSize3];\n[sampleTime,sampleBidPrices,sampleBidSizes,sampleAskPrices,sampleAskSizes] =  ...     gather(sampleTime,sampleBidPrices,sampleBidSizes,sampleAskPrices,sampleAskSizes);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 99,
      "section_heading": "The remainder of this example uses only the unevaluated tall timetable DTT. Clear other variables",
      "captions": ""
    }
  },
  {
    "text": "[sampleTime,sampleBidPrices,sampleBidSizes,sampleAskPrices,sampleAskSizes] =  ...     gather(sampleTime,sampleBidPrices,sampleBidSizes,sampleAskPrices,sampleAskSizes);\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 2: Completed in 3.7 sec - Pass 2 of 2: Completed in 4 sec Evaluation completed in 8.6 sec\nVisualize the limited data sample returned by  gather  by using  bar .\nfigure hold  on\nbar((sampleBidPrices/10000),sampleBidSizes, 'r' ) bar((sampleAskPrices/10000),sampleAskSizes, 'g' ) hold  off\nMachine Learning for Statistical Arbitrage I: Data Management and Visualization\n2-55",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 99,
      "section_heading": "The remainder of this example uses only the unevaluated tall timetable DTT. Clear other variables",
      "captions": ""
    }
  },
  {
    "text": "xlabel( \"Price (Dollars)\" ) ylabel( \"Number of Shares\" ) legend([ \"Bid\" , \"Ask\" ], 'Location' , 'North' ) title(strcat( \"Level 3 Limit Order Book: \" ,datestr(sampleTime, \"HH:MM:SS\" )))\nDepth of Market\nSome visualization functions work directly with tall arrays and do not require the use of  gather   ( see “Visualization of Tall Arrays”). The functions automatically sample data to decrease pixel density. Visualize the level 3 intraday  depth of market , which shows the time evolution of liquidity, by using plot  with the tall timetable  DTT .\nfigure hold  on\nplot(DTT.Time,-DTT.BidSize1, 'Color' ,[1.0 0 0], 'LineWidth' ,2) plot(DTT.Time,-DTT.BidSize2, 'Color' ,[0.8 0 0], 'LineWidth' ,2) plot(DTT.Time,-DTT.BidSize3, 'Color' ,[0.6 0 0], 'LineWidth' ,2)\nplot(DTT.Time,DTT.AskSize1, 'Color' ,[0 1.0 0], 'LineWidth' ,2) plot(DTT.Time,DTT.AskSize2, 'Color' ,[0 0.8 0], 'LineWidth' ,2) plot(DTT.Time,DTT.AskSize3, 'Color' ,[0 0.6 0], 'LineWidth' ,2)\nhold  off",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 100,
      "section_heading": "Depth of Market",
      "captions": ""
    }
  },
  {
    "text": "hold  off\nxlabel( \"Time\" ) ylabel( \"Number of Shares\" ) title( \"Depth of Market: Intraday Evolution\" ) legend([ \"Bid1\" , \"Bid2\" , \"Bid3\" , \"Ask1\" , \"Ask2\" , \"Ask3\" ], 'Location' , 'NorthOutside' , 'Orientation' , 'Horiz\n2 Performing Common Financial Tasks\n2-56",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 100,
      "section_heading": "Depth of Market",
      "captions": ""
    }
  },
  {
    "text": "To display details, limit the time interval.\nxlim(seconds([45000 45060])) ylim([-35000 35000]) title( \"Depth of Market: One Minute\" )\nMachine Learning for Statistical Arbitrage I: Data Management and Visualization\n2-57",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 101,
      "section_heading": "To display details, limit the time interval.",
      "captions": ""
    }
  },
  {
    "text": "Summary\nThis example introduces the basics of working with big data, both in and out of memory. It shows how to set up, combine, and update external datastores, then create tall arrays for preprocessing data without allocating variables in the MATLAB workspace. The  gather  function transfers data into the workspace for computation and further analysis. The example shows how to visualize the data through data sampling or by MATLAB plotting functions that work directly with out-of-memory data.\nReferences\n[1] LOBSTER Limit Order Book Data. Berlin: frischedaten UG (haftungsbeschränkt).\n[2] NASDAQ Historical TotalView-ITCH Data. New York: The Nasdaq, Inc.\n[3] Rubisov, Anton D. \"Statistical Arbitrage Using Limit Order Book Imbalance.\" Master's thesis, University of Toronto, 2015.\nSee Also\nMore About\n• “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48\n• “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 102,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "See Also\nMore About\n• “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48\n• “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59\n• “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69\n2 Performing Common Financial Tasks\n2-58",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 102,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development\nThis example creates a continuous-time Markov model of limit order book (LOB) dynamics, and develops a strategy for algorithmic trading based on patterns observed in the data. It is part of a series of related examples on machine learning for statistical arbitrage (see “Machine Learning Applications”).\nExploratory Data Analysis\nTo predict the future behavior of a system, you need to discover patterns in historical data. The vast amount of data available from exchanges, such as NASDAQ, poses computational challenges while offering statistical opportunities. This example explores LOB data by looking for indicators of price momentum, following the approach in [4].\nRaw Data\nLoad  LOBVars.mat , the preprocessed LOB data set of the NASDAQ security INTC, which is included with the Financial Toolbox™ documentation.\nload  LOBVars",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 103,
      "section_heading": "Machine Learning for Statistical Arbitrage II: Feature",
      "captions": ""
    }
  },
  {
    "text": "Raw Data\nLoad  LOBVars.mat , the preprocessed LOB data set of the NASDAQ security INTC, which is included with the Financial Toolbox™ documentation.\nload  LOBVars\nThe data set contains the following information for each order: the arrival time  t  (seconds from midnight), level 1 asking price  MOAsk , level 1 bidding price  MOBid , midprice  S , and imbalance index I .\nCreate a plot that shows the intraday evolution of the LOB imbalance index  I  and midprice  S .\nfigure\nt.Format =  \"hh:mm:ss\" ;\nyyaxis  left plot(t,I) ylabel( \"Imbalance Index\" )\nyyaxis  right plot(t,S/10000, 'LineWidth' ,2) ylabel( \"Midprice (Dollars)\" )\nxlabel( \"Time\" )\ntitle( 'Exchange Data: One Day' ) legend([ \"Imbalance\" , \"Midprice\" ], 'Location' , 'NE' ) grid  on\nMachine Learning for Statistical Arbitrage II: Feature Engineering and Model Development\n2-59",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 103,
      "section_heading": "Machine Learning for Statistical Arbitrage II: Feature",
      "captions": ""
    }
  },
  {
    "text": "At this scale, the imbalance index gives no indication of future changes in the midprice.\nTo see more detail, limit the time scale to one minute.\ntimeRange = seconds([36000 36060]);  % One minute after 10 AM, when prices were climbing xlim(timeRange) legend( 'Location' , 'SE' ) title( \"Exchange Data: One Minute\" )\n2 Performing Common Financial Tasks\n2-60",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 104,
      "section_heading": "At this scale, the imbalance index gives no indication of future changes in the midprice.",
      "captions": ""
    }
  },
  {
    "text": "At this scale, sharp departures in the imbalance index align with corresponding departures in the midprice. If the relationship is predictive, meaning imbalances of a certain size forecast  future  price movements, then quantifying the relationship can provide statistical arbitrage opportunities.\nPlot a histogram of the interarrival times in the LOB.\nDT = diff(t);  % Interarrival Times DT.Format =  \"s\" ;\nfigure binEdges = seconds(0.01:0.01:1); histogram(DT,binEdges) xlabel( \"Seconds\" ) ylabel( \"Number of Orders\" ) title( \"LOB Interarrival Times\" )\nInterarrival times follow the characteristic pattern of a Poisson process.\nCompute the average wait time between orders by fitting an exponential distribution to the interarrival times.\nDTAvg = expfit(DT)\nDTAvg =  duration    0.040273 sec\nSmoothed Data",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 105,
      "section_heading": "At this scale, sharp departures in the imbalance index align with corresponding departures in the",
      "captions": ""
    }
  },
  {
    "text": "Compute the average wait time between orders by fitting an exponential distribution to the interarrival times.\nDTAvg = expfit(DT)\nDTAvg =  duration    0.040273 sec\nSmoothed Data\nThe raw imbalance series  I  is erratic. To identify the most significant dynamic shifts, introduce a degree of smoothing  dI , which is the number of backward ticks used to average the raw imbalance series.\nMachine Learning for Statistical Arbitrage II: Feature Engineering and Model Development\n2-61",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 105,
      "section_heading": "At this scale, sharp departures in the imbalance index align with corresponding departures in the",
      "captions": ""
    }
  },
  {
    "text": "dI = 10;  % Hyperparameter dTI = dI*DTAvg\ndTI =  duration    0.40273 sec\nThe setting corresponds to an interval of 10 ticks, or about 0.4 seconds on average. Smooth the imbalance indices over a trailing window.\nsI = smoothdata(I, 'movmean' ,[dI 0]);\nVisualize the degree of smoothing to assess the volatility lost or retained.\nfigure hold  on plot(t,I) plot(t,sI, 'c' , 'LineWidth' ,2) hold  off\nxlabel( \"Time\" ) xlim(timeRange) ylabel( \"Imbalance Index\" ) title( \"Imbalance Data: One Minute\" ) legend([ \"Raw\" , \"Smoothed\" ], 'Location' , 'SE' ) grid  on\nDiscretized Data\nTo create a Markov model of the dynamics, collect the smoothed imbalance index  sI  into bins, discretizing it into a finite collection of states  rho  ( ρ ). The number of bins  numBins  is a hyperparameter.\n2 Performing Common Financial Tasks\n2-62",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 106,
      "section_heading": "The setting corresponds to an interval of 10 ticks, or about 0.4 seconds on average. Smooth the",
      "captions": ""
    }
  },
  {
    "text": "numBins = 3;  % Hyperparameter binEdges = linspace(-1,1,numBins+1); rho = discretize(sI,binEdges);\nTo model forecast performance, aggregate prices over a leading window. The number of ticks in a window  dS  is a hyperparameter.\ndS = 20;  % Hyperparameter dTS = dS*DTAvg\ndTS =  duration    0.80547 sec\nThe setting corresponds to an interval of 20 ticks, or about 0.8 seconds on average. Discretize price movements into three states  DS  ( ΔS ) given by the sign of the forward price change.\nDS = NaN(size(S)); shiftS = S(dS+1:end); DS(1:end-dS) = sign(shiftS-S(1:end-dS));\nVisualize the discretized data.\nfigure\nsubplot(3,1,1) hold  on plot(t,sI, 'c' , 'LineWidth' ,2) for  i = 2:numBins     yline(binEdges(i), 'b--' ); end hold  off xlim(timeRange) ylim([-1 1]) yticks(binEdges) title( \"Imbalance Index (Smoothed)\" ) grid  on\nsubplot(3,1,2) plot(t,rho, 'co' , 'MarkerSize' ,3) xlim(timeRange) ylim([1 numBins]) yticks(1:numBins) ylabel( \"\\rho\" ) title( \"Imbalance Index (Discretized)\" ) grid  on",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 107,
      "section_heading": "To model forecast performance, aggregate prices over a leading window. The number of ticks in a",
      "captions": ""
    }
  },
  {
    "text": "subplot(3,1,2) plot(t,rho, 'co' , 'MarkerSize' ,3) xlim(timeRange) ylim([1 numBins]) yticks(1:numBins) ylabel( \"\\rho\" ) title( \"Imbalance Index (Discretized)\" ) grid  on\nsubplot(3,1,3) plot(t,DS, 'ro' , 'MarkerSize' ,3) xlim(timeRange) ylim([-1 1]) yticks([-1 0 1]) ylabel( \"\\DeltaS\" ) title( \"Price Movement\" ) grid  on\nMachine Learning for Statistical Arbitrage II: Feature Engineering and Model Development\n2-63",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 107,
      "section_heading": "To model forecast performance, aggregate prices over a leading window. The number of ticks in a",
      "captions": ""
    }
  },
  {
    "text": "Continuous Time Markov Process\nTogether, the state of the LOB imbalance index  rho  ( ρ ) and the state of the forward price movement DS  ( ΔS ) describe a two-dimensional continuous-time Markov chain (CTMC). The chain is modulated by the Poisson process of order arrivals, which signals any transition among the states.\nTo simplify the description, give the two-dimensional CTMC a one-dimensional encoding into states phi  ( φ  =  ρ ,  ΔS  ).\nnumStates = 3*numBins;  % numStates(DS)*numStates(rho)\nphi = NaN(size(t)); for  i = 1:length(t)      switch  DS(i)          case  -1             phi(i) = rho(i);          case  0             phi(i) = rho(i) + numBins;          case  1             phi(i) = rho(i) + 2*numBins;      end end\nSuccessive states of  φ , and the component states  ρ  and  ΔS , proceed as follows.\n2 Performing Common Financial Tasks\n2-64",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 108,
      "section_heading": "Continuous Time Markov Process",
      "captions": ""
    }
  },
  {
    "text": "Hyperparameters  dI  ( Δt I ) and  dS  ( Δt S ) determine the size of a rolling state characterizing the\ndynamics. At time  t , the process transitions from  φ  =  ρ previous ,  ΔS current  =  i  to\nφ  =  ρ current ,  ΔS future  =  j  (or holds in the same state if  i  =  j ).\nEstimate Process Parameters\nExecution of the trading strategy at any time  t  is based on the probability of  ΔS future  being in a particular state, conditional on the current and previous values of the other states. Following [3] and [4], determine empirical transition probabilities, and then assess them for predictive power.\n% Transition counts\nC = zeros(numStates); for  i = 1:length(phi)-dS-1       C(phi(i),phi(i+1)) = C(phi(i),phi(i+1))+1; end\n% Holding times\nH = diag(C);\n% Transition rate matrix (infinitesimal generator)\nG = C./H; v = sum(G,2); G = G + diag(-v);\n% Transition probability matrix (stochastic for all dI)\nP = expm(G*dI);  % Matrix exponential",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 109,
      "section_heading": "Hyperparameters",
      "captions": ""
    }
  },
  {
    "text": "H = diag(C);\n% Transition rate matrix (infinitesimal generator)\nG = C./H; v = sum(G,2); G = G + diag(-v);\n% Transition probability matrix (stochastic for all dI)\nP = expm(G*dI);  % Matrix exponential\nTo obtain a trading matrix  Q  containing Prob  ΔS future  ρ previous ,  ρ current ,  ΔS current   as in [4], apply Bayes’ rule,\nMachine Learning for Statistical Arbitrage II: Feature Engineering and Model Development\n2-65",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 109,
      "section_heading": "Hyperparameters",
      "captions": ""
    }
  },
  {
    "text": "Prob  ΔS future  ρ previous ,  ρ current ,  ΔS current  =\nProb  ρcurrent ,  ΔSfuture ρprevious ,  ΔScurrent\nProb  ρcurrent ρprevious ,  ΔScurrent\n.\nThe numerator is the transition probability matrix  P . Compute the denominator  PCond.\nPCond = zeros(size(P)); phiNums = 1:numStates; modNums = mod(phiNums,numBins); for  i = phiNums      for  j = phiNums         idx = (modNums == modNums(j));         PCond(i,j) = sum(P(i,idx));              end      end\nQ = P./PCond;\nDisplay  Q  in a table. Label the rows and columns with composite states  φ  =  ρ ,  ΔS  .\nbinNames = string(1:numBins); stateNames = [ \"(\" +binNames+ \",-1)\" , \"(\" +binNames+ \",0)\" , \"(\" +binNames+ \",1)\" ]; QTable = array2table(Q, 'RowNames' ,stateNames, 'VariableNames' ,stateNames)\nQTable= 9×9 table                (1,-1)      (2,-1)       (3,-1)       (1,0)      (2,0)      (3,0)       (1,1)                    ________    _________    _________    _______    _______    _______    _________",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 110,
      "section_heading": "Prob",
      "captions": "binNames = string(1:numBins); stateNames = [ \"(\" +binNames+ \",-1)\" , \"(\" +binNames+ \",0)\" , \"(\" +binNames+ \",1)\" ]; QTable = array2table(Q, 'RowNames' ,stateNames, 'VariableNames' ,stateNames), QTable= 9×9 table                (1,-1)      (2,-1)       (3,-1)       (1,0)      (2,0)      (3,0)       (1,1)                    ________    _________    _________    _______    _______    _______    _________"
    }
  },
  {
    "text": "(1,-1)     0.59952      0.30458      0.19165    0.39343    0.67723     0.7099    0.0070457        (2,-1)     0.74092      0.58445      0.40023    0.25506    0.41003    0.56386    0.0040178        (3,-1)     0.79895      0.60866      0.55443    0.19814      0.385    0.42501    0.0029096        (1,0)     0.094173     0.036014     0.019107    0.88963    0.91688    0.75192     0.016195        (2,0)      0.12325     0.017282     0.015453    0.86523    0.96939     0.9059     0.011525        (3,0)       0.1773      0.02616     0.018494    0.81155    0.95359    0.92513     0.011154        (1,1)     0.041132    0.0065127    0.0021313    0.59869    0.39374    0.21787      0.36017        (2,1)     0.059151    0.0053554    0.0027769    0.65672    0.42325    0.26478      0.28413        (3,1)     0.095832     0.010519    0.0051565     0.7768     0.6944     0.3906      0.12736",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 110,
      "section_heading": "Prob",
      "captions": "binNames = string(1:numBins); stateNames = [ \"(\" +binNames+ \",-1)\" , \"(\" +binNames+ \",0)\" , \"(\" +binNames+ \",1)\" ]; QTable = array2table(Q, 'RowNames' ,stateNames, 'VariableNames' ,stateNames), QTable= 9×9 table                (1,-1)      (2,-1)       (3,-1)       (1,0)      (2,0)      (3,0)       (1,1)                    ________    _________    _________    _______    _______    _______    _________"
    }
  },
  {
    "text": "Rows are indexed by ( ρ previous ,  ΔS current ). Conditional probabilities for each of the three possible states of  ΔS future  are read from the corresponding column, conditional on  ρ current .\nRepresent  Q  with a heatmap.\nfigure imagesc(Q) axis  equal   tight hCB = colorbar; hCB.Label.String =  \"Prob(\\DeltaS_{future} | \\rho_{previous},\\rho_{current},\\DeltaS_{current})\" ; xticks(phiNums) xticklabels(stateNames) xlabel( \"(\\rho_{current},\\DeltaS_{future})\" ) yticks(phiNums) yticklabels(stateNames) ylabel( \"(\\rho_{previous},\\DeltaS_{current})\" ) title( \"Trading Matrix\" )\n2 Performing Common Financial Tasks\n2-66",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 110,
      "section_heading": "Prob",
      "captions": "binNames = string(1:numBins); stateNames = [ \"(\" +binNames+ \",-1)\" , \"(\" +binNames+ \",0)\" , \"(\" +binNames+ \",1)\" ]; QTable = array2table(Q, 'RowNames' ,stateNames, 'VariableNames' ,stateNames), QTable= 9×9 table                (1,-1)      (2,-1)       (3,-1)       (1,0)      (2,0)      (3,0)       (1,1)                    ________    _________    _________    _______    _______    _______    _________"
    }
  },
  {
    "text": "The bright, central 3 x 3 square shows that in most transitions, tick to tick, no price change is expected ( ΔS future  = 0). Bright areas in the upper-left 3 x 3 square (downward price movements ΔS future  = −1) and lower-right 3 x 3 square (upward price movements  ΔS future  = + 1) show evidence of momentum, which can be leveraged in a trading strategy.\nYou can find arbitrage opportunities by thresholding  Q  above a specified trigger probability. For example:\ntrigger = 0.5; QPattern = (Q > trigger)\nQPattern =  9×9 logical array\n1   0   0   0   1   1   0   0   0    1   1   0   0   0   1   0   0   0    1   1   1   0   0   0   0   0   0    0   0   0   1   1   1   0   0   0    0   0   0   1   1   1   0   0   0    0   0   0   1   1   1   0   0   0    0   0   0   1   0   0   0   1   1    0   0   0   1   0   0   0   1   1    0   0   0   1   1   0   0   0   1",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 111,
      "section_heading": "The bright, central 3 x 3 square shows that in most transitions, tick to tick, no price change is",
      "captions": ""
    }
  },
  {
    "text": "The entry in the (1,1) position shows a chance of more than 50% that a downward price movement ( ΔS current  = −1) will be followed by another downward price movement ( ΔS future  = −1), provided that the previous and current imbalance states  ρ  are both 1.\nA Trading Strategy?\nQ  is constructed on the basis of both the available exchange data and the hyperparameter settings. Using  Q  to inform future trading decisions depends on the market continuing in the same statistical\nMachine Learning for Statistical Arbitrage II: Feature Engineering and Model Development\n2-67",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 111,
      "section_heading": "The bright, central 3 x 3 square shows that in most transitions, tick to tick, no price change is",
      "captions": ""
    }
  },
  {
    "text": "pattern. Whether the market exhibits momentum in certain states is a test of the weak-form  Efficient Market Hypothesis  (EMH). For heavily traded assets, such as the one used in this example (INTC), the EMH is likely to hold over extended periods, and arbitrage opportunities quickly disappear. However, failure of EMH can occur in some assets over short time intervals. A working trading strategy divides a portion of the trading day, short enough to exhibit a degree of statistical equilibrium, into a training period for estimating  Q , using optimal hyperparameter settings and a validation period on which to trade. For an implementation of such a strategy, see “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69.\nSummary",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 112,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "Summary\nThis example begins with raw data on the LOB and transforms it into a summary (the  Q  matrix) of statistical arbitrage opportunities. The analysis uses the mathematics of continuous-time Markov chain models, first in recognizing the Poisson process of LOB interarrival times, then by discretizing data into two-dimensional states representing the instantaneous position of the market. A description of state transitions, derived empirically, leads to the possibility of an algorithmic trading strategy.\nReferences\n[1] Cartea, Álvaro, Sebastian Jaimungal, and Jason Ricci. \"Buy Low, Sell High: A High-Frequency Trading Perspective.\"  SIAM Journal on Financial Mathematics  5, no. 1 (January 2014): 415– 44. https://doi.org/10.1137/130911196.\n[2] Guilbaud, Fabien, and Huyen Pham. \"Optimal High-Frequency Trading with Limit and Market Orders.\"  Quantitative Finance  13, no. 1 (January 2013): 79–94. https://doi.org/ 10.1080/14697688.2012.708779.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 112,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "[3] Norris, J. R.  Markov Chains . Cambridge, UK: Cambridge University Press, 1997.\n[4] Rubisov, Anton D. \"Statistical Arbitrage Using Limit Order Book Imbalance.\" Master's thesis, University of Toronto, 2015.\nSee Also\nMore About\n• “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48\n• “Machine Learning for Statistical Arbitrage I: Data Management and Visualization” on page 2- 50\n• “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69\n2 Performing Common Financial Tasks\n2-68",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 112,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction\nThis example uses Bayesian optimization to tune hyperparameters in the algorithmic trading model, supervised by the end-of-day return. It is part of a series of related examples on machine learning for statistical arbitrage (see “Machine Learning Applications”).\nLoad  LOBVars.mat , the preprocessed LOB data set of the NASDAQ security INTC, which is included with the Financial Toolbox™ documentation.\nload  LOBVars\nThe data set contains the following information for each order: the arrival time  t  (seconds from midnight), level 1 asking price  MOAsk , level 1 bidding price  MOBid , midprice  S , and imbalance index I .\nThis example includes several supporting functions. To view them, open the example, and then expand the  LOBSupportingFiles  folder in the  Current Folder  pane.\nAccess the files by adding them to the search path.\naddpath( \"LOBSupportingFiles\" )\nTrading Strategy",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 113,
      "section_heading": "Machine Learning for Statistical Arbitrage III: Training, Tuning,",
      "captions": ""
    }
  },
  {
    "text": "Access the files by adding them to the search path.\naddpath( \"LOBSupportingFiles\" )\nTrading Strategy\nThe trading matrix  Q  contains probabilities of future price movements, given current and previous states  rho  of the limit order book (LOB) imbalance index  I  and the latest observed direction in prices DS .\nView the supporting function  tradeOnQ.m , which implements a simple trading strategy based on the pattern in  Q .\nfunction  cash = tradeOnQ(Data,Q,n,N)\n% Reference: Machine Learning for Statistical Arbitrage %            Part II: Feature Engineering and Model Development     % Data\nt = Data.t; MOBid = Data.MOBid;\nMachine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction\n2-69",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 113,
      "section_heading": "Machine Learning for Statistical Arbitrage III: Training, Tuning,",
      "captions": ""
    }
  },
  {
    "text": "MOAsk = Data.MOAsk;\n% States\n[rho,DS] = getStates(Data,n,N);\n% Start of trading\ncash = 0; assets = 0;\n% Active trading\nT = length(t);\nfor  tt = 2:T-N   % Trading ticks\n% Get Q row, column indices of current state          row = rho(tt-1)+n*(DS(tt-1)+1);     downColumn = rho(tt);     upColumn = rho(tt) + 2*n;\n% If predicting downward price move           if  Q(row,downColumn) > 0.5\ncash = cash + MOBid(tt);  % Sell         assets = assets - 1;                   % If predicting upward price move\nelseif  Q(row,upColumn) > 0.5\ncash = cash - MOAsk(tt);  % Buy         assets = assets + 1;\nend\nend\n% End of trading (liquidate position)\nif  assets > 0\ncash = cash + assets*MOBid(T);  % Sell off\nelseif  assets < 0\ncash = cash + assets*MOAsk(T);  % Buy back\nend\nThe algorithm uses predictions from  Q  to make decisions about trading at each tick. It illustrates the general mechanism of any optimized machine learning algorithm.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 114,
      "section_heading": "The algorithm uses predictions from",
      "captions": ""
    }
  },
  {
    "text": "end\nThe algorithm uses predictions from  Q  to make decisions about trading at each tick. It illustrates the general mechanism of any optimized machine learning algorithm.\nThis strategy seeks to profit from expected price changes using market orders (best offer at the touch) of a single share at each tick, if an arbitrage opportunity arises. The strategy can be scaled up\n2 Performing Common Financial Tasks\n2-70",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 114,
      "section_heading": "The algorithm uses predictions from",
      "captions": ""
    }
  },
  {
    "text": "to larger trading volumes. Using the conditional probabilities obtained from  Q , the  tradeOnQ function takes one of these actions:\n• Executes a buy if the probability of an upward forward price change is greater than 0.5.\n• Executes a sell if the probability of a downward forward price change is greater than 0.5.\nAt the end of the trading day, the function liquidates the position at the touch.\nThe strategy requires  Data  with tick times  t  and the corresponding market order bid and ask prices MOBid  and  MOAsk , respectively. In real-time trading, data is provided by the exchange. This example evaluates the strategy by dividing the historical sample into  training  (calibration) and  validation subsamples. The validation subsample serves as a proxy for real-time trading data. The strategy depends on  Q , the trading matrix itself, which you estimate after you make a number of hyperparameter choices. The inputs  n  and  N  are hyperparameters to tune when you optimize the strategy.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 115,
      "section_heading": "to larger trading volumes. Using the conditional probabilities obtained from",
      "captions": ""
    }
  },
  {
    "text": "Hyperparameters\nThe continuous-time Markov model and the resulting trading matrix  Q  depend on the values of four hyperparameters:\n• lambda  — The weighting parameter used to compute the imbalance index  I\n• dI  — The number of backward ticks used to average  I  during smoothing\n• numBins  — The number of bins used to partition smoothed  I  for discretization\n• dS  — The number of forward ticks used to convert the prices  S  to discrete  DS\nIn general, all four hyperparameters are tunable. However, to facilitate visualization, the example reduces the number of dimensions by tuning only  numBins  and  N . The example:\n• Fixes  lambda\n• Leaves  numBins  =  n , where  n  is free to vary\n• Equalizes the window lengths  dI  =  dS  =  N , where  N  is free to vary\nThe restrictions do not significantly affect optimization outcomes. The optimization algorithm searches over the two-dimensional parameter space ( n , N ) for the configuration yielding the maximum return on trading.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 115,
      "section_heading": "to larger trading volumes. Using the conditional probabilities obtained from",
      "captions": ""
    }
  },
  {
    "text": "Training and Validation Data\nMachine learning requires a subsample on which to estimate  Q  and another subsample on which to evaluate the hyperparameter selections.\nSpecify a breakpoint to separate the data into training and validation subsamples. The breakpoint affects evaluation of the objective function, and is essentially another hyperparameter. However, because you do not tune the breakpoint, it is external to the optimization process.\nbp = round((0.80)*length(t));  % Use 80% of data for training\nCollect data in a timetable to pass to  tradeOnQ .\nData = timetable(t,S,I,MOBid,MOAsk); TData = Data(1:bp,:);        % Training data VData = Data(bp+1:end,:);    % Validation data\nMachine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction\n2-71",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 115,
      "section_heading": "to larger trading volumes. Using the conditional probabilities obtained from",
      "captions": ""
    }
  },
  {
    "text": "Cross-Validation\nCross-validation  describes a variety of techniques to assess how training results (here, computation of Q ) generalize, with predictive reliability, to independent validation data (here, profitable trading). The goal of cross-validation is to flag problems in training results, like bias and overfitting. In the context of the trading strategy, overfitting refers to the time dependence, or nonstationarity, of  Q . As  Q changes over time, it becomes less effective in predicting future price movements. The key diagnostic issue is the degree to which  Q  changes, and at what rate, over a limited trading horizon.\nWith training and validation data in place, specify the hyperparameters and compare  Q  in the two subsamples. The supporting function  makeQ.m  provides the steps for making  Q .\n% Set specific hyperparameters\nn = 3;   % Number of bins for I N = 20;  % Window lengths\n% Compare Qs\nQT = makeQ(TData,n,N); QV = makeQ(VData,n,N); QTVDiff = QT - QV\nQTVDiff =  9×9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 116,
      "section_heading": "Cross-Validation",
      "captions": ""
    }
  },
  {
    "text": "% Set specific hyperparameters\nn = 3;   % Number of bins for I N = 20;  % Window lengths\n% Compare Qs\nQT = makeQ(TData,n,N); QV = makeQ(VData,n,N); QTVDiff = QT - QV\nQTVDiff =  9×9\n0.0070    0.0182    0.1198   -0.0103   -0.0175   -0.0348    0.0034   -0.0007   -0.0851    -0.0009    0.0176    0.2535   -0.0010   -0.0233   -0.2430    0.0019    0.0058   -0.0106     0.0184    0.0948    0.0835   -0.0195   -0.1021   -0.1004    0.0011    0.0073    0.0168     0.0462    0.0180    0.0254   -0.0512   -0.0172    0.0417    0.0050   -0.0009   -0.0671     0.0543    0.0089    0.0219   -0.0556   -0.0169   -0.0331    0.0013    0.0080    0.0112     0.1037    0.0221    0.0184   -0.1043   -0.0401   -0.0479    0.0006    0.0180    0.0295     0.0266    0.0066    0.0054   -0.0821   -0.0143   -0.0116    0.0555    0.0077    0.0062     0.0615    0.0050    0.0060   -0.0189   -0.0207   -0.0262   -0.0426    0.0157    0.0203     0.0735    0.0103    0.0090   -0.0788   -0.1216   -0.0453    0.0053    0.1113    0.0362",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 116,
      "section_heading": "Cross-Validation",
      "captions": ""
    }
  },
  {
    "text": "Differences between  QT  and  QV  appear minor, although they vary based on their position in the matrix. Identify trading inefficiencies, which result from indices (market states) where one matrix gives a trading cue (probability value > 0.5) and the other does not.\nInhomogeneity = (QT > 0.5 & QV < 0.5 ) | (QT < 0.5 & QV > 0.5 )\nInhomogeneity =  9×9 logical array\n0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0\nNo significant inhomogeneities appear in the data with the given hyperparameter settings.\n2 Performing Common Financial Tasks\n2-72",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 116,
      "section_heading": "Cross-Validation",
      "captions": ""
    }
  },
  {
    "text": "The severity of proceeding with a homogeneity assumption is not known  a priori , and can emerge only from more comprehensive backtesting. Statistical tests are available, as described in [4] and [5], for example. During real-time trading, a rolling computation of  Q  over trailing training data of suitable size can provide the most reliable cues. Such an approach acknowledges inherent nonstationarity in the market.\nMachine Learning\nMachine learning  refers to the general approach of effectively performing a task (for example, trading) in an automated fashion by detecting patterns (for example, computing  Q ) and making inferences based on available data. Often, data is dynamic and big enough to require specialized computational techniques. The evaluation process—tuning hyperparameters to describe the data and direct performance of the task—is ongoing.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 117,
      "section_heading": "The severity of proceeding with a homogeneity assumption is not known",
      "captions": ""
    }
  },
  {
    "text": "In addition to the challenges of working with big data, the process of evaluating complex, sometimes black-box, objective functions is also challenging. Objective functions supervise hyperparameter evaluation. The trading strategy evaluates hyperparameter tunings by first computing  Q  on a training subsample, and then trading during an evaluation (real-time) subsample. The objective is to maximize profit, or minimize negative cash returned, over a space of suitably constrained configurations ( n , N ). This objective is a prototypical \"expensive\" objective function.  Bayesian optimization  is a type of machine learning suited to such objective functions. One of its principal advantages is the absence of costly derivative evaluations. To implement Bayesian optimization, use the Statistics and Machine Learning Toolbox™ function  bayesopt .\nThe supporting function  optimizeTrading.m  uses  bayesopt  to optimize the trading strategy in tradeOnQ .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 117,
      "section_heading": "The severity of proceeding with a homogeneity assumption is not known",
      "captions": ""
    }
  },
  {
    "text": "The supporting function  optimizeTrading.m  uses  bayesopt  to optimize the trading strategy in tradeOnQ .\nfunction  results = optimizeTrading(TData,VData)\n% Optimization variables\nn = optimizableVariable( 'numBins' ,[1 10], 'Type' , 'integer' ); N = optimizableVariable( 'numTicks' ,[1 50], 'Type' , 'integer' );\n% Objective function handle\nf = @(x)negativeCash(x,TData,VData);\n% Optimize\nresults = bayesopt(f,[n,N], ...                     'IsObjectiveDeterministic' ,true, ...                     'AcquisitionFunctionName' , 'expected-improvement-plus' , ...                     'MaxObjectiveEvaluations' ,25, ...                     'ExplorationRatio' ,2, ...                     'Verbose' ,0);\nend   % optimizeTrading\n% Objective (local) function  loss = negativeCash(x,TData,VData)\nn = x.numBins; N = x.numTicks;\n% Make trading matrix Q\nMachine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction\n2-73",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 117,
      "section_heading": "The severity of proceeding with a homogeneity assumption is not known",
      "captions": ""
    }
  },
  {
    "text": "Q = makeQ(TData,n,N);\n% Trade on Q\ncash = tradeOnQ(VData,Q,n,N);\n% Objective value\nloss = -cash;\nend   % negativeCash\nOptimize the trading strategy by passing the training and validation data to  optimizeTrading .\nrng(0)  % For reproducibility results = optimizeTrading(TData,VData);\n2 Performing Common Financial Tasks\n2-74",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 118,
      "section_heading": "Optimize the trading strategy by passing the training and validation data to",
      "captions": ""
    }
  },
  {
    "text": "The estimated minimum objective coincides with the minimum observed objective (the search is monotonic). Unlike derivative-based algorithms,  bayesopt  does not converge. As it tries to find the global minimum,  bayesopt  continues exploring until it reaches the specified number of iterations ( 25 ).\nObtain the best configuration by passing the  results  to  bestPoint .\n[Calibration,negReturn] = bestPoint(results, 'Criterion' , 'min-observed' )\nCalibration= 1×2 table     numBins    numTicks     _______    ________\n3          24\nnegReturn =  -7100\nTrading one share per tick, as directed by  Q , the optimal strategy using ( n , N ) = (3,24) returns $0.71 over the final 20% of the trading day. Modifying the trading volume scales the return.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 119,
      "section_heading": "The estimated minimum objective coincides with the minimum observed objective (the search is",
      "captions": ""
    }
  },
  {
    "text": "Trading one share per tick, as directed by  Q , the optimal strategy using ( n , N ) = (3,24) returns $0.71 over the final 20% of the trading day. Modifying the trading volume scales the return.\nAnother optimizer designed for expensive objectives is  surrogateopt  (Global Optimization Toolbox). It uses a different search strategy and can locate optima more quickly, depending on the objective. The supporting function  optimizeTrading2.m  uses  surrogateopt  instead of  bayesopt  to optimize the trading strategy in  tradeOnQ .\nrng(0)  % For reproducibility results2 = optimizeTrading2(TData,VData)\nMachine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction\n2-75",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 119,
      "section_heading": "The estimated minimum objective coincides with the minimum observed objective (the search is",
      "captions": ""
    }
  },
  {
    "text": "results2 =  1×2\n3    25\nThe results obtained with  surrogateopt  are the same as the  bayesopt  results. The plot contains information about the progress of the search that is specific to the  surrogateopt  algorithm.\nCompute  Q  by passing the optimal hyperparameters and the entire data set to  makeQ .\nbestQ = makeQ(Data,3,24)\nbestQ =  9×9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 120,
      "section_heading": "The results obtained with",
      "captions": ""
    }
  },
  {
    "text": "Compute  Q  by passing the optimal hyperparameters and the entire data set to  makeQ .\nbestQ = makeQ(Data,3,24)\nbestQ =  9×9\n0.3933    0.1868    0.1268    0.5887    0.7722    0.6665    0.0180    0.0410    0.2068     0.5430    0.3490    0.2716    0.4447    0.6379    0.6518    0.0123    0.0131    0.0766     0.6197    0.3897    0.3090    0.3705    0.5954    0.6363    0.0098    0.0150    0.0547     0.1509    0.0440    0.0261    0.8217    0.8960    0.6908    0.0273    0.0601    0.2831     0.1900    0.0328    0.0280    0.7862    0.9415    0.8316    0.0238    0.0257    0.1404     0.2370    0.0441    0.0329    0.7391    0.9221    0.8745    0.0239    0.0338    0.0925     0.1306    0.0234    0.0101    0.7861    0.6566    0.4168    0.0833    0.3200    0.5731     0.1276    0.0169    0.0118    0.7242    0.6505    0.4712    0.1482    0.3326    0.5171     0.1766    0.0282    0.0186    0.7216    0.7696    0.6185    0.1018    0.2023    0.3629",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 120,
      "section_heading": "The results obtained with",
      "captions": ""
    }
  },
  {
    "text": "The trading matrix  bestQ  can be used as a starting point for the next trading day.\nSummary\nThis example implements the optimized trading strategy developed in the first two related examples. Available data is split into training and validation subsamples and used, respectively, to compute the trading matrix  Q  and execute the resulting trading algorithm. The process is repeated over a space of hyperparameter settings using the global optimizers  bayesopt  and  surrogateopt , both of which\n2 Performing Common Financial Tasks\n2-76",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 120,
      "section_heading": "The results obtained with",
      "captions": ""
    }
  },
  {
    "text": "identify an optimal strategy yielding a positive return. The approach has many options for further customization.\nReferences\n[1] Bull, Adam D. \"Convergence Rates of Efficient Global Optimization Algorithms.\"  Journal of Machine Learning Research  12, (November 2011): 2879–904.\n[2] Rubisov, Anton D. \"Statistical Arbitrage Using Limit Order Book Imbalance.\" Master's thesis, University of Toronto, 2015.\n[3] Snoek, Jasper, Hugo Larochelle, and Ryan P. Adams. \"Practical Bayesian Optimization of Machine Learning Algorithms.\" In  Advances in Neural Information Processing Systems 25 , F. Pereira et. al. editors, 2012.\n[4] Tan, Barış, and Kamil Yılmaz. “Markov Chain Test for Time Dependence and Homogeneity: An Analytical and Empirical Evaluation.”  European Journal of Operational Research  137, no. 3 (March 2002): 524–43. https://doi.org/10.1016/S0377-2217(01)00081-9.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 121,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "[5] Weißbach, Rafael, and Ronja Walter. “A Likelihood Ratio Test for Stationarity of Rating Transitions.”  Journal of Econometrics  155, no. 2 (April 2010): 188–94.https://doi.org/10.1016/ j.jeconom.2009.10.016.\nSee Also\nMore About\n• “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48\n• “Machine Learning for Statistical Arbitrage I: Data Management and Visualization” on page 2- 50\n• “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59\n• “Backtest Deep Learning Model for Algorithmic Trading of Limit Order Book Data” on page 2- 78\n• “Deep Reinforcement Learning for Optimal Trade Execution” on page 4-407\nMachine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction\n2-77",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 121,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "Backtest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\nThis example applies artificial intelligence (AI) techniques and backtesting to find trading opportunities from imbalances in limit order book (LOB) data of a security. Specifically, the example applies a backtest trading strategy to measure the performance of a long short-term memory (LSTM) neural network. The goal of the model is to predict future forward price movements from current and past on ask and bid volume imbalances and forward price movements, which are extracted from the raw LOB data. Given a forward price movement prediction, a trading decision can be made. This example uses the following trading strategy and assumptions:\n• Trading strategy: \"All-in/all-out\"; all cash is invested when the model predicts positive price movements and cash out when the model predicts no or negative cash movements.\n• Transactions are free.\n• Current trading actions do not affect future price movements.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 122,
      "section_heading": "Backtest Deep Learning Model for Algorithmic Trading of Limit",
      "captions": ""
    }
  },
  {
    "text": "• Transactions are free.\n• Current trading actions do not affect future price movements.\n• The risk-free rate is 0%.\nThis example builds on the developments in the “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48 example series and uses this procedure:\n1 Load and preprocess the raw limit order book data.\n2 Engineer features by transforming the raw LOB data to obtain the discretized imbalance index series  ρ t  and forward price movement series  ΔS t . The response is the discretized future price movement  ΔS t  +  ΔtS .\n3 Prepare the data for the classification LSTM neural network.\n4 Partition the data into training, validation, and backtest sets.\n5 Configure the LSTM neural network.\n6 Train and validate the LSTM neural network.\n7 Asses the quality of the trained model.\n8 Backtest the trained LSTM neural network. Compare the performance of the model with a model that has knowledge of all future price movements (maximum profit model).",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 122,
      "section_heading": "Backtest Deep Learning Model for Algorithmic Trading of Limit",
      "captions": ""
    }
  },
  {
    "text": "8 Backtest the trained LSTM neural network. Compare the performance of the model with a model that has knowledge of all future price movements (maximum profit model).\nLoad and Preprocess Raw LOB Data\nThis example uses the level 3 limit order book data from one trading day of NASDAQ exchange data [3] on one security (INTC) in a sample provided by LOBSTER [2] and included with the Financial Toolbox™ documentation in the zip file  LOBSTER_SampleFile_INTC_2012-06-21_5.zip .\nExtract the contents of the zip file into your current folder.\nunzip( \"LOBSTER_SampleFile_INTC_2012-06-21_5.zip\" ); MSGFileName =  \"INTC_2012-06-21_34200000_57600000_message_5.csv\" ;    LOBFileName =  \"INTC_2012-06-21_34200000_57600000_orderbook_5.csv\" ;\nThe “Machine Learning for Statistical Arbitrage I: Data Management and Visualization” on page 2-50 example describes LOB data. To summarize:\n• LOB data is composed of two CSV files: the order book  LOBFileName  and a message file MSGFileName .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 122,
      "section_heading": "Backtest Deep Learning Model for Algorithmic Trading of Limit",
      "captions": ""
    }
  },
  {
    "text": "• LOB data is composed of two CSV files: the order book  LOBFileName  and a message file MSGFileName .\n2 Performing Common Financial Tasks\n2-78",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 122,
      "section_heading": "Backtest Deep Learning Model for Algorithmic Trading of Limit",
      "captions": ""
    }
  },
  {
    "text": "• The order book data describes the intraday evolution of the limit order book of the security, which includes market and limit orders, resulting buys and sells, and corresponding times of all events.\n• The message file describes each event.\n• Many order events can occur during a trading day, therefore such data sets are typically large and difficult or impossible to fit in memory. This example uses a  tabularTextDatastore  and tall timetables to store and operate on the sets.\nExtract the trading date from the message file name.\n[ticker,rem] = strtok(MSGFileName, \"_\" ); date = strtok(rem, \"_\" );\nCreate separate datastores for the message and data files by using  tabularTextDatastore . Ignore the generic column headers by setting  ReadVariableNames=false . To allow similarly formatted files to be appended to existing datastores at the end of each trading day  ReadSize=\"file\" . Set descriptive variables names to each datastore.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 123,
      "section_heading": "The order book data describes the intraday evolution of the limit order book of the security, which",
      "captions": ""
    }
  },
  {
    "text": "DSMSG = tabularTextDatastore(MSGFileName,ReadVariableNames=false,ReadSize= \"file\" ); DSMSG.VariableNames = [ \"Time\" , \"Type\" , \"OrderID\" , \"Size\" , \"Price\" , \"Direction\" ];\nDSLOB = tabularTextDatastore(LOBFileName,ReadVariableNames=false,ReadSize= \"file\" ); DSLOB.VariableNames = [ \"AskPrice1\"   \"AskSize1\"   \"BidPrice1\"   \"BidSize1\"   ...                         \"AskPrice2\"   \"AskSize2\"   \"BidPrice2\"   \"BidSize2\"   ...                         \"AskPrice3\"   \"AskSize3\"   \"BidPrice3\"   \"BidSize3\"   ...                         \"AskPrice4\"   \"AskSize4\"   \"BidPrice4\"   \"BidSize4\"   ...                         \"AskPrice5\"   \"AskSize5\"   \"BidPrice5\"   \"BidSize5\" ];\nCreate a combined datastore by selecting the time variable of the message data and all levels in the limit order data.\nDSMSG.SelectedVariableNames = [ \"Time\"   \"Type\" ]; DSLOB.SelectedVariableNames = DSLOB.VariableNames;\nCombinedDS = combine(DSMSG,DSLOB);\nEngineer Features and Prepare Response Variable",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 123,
      "section_heading": "The order book data describes the intraday evolution of the limit order book of the security, which",
      "captions": ""
    }
  },
  {
    "text": "DSMSG.SelectedVariableNames = [ \"Time\"   \"Type\" ]; DSLOB.SelectedVariableNames = DSLOB.VariableNames;\nCombinedDS = combine(DSMSG,DSLOB);\nEngineer Features and Prepare Response Variable\nAI techniques can accommodate data in a variety of forms, from high-dimensional raw data, in which it's difficult for humans to find patterns and structure, through a lower dimensional space where the variables in the raw data are transformed to more practical, interpretable measurements. For example, Kolm, et al. 2021 [1] train a convolutional neural network (CNN) and LSTM on raw LOB data to forecast for trading opportunities. Regardless of form, with careful tuning, the layers of a deep network can find structure in the data that might inform predictions.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 123,
      "section_heading": "The order book data describes the intraday evolution of the limit order book of the security, which",
      "captions": ""
    }
  },
  {
    "text": "As in [4] and “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59, this example uses the current imbalance index  I t  and the sign of the forward price movements  ΔS t  to build a predictive model for future price movements. The following summarizes these measurements; for more details, see “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59.\nInitialize MapReduce for the tall array calculations.\nmapreducer(0)\nConvert the tall table into a tall timetable.\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-79",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 123,
      "section_heading": "The order book data describes the intraday evolution of the limit order book of the security, which",
      "captions": ""
    }
  },
  {
    "text": "DT = tall(CombinedDS); DT.Time = seconds(DT.Time); DTT = table2timetable(DT);\nThe timestamps are durations, seconds from midnight on June 21, 2012 when the corresponding event occurred. Obtain timestamps that are dates and times of events instead of durations.\nstrt = datetime(201,6,21,0,0,0,34200000); t = datetime(strt,Format= \"dd-MMM-yyyy HH:mm:ss.SSSSSSSSSSSSSS\" ) + DTT.Time;\nImbalance Index  I t\nThe level 3 imbalance index at time  t   I t  is the ratio of the weighted averages of the first three levels of ask and bid volumes on either side of the midprice at time  t  [4]. Symbolically,\nI t  =   V bt  − V at V bt  +  V at ,\nwhere the level 3 weighted average of bid volumes  V bt  =  ∑ j  = 1\n3 e − λ (  j  −1) V b jt  and  V b jt  is the level  j  bid\nvolume at time  t .  V at  is similarly defined.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 124,
      "section_heading": "The timestamps are durations, seconds from midnight on June 21, 2012 when the corresponding",
      "captions": ""
    }
  },
  {
    "text": "where the level 3 weighted average of bid volumes  V bt  =  ∑ j  = 1\n3 e − λ (  j  −1) V b jt  and  V b jt  is the level  j  bid\nvolume at time  t .  V at  is similarly defined.\nThe variable  λ  > 0 is a hyperparameter controlling the influence of levels 2 through 3 on the average volume. You choose the value of  λ  before training or you can tune it by, for example, performing cross-validation. This example sets  λ  to 0.5.\nI t  is in the interval −1, 1 ; a positive value indicates a larger bid volume than ask volume and a negative value indicates a larger ask volume than bid volume. A magnitude close to 1 suggests an extreme volume imbalance.\nCompute level 3 imbalance index values.\nlvl = 3;         % Hyperparameter lambda = 0.5;    % Hyperparameter weights = exp(-(lambda)*(0:(lvl-1)))'; VAsk = DTT{:, \"AskSize\"  + string(1:lvl)}*weights; VBid = DTT{:, \"BidSize\"  + string(1:lvl)}*weights; DTT.I = (VBid-VAsk)./(VBid+VAsk);\nMidprice  S t",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 124,
      "section_heading": "The timestamps are durations, seconds from midnight on June 21, 2012 when the corresponding",
      "captions": ""
    }
  },
  {
    "text": "Midprice  S t\nThe midprice at time  t   S t  is the average of the level 1 bid and ask prices,  S t  = ( V b 1 t  +  V a 1 t )/2. Price changes are measured with respect to changes in midprices.\nCompute the midprices.\nDTT.Midprices = (DTT.BidPrice1 + DTT.AskPrice1)/2;\nFocus on Order Executions\nPrices are far more likely to change when orders are executed, which correspond to event types 4 and 5 in the message data. Focus the sample on only those events.\nexecutionIdx = DTT.Type == 4 | DTT.Type == 5;    % By assumption I = DTT.I(executionIdx);\n2 Performing Common Financial Tasks\n2-80",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 124,
      "section_heading": "The timestamps are durations, seconds from midnight on June 21, 2012 when the corresponding",
      "captions": ""
    }
  },
  {
    "text": "midprices = DTT.Midprices(executionIdx); t = t(executionIdx);\nInitiate all calculations on the tall arrays.\n[I,midprices,t,DTT] = gather(I,midprices,t,DTT);\nEvaluating tall expression using the Local MATLAB Session: - Pass 1 of 1: Completed in 15 sec Evaluation completed in 17 sec\nt = t + milliseconds(1:numel(midprices))';  % Make timestamps unique\nForward Price Movement  ΔS t\nThe forward price movement at time  t   ΔS t  is the difference between the midprice  S t  at time  t  and time  t  − Δt S .\nThe variable  Δt S  > 0 is a hyperparameter controlling the baseline midprice to compare the current forward price. You can set it to the value informed by theory or practice, or you can tune it.\nFollowing the procedure in “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59 to determine a value for  Δt S , compute the average time for arrivals of order executions.\ndt = diff(t,1,1); dt.Format =  \"s\" ; dtav = expfit(dt)",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 125,
      "section_heading": "Initiate all calculations on the tall arrays.",
      "captions": ""
    }
  },
  {
    "text": "dt = diff(t,1,1); dt.Format =  \"s\" ; dtav = expfit(dt)\ndtav =  duration    0.7214 sec\ndtS = 1;     % Hyperparameter\nThe average arrival time of order executions is 0.72 seconds. The setting  Δt S  = 1 corresponds to an interval of 0.72 seconds, on average, which is close to the figure from the example. Therefore, ΔS t  =  S t  − S t  −1 .\nΔS t  indicates the magnitude and direction of the current price change from the baseline  S t  − ΔtS .\nAlthough use of the magnitude might inform future price changes, this example discretizes the  ΔS t such that it uses only the direction of the price change.\nCompute the forward price movements between execution orders.\nDS = NaN(size(midprices)); shiftS = midprices((dtS+1):end); DS(1:(end-dtS)) = sign(shiftS-midprices(1:(end-dtS)));\nThe difference operation introduces  Δt S  missing values at the tail of  DS . Remove the missing values and synchronize all series.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 125,
      "section_heading": "Initiate all calculations on the tall arrays.",
      "captions": ""
    }
  },
  {
    "text": "The difference operation introduces  Δt S  missing values at the tail of  DS . Remove the missing values and synchronize all series.\nDS = DS(1:end-dtS,:); I = I(dtS+1:end,:); midprices = midprices(dtS+1:end); t = t(dtS+1:end,:); X = [I DS];\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-81",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 125,
      "section_heading": "Initiate all calculations on the tall arrays.",
      "captions": ""
    }
  },
  {
    "text": "Response Variable  y t\nThe goal of the analysis is to build a model that accurately predicts forward price direction  ΔS t  +  ΔtS from historical forward price directions  ΔS j  and imbalance index values  I j ,  j  ≤ t .\nPrepare the response data. Cast it as a categorical variable.\nclasses = [ \"loss\"   \"const\"   \"gain\" ]; y = DS((dtS+1):end); y = categorical(y,[-1 0 1],classes); n = numel(y); numClasses = numel(classes);\nThe predictor data  X  and responses  y  are prepared for many MATLAB® machine learning functions. However, for richer model, the LSTM neural network can associate a time series of predictors with each response.\nDisplay the distribution of  y t .\ntabulate(y)\nValue    Count   Percent    loss     1497      4.61%   const    29651     91.29%    gain     1333      4.10%",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 126,
      "section_heading": "Response Variable",
      "captions": ""
    }
  },
  {
    "text": "Display the distribution of  y t .\ntabulate(y)\nValue    Count   Percent    loss     1497      4.61%   const    29651     91.29%    gain     1333      4.10%\nThe class distribution is severely imbalanced—a majority of the forward price changes are constant. A naive model that always predicts into the constant class, or a mathematical model trained to predict into that way, has about 91% accuracy. However, such a model does not predict price changes for trading opportunities. Therefore, because the goal is to exploit imbalances to make money, the model needs to be trained to learn how to predict losses and gains well, likely at the expense of misclassifying the constant class.\nPrepare Data for LSTM Neural Network",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 126,
      "section_heading": "Response Variable",
      "captions": ""
    }
  },
  {
    "text": "Prepare Data for LSTM Neural Network\nA long short-term memory neural network is a special case of a recurrent neural network (RNN) that associates a time series of features with a response. Its goal is to learn long-term associations between the response and features, while \"forgetting\" less useful associations. Symbolically,\ny t  =  f X t ,  X t  −1 , . . . ,  X t  − b ;  W  ,\nwhere:\n• y t  is the response at time  t .\n• X t  is the collection of features at time  t , which can include lagged response values.\n• X t  −1  is the collection of features at time  t  −1.\n• b  is the outlook hyperparameter.\n• W  is the collection of neural network weights and biases.\n• f  specifies the LSTM architecture.\nFor more details, see “Long Short-Term Memory Neural Networks” (Deep Learning Toolbox).\n2 Performing Common Financial Tasks\n2-82",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 126,
      "section_heading": "Response Variable",
      "captions": ""
    }
  },
  {
    "text": "Prepare the data for the LSTM neural network by associating each response with the past  b  = 100 forward price movements and imbalance index values ( b  is arbitrarily chosen in this example). Store each successive feature series in a cell vector.\nb = 100;     % Hyperpatameter n = n - b + 1; XCell = cell(n,1);\nfor  k = 1:n     tmp = zeros(width(X),b);      for  j = 1:b         tmp(:,j) = X(j+k-1,:)';      end     XCell{k} = tmp; end\nBecause the first predictor observation contains measurements from times 1 through 100, the response data must start at time 101. In other words, the setting  b  causes the sample size reduction n  − b .\nSynchronize the series.\nXCell = XCell(1:(end-1)); y = y(b:(end-1)); midprices = midprices(b-1:end-2); n = numel(y); head(table(XCell,y))\nXCell           y       ______________    _____",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 127,
      "section_heading": "Prepare the data for the LSTM neural network by associating each response with the past",
      "captions": ""
    }
  },
  {
    "text": "Synchronize the series.\nXCell = XCell(1:(end-1)); y = y(b:(end-1)); midprices = midprices(b-1:end-2); n = numel(y); head(table(XCell,y))\nXCell           y       ______________    _____\n{2×100 double}    const     {2×100 double}    const     {2×100 double}    const     {2×100 double}    const     {2×100 double}    const     {2×100 double}    const     {2×100 double}    const     {2×100 double}    const\nEach response is associated with a 2-by-100 matrix of predictor data. In the first row of the table display,  XCell{1,:}  contains imbalance index values during times  t(1:100)  and  XCell{2,:} contains forward price movements in the same period.  y(1)  is future forward price movement during time(101)  (recall  Δt S  = 1). Symbolically, the model is\ny t  + 1  =  f I t ,  I t  −1 , . . . ,  I t  −100 ,  ΔS t ,  ΔS t  −1 , . . . , ,  ΔS t  −100 ;  W  .\nPartition Data",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 127,
      "section_heading": "Prepare the data for the LSTM neural network by associating each response with the past",
      "captions": ""
    }
  },
  {
    "text": "y t  + 1  =  f I t ,  I t  −1 , . . . ,  I t  −100 ,  ΔS t ,  ΔS t  −1 , . . . , ,  ΔS t  −100 ;  W  .\nPartition Data\nPartition the data into training, validation, and backtesting sets. Because the data are time series, you can use the  tspartition  function, which, among other features, cuts the data, rather than shuffles it before cutting it. Reserve half the data for backtesting, and partition the other half of the data so that 85% is for training the model and 15% is for validation.\npBT = 0.5; tspFull = tspartition(n,Holdout=pBT); idxTV = training(tspFull);   % Training and validation indices\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-83",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 127,
      "section_heading": "Prepare the data for the LSTM neural network by associating each response with the past",
      "captions": ""
    }
  },
  {
    "text": "idxBT = test(tspFull);       % Backtesting indices XTV = XCell(idxTV); yTV = y(idxTV); XBT = XCell(idxBT); yBT = y(idxBT); tBT = t(idxBT); mpBT = midprices(idxBT); nBT = sum(idxBT);\npV = 0.15; nTV = sum(idxTV); tspTV = tspartition(nTV,Holdout=pV); idxT = training(tspTV);      % Training indices idxV = test(tspTV);          % Validation indices XT = XCell(idxT); yT = y(idxT); XV = XCell(idxV); yV = y(idxV);\nConfigure LSTM Neural Networks\nConsider training the following two LSTM neural networks:\n• A deep learning model that ignores the severely imbalanced class distribution of the response data.\n• A deep learning model that, despite the risk, addresses imbalanced class distribution by applying a weighting scheme.\nFor both deep learning models, this example uses the following LSTM architecture in this order. For more details, see “Long Short-Term Memory Neural Networks” (Deep Learning Toolbox).",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 128,
      "section_heading": "Configure LSTM Neural Networks",
      "captions": ""
    }
  },
  {
    "text": "For both deep learning models, this example uses the following LSTM architecture in this order. For more details, see “Long Short-Term Memory Neural Networks” (Deep Learning Toolbox).\n• sequenceInputLayer  — Sequence input layer for the two feature variables with  b  =  MinLength = 100.\n• batchNormalizationLayer  — Batch normalization layer, which normalizes a mini-batch of data across all observations to speed up training and reduce the sensitivity to network initialization.\n• lstmLayer  — Long short-term memory layer with 64 hidden units and configured to return only the last step sequence. The number of hidden layers is a hyperparameter.\n• fullyConnectedLayer  — Fully connected layer, which combines  W  and inputs, and reduces the number of neurons to 10.\n• leakyReluLayer  — Leaky ReLU layer, which reduces negative outputs of the fully connected layer to 10% of their value.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 128,
      "section_heading": "Configure LSTM Neural Networks",
      "captions": ""
    }
  },
  {
    "text": "• leakyReluLayer  — Leaky ReLU layer, which reduces negative outputs of the fully connected layer to 10% of their value.\n• fullyConnectedLayer  — Fully connected layer, which combines  W  and inputs, and reduces the number of neurons to 3.\n• softmaxLayer  — Softmax layer, which outputs a length 3 vector of class probabilities by applying the softmax function to the outputs of the previous fully connected layer.\nThe risky model applies the following class weighting scheme to increase the penalty on the loss for predicting into the gain and loss classes:\nu j  =   n T 3 c j ,\n2 Performing Common Financial Tasks\n2-84",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 128,
      "section_heading": "Configure LSTM Neural Networks",
      "captions": ""
    }
  },
  {
    "text": "where  n T  is the number of training observations and  c j  is the number of responses in class  j . This weighting scheme forces the classifier to pay more attention to the classes with lower frequency.\nCompute the class weights.\nnTP = tspTV.TrainSize; classFreqT = countcats(yT); classWtsT = nTP./(numClasses*classFreqT);\nFor each LSTM neural network, create an array specifying the architecture. Note that the LSTM architecture itself is a hyperparameter, as are most options taken at their default.\n% Hyperparameters numHiddenUnits = 64; numNeuronsOutFC1 = 10; thresholdScaleLR = 0.1;\nlayersLSTM = [     sequenceInputLayer(2,Name= \"Sequence\" ,MinLength=b)     batchNormalizationLayer(Name= \"BN\" )     lstmLayer(numHiddenUnits,Name= \"LSTM\" ,OutputMode= \"last\" )     fullyConnectedLayer(numNeuronsOutFC1,Name= \"FC1\" )     leakyReluLayer(thresholdScaleLR,Name= \"LR\" )     fullyConnectedLayer(3,Name= \"FC2\" )     softmaxLayer(Name= \"Softmax\" )];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 129,
      "section_heading": "where",
      "captions": ""
    }
  },
  {
    "text": "lossFcn = @(Y,T) crossentropy(Y,T,  ...     classWtsT,  ...     Reduction =  \"sum\" , ...     WeightsFormat= \"C\" , ...     ClassificationMode= \"single-label\" , ...     NormalizationFactor= \"none\" )*numClasses;\nCreate the LSTM architectures and visualize one of them.\nfigure plot(dlnetwork(layersLSTM))\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-85",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 129,
      "section_heading": "where",
      "captions": ""
    }
  },
  {
    "text": "Train and Validate LSTM Neural Network\nSet the following training options by using the  trainingOptions  function:\n• Use the stochastic gradient descent with momentum solver.\n• Plot the training progress.\n• Monitor the solver's progress by printing numeric results, in real time, every 100 iterations.\n• Set the initial learning rate to  1e-1  and specify a piecewise learning rate schedule. These are hyperparameters.\n• Specify the validation data in a cell vector.\n• Validate every 100 iterations and set the validation patience to 5.\n• Shuffle the data every epoch.\nVData = {XV,yV};\n% Hyperparameters lr = 1e-4; lrs =  \"piecewise\" ;\noptions = trainingOptions( \"sgdm\" ,  ...     Plots= 'training-progress' ,  ...     InputDataFormats= \"CTB\" , ...     Metric= \"accuracy\" , ...     Verbose=1,VerboseFrequency=100,  ...     InitialLearnRate=lr,LearnRateSchedule=lrs,  ...     ValidationData=VData,ValidationFrequency=100,ValidationPatience=5,  ...     Shuffle= \"every-epoch\" );",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 130,
      "section_heading": "Train and Validate LSTM Neural Network",
      "captions": ""
    }
  },
  {
    "text": "To train and validate the LSTM neural networks, set  trainLSTM  to  true . Otherwise, this example loads the pretrained LSTM neural networks  LSTMMdl  and  RiskyLSTMMdl  in the MAT-file\n2 Performing Common Financial Tasks\n2-86",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 130,
      "section_heading": "Train and Validate LSTM Neural Network",
      "captions": ""
    }
  },
  {
    "text": "PretrainedLOBLSTMLvl3.mat , which is included with the Financial Toolbox documentation. Analyze the trained risky model.\ntrainLSTM = false; if  trainLSTM     rng(1, \"twister\" )     LSTMMdl = trainnet(XT,yT,layersLSTM, \"crossentropy\" ,options);     RiskyLSTMMdl = trainnet(XT,yT,layersLSTM,lossFcn,options); else     load  PretrainedLOBLSTMLvl3 end analyzeNetwork(RiskyLSTMMdl)\nAssess Trained LSTM Model Quality\nFor each trained LSTM model, compute the model accuracy on the validation data and plot a confusion chart by following this procedure:\n1 Predict responses and classification scores for the validation data by passing the feature validation data and the trained LSTM model to  classify .\n2 Pass the observed and predicted responses to  confusionchart . Add column and row summaries to the chart.\n[predScoresLSTM] = minibatchpredict(LSTMMdl,XV,InputDataFormats= \"CTB\" );\nWarning: Support for GPU devices with compute capability 7.0 will be removed in a future MATLAB r",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 131,
      "section_heading": "PretrainedLOBLSTMLvl3.mat",
      "captions": ""
    }
  },
  {
    "text": "[predScoresLSTM] = minibatchpredict(LSTMMdl,XV,InputDataFormats= \"CTB\" );\nWarning: Support for GPU devices with compute capability 7.0 will be removed in a future MATLAB r\npredYLSTM = scores2label(predScoresLSTM,classes); accV = 100*mean(predYLSTM == yV)\naccV =  91.0626\nfigure cm = confusionchart(yV,predYLSTM); cm.NormalizedValues; cm.RowSummary =  \"row-normalized\" ;\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-87",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 131,
      "section_heading": "PretrainedLOBLSTMLvl3.mat",
      "captions": ""
    }
  },
  {
    "text": "cm.ColumnSummary =  \"column-normalized\" ; cm.Title =  \"LSTM\" ;\nThe conservative LSTM neural network predicts into the constant class for all validation observations. The 91% accuracy comes for free because this model acts like the naive model discussed in Engineer Features and Prepare Response Variable on page 2-79, which only ever predicts into the constant class. Such a model does not make money.\n[predScoresRLSTM] = minibatchpredict(RiskyLSTMMdl,XV,InputDataFormats= \"CTB\" ); predYRLSTM = scores2label(predScoresRLSTM,classes); accRiskyV = 100*mean(predYRLSTM == yV)\naccRiskyV =  60.8731\nfigure cm = confusionchart(yV,predYRLSTM); cm.NormalizedValues; cm.RowSummary =  \"row-normalized\" ; cm.ColumnSummary =  \"column-normalized\" ; cm.Title =  \"Risky LSTM\" ;\n2 Performing Common Financial Tasks\n2-88",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 132,
      "section_heading": "The conservative LSTM neural network predicts into the constant class for all validation",
      "captions": ""
    }
  },
  {
    "text": "The risky LSTM model accuracy is about 61%. Despite this low value, the confusion chart suggests the following other aspects about the model's performance as it pertains to the trading strategy.\n• It correctly predicted about 65% of the 86 true gains, which makes money.\n• It correctly predicted about 79% of the 131 true losses, which prevents money loss.\n• It incorrectly predicted about 35% of the true gains as losses or constant, which results is a missed opportunity to make money.\n• It incorrectly predicted about 2% of the true losses as gains, which results in a money loss.\nPlot ROC curves for both deep learning models.\nrocLSTM = rocmetrics(yV,predScoresLSTM,classes); rocRLSTM = rocmetrics(yV,predScoresRLSTM,classes);\nfigure tiledlayout(1,2,TileSpacing= \"compact\" ) nexttile plot(rocLSTM,ShowModelOperatingPoint=false) title( \"ROC Curve: LSTM\" ) nexttile plot(rocRLSTM,ShowModelOperatingPoint=false) title( \"ROC Curve: Risky LSTM\" )",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 133,
      "section_heading": "The risky LSTM model accuracy is about 61%. Despite this low value, the confusion chart suggests",
      "captions": ""
    }
  },
  {
    "text": "Backtest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-89",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 133,
      "section_heading": "The risky LSTM model accuracy is about 61%. Despite this low value, the confusion chart suggests",
      "captions": ""
    }
  },
  {
    "text": "In general, each curve represents the ability of the model to distinguish observations that are in the corresponding class from the other two classes at various classification decision thresholds. For example, the blue curve corresponds to the ability of the classifiers to correctly distinguish losses from constants or gains. The diagonal dashed line is a hypothetical classifier that assigns observations into classes at random, which is a baseline for comparison. The curve of a good classifier increases very quickly and then levels off, making the area under the curve (AUC) close to 1. In other words, a good classifier has a high true positive rate for all classification decision thresholds, regardless of false positive rate levels produced. Note that the ROC curve does not consider false negative rates.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 134,
      "section_heading": "In general, each curve represents the ability of the model to distinguish observations that are in the",
      "captions": ""
    }
  },
  {
    "text": "In this case, the risky LSTM is better at correctly distinguishing each class from the other two than the conservative LSTM; the AUCs of the risky LSTM are larger than the corresponding AUCs of the conservative LSTM.\nBacktest Risky LSTM Model\nBacktesting a predictive financial model dispatches it, and a trading strategy based on its predictions, on historical data. This action determines how well the model performs, with respect to the strategy. A backtest requires:\n• Historical data not used to train or validate the model (see Partition Data on page 2-83)\n• The target predictive model (The risky LSTM neural network  RiskyLSTMMdl )\n• The model's predictions (signals) on the historical data\n• At least one trading strategy\nClassify the forward price movements in the backtest data  XBT  using the risky LSTM neural network.\n[predScoresRLSTMBT] = minibatchpredict(RiskyLSTMMdl,XBT,InputDataFormats= \"CTB\" ); predYRLSTMBT = scores2label(predScoresRLSTMBT,classes);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 134,
      "section_heading": "In general, each curve represents the ability of the model to distinguish observations that are in the",
      "captions": ""
    }
  },
  {
    "text": "[predScoresRLSTMBT] = minibatchpredict(RiskyLSTMMdl,XBT,InputDataFormats= \"CTB\" ); predYRLSTMBT = scores2label(predScoresRLSTMBT,classes);\n2 Performing Common Financial Tasks\n2-90",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 134,
      "section_heading": "In general, each curve represents the ability of the model to distinguish observations that are in the",
      "captions": ""
    }
  },
  {
    "text": "A trading strategy requires a way to predict outcomes and what financial decisions to make based on the outcomes. This example uses the following trading decision logic:\n• If the forward price direction is predicted to be a gain, invest all available money.\n• If the forward price direction is predicted to be a loss, cash out.\n• Otherwise, do nothing.\nThe  rebalance  function, located in this example in Local Functions on page 2-93, defines these predictive models:\n• Maximum Profit Model  MaxProfit : A baseline model that perfectly predicts the next forward price direction, and therefore it always makes the right trading decisions.\n• Risky LSTM Neural Network  RiskyLSTM : A model that predicts the next forward price direction by using the trained risky LSTM neural network  RiskyLSTMMdl , with trading decisions based on its predictions.\nThe inputs of  rebalance  are:\n• Required asset weights  w , which are the proportion of capital to invest across assets",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 135,
      "section_heading": "A trading strategy requires a way to predict outcomes and what financial decisions to make based on",
      "captions": ""
    }
  },
  {
    "text": "The inputs of  rebalance  are:\n• Required asset weights  w , which are the proportion of capital to invest across assets\n• Required asset prices  p , which are not used in this example\n• Signal data  s , optional data used to inform trading decisions\n• Optional user data structure to print backtest iteration information\n• Optional column of signal data to operate on for the strategy\n• Optional strategy name\nDefine the backtest strategies by passing the a function handle to  rebalance  to “Create backtestStrategy” on page 15-233. Set the following properties:\n• LookbackWindow=1 , which indicates that the previous data point is available to the  rebalance function during backtesting.\n• UserData=user_data , where  user_data  is a structure array containing the fields  Counter , set initially to 0, and  NumTestPoints , set to the backtest sample size.\nStore the strategies in a vector.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 135,
      "section_heading": "A trading strategy requires a way to predict outcomes and what financial decisions to make based on",
      "captions": ""
    }
  },
  {
    "text": "Store the strategies in a vector.\nuser_data = struct( \"Counter\" ,0, \"NumTestPoints\" ,nBT); maxMoneyStrat = backtestStrategy( \"MaxProfit\" ,@(w,p,s,u)rebalance(w,p,s,u,1, \"MaxProfit\" ),  ...     LookbackWindow=1,UserData=user_data); RiskyLSTMStrat = backtestStrategy( \"RiskyLSTM\" ,@(w,p,s,u)rebalance(w,p,s,u,2, \"RiskyLSTM\" ),  ...     LookbackWindow=1,UserData=user_data); strategies = [maxMoneyStrat RiskyLSTMStrat];\nstrategies  is a vector of  backtestStrategy  objects storing the backtest strategies.\nPrepare the backtest engine by supplying the vector of  backtestStrategy  objects to backtestEngine .\nbte = backtestEngine(strategies);\nbte  is a  backtestEngine  object specifying parameters for the backtest, including the risk-free rate RiskFreeRate , which is 0% by default.\nStore the backtest forward price direction data and risky LSTM predictions in a timetable.\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-91",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 135,
      "section_heading": "A trading strategy requires a way to predict outcomes and what financial decisions to make based on",
      "captions": ""
    }
  },
  {
    "text": "signalTT = timetable(yBT,predYRLSTMBT,RowTimes=tBT);\nStore the backtest midprices in a timetable.\nmpTT = timetable(mpBT,RowTimes=tBT);\nRun the backtest by passing the backtest engine, midprice data, and signal data to  runBacktest .\nbte = runBacktest(bte,mpTT,signalTT);\nBacktesting MaxProfit. Total progress: 5000 of 16190. Backtesting MaxProfit. Total progress: 10000 of 16190. Backtesting MaxProfit. Total progress: 15000 of 16190. Backtesting RiskyLSTM. Total progress: 5000 of 16190. Backtesting RiskyLSTM. Total progress: 10000 of 16190. Backtesting RiskyLSTM. Total progress: 15000 of 16190.\nbte  is a  backtestEngine  object containing the results of the backtest.\nDisplay a summary of the results by passing the completed backtest engine object to  summary .\nsummary(bte)\nans= 9×2 table                        MaxProfit     RiskyLSTM                         __________    __________",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 136,
      "section_heading": "Store the backtest midprices in a timetable.",
      "captions": ""
    }
  },
  {
    "text": "summary(bte)\nans= 9×2 table                        MaxProfit     RiskyLSTM                         __________    __________\nTotalReturn          0.076328      0.067524     SharpeRatio           0.15212       0.13715     Volatility         2.9873e-05    2.9433e-05     AverageTurnover      0.010624     0.0090802     MaxTurnover               0.5           0.5     AverageReturn       4.544e-06    4.0366e-06     MaxDrawdown        0.00018751    0.00055683     AverageBuyCost              0             0     AverageSellCost             0             0\nThe total nonannualized returns of the maximum profit and risky LSTM model are 7.6% and 6.8%, respectively. Therefore, the LSTM neural network performs well over the historical data.\nPlot equity curves of the strategies by passing the completed backtest engine object to equityCurve .\nfigure equityCurve(bte)\n2 Performing Common Financial Tasks\n2-92",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 136,
      "section_heading": "Store the backtest midprices in a timetable.",
      "captions": ""
    }
  },
  {
    "text": "The equity curves indicate both strategies performed well, and are in close correspondence with each other.\nLocal Function\nThe  rebalance  function directs the backtest framework to perform the following trades:\n• When the model predicts a price gain, invest all available cash.\n• When the model predicts a price loss, cash out entirely.\n• When the model predicts a constant price, take no actions.\nYou can use this function only from in this script.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 137,
      "section_heading": "The equity curves indicate both strategies performed well, and are in close correspondence with each",
      "captions": ""
    }
  },
  {
    "text": "• When the model predicts a price loss, cash out entirely.\n• When the model predicts a constant price, take no actions.\nYou can use this function only from in this script.\nfunction  [new_weights,user_data] = rebalance(weights,~,signalData,user_data,col,id)     new_weights = weights;          direction = signalData{:,col};      if  direction ==  \"gain\"         new_weights = 1;     % Expect a gain --> Fully invest       end      if  direction ==  \"loss\"         new_weights = 0;     % Expect loss --> Cash out, with risk-free rate of 0%      end           % Print iteration information at command line      user_data.Counter = user_data.Counter + 1;      if  (mod(user_data.Counter,5000) == 0)         displayText =  \"Backtesting \"  + id +  \". Total progress: \"  + num2str(user_data.Counter) +  \"         disp(displayText);\nBacktest Deep Learning Model for Algorithmic Trading of Limit Order Book Data\n2-93",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 137,
      "section_heading": "The equity curves indicate both strategies performed well, and are in close correspondence with each",
      "captions": ""
    }
  },
  {
    "text": "end      end\nReferences\n[1] Kolm, Petter, N., Jeremy Turiel, and Nicholas Westray. \"Deep Order Flow Imbalance: Extracting Alpha at Multiple Horizons from the Limit Order Book.\"  SSRN  (August 2021): https:// papers.ssrn.com/sol3/papers.cfm?abstract_id=3900141.\n[2] LOBSTER Limit Order Book Data. Berlin: frischedaten UG (haftungsbeschränkt).\n[3] NASDAQ Historical TotalView-ITCH Data. New York: The Nasdaq, Inc.\n[4] Rubisov, Anton D. \"Statistical Arbitrage Using Limit Order Book Imbalance.\" Master's thesis, University of Toronto, 2015.\nSee Also\nMore About\n• “Machine Learning for Statistical Arbitrage: Introduction” on page 2-48\n• “Machine Learning for Statistical Arbitrage II: Feature Engineering and Model Development” on page 2-59\n• “Machine Learning for Statistical Arbitrage III: Training, Tuning, and Prediction” on page 2-69\n• “Backtest Investment Strategies Using Financial Toolbox” on page 4-238\n• “Backtest Strategies Using Deep Learning” on page 4-302",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 138,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "• “Backtest Investment Strategies Using Financial Toolbox” on page 4-238\n• “Backtest Strategies Using Deep Learning” on page 4-302\n• “Backtest Investment Strategies with Trading Signals” on page 4-251\n• “Deep Reinforcement Learning for Optimal Trade Execution” on page 4-407\n2 Performing Common Financial Tasks\n2-94",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 138,
      "section_heading": "References",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Analysis\n• “Analyzing Portfolios” on page 3-2\n• “Portfolio Optimization Functions” on page 3-3\n• “Portfolio Construction Examples” on page 3-5\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “portopt Migration to Portfolio Object” on page 3-11\n• “Constraint Specification Using a Portfolio Object” on page 3-19\n• “Active Returns and Tracking Error Efficient Frontier” on page 3-27\n3",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 139,
      "section_heading": "Portfolio Analysis",
      "captions": ""
    }
  },
  {
    "text": "Analyzing Portfolios\nPortfolio managers concentrate their efforts on achieving the best possible trade-off between risk and return. For portfolios constructed from a fixed set of assets, the risk/return profile varies with the portfolio composition. Portfolios that maximize the return, given the risk, or, conversely, minimize the risk for the given return, are called  optimal . Optimal portfolios define a line in the risk/return plane called the  efficient frontier .\nA portfolio may also have to meet additional requirements to be considered. Different investors have different levels of risk tolerance. Selecting the adequate portfolio for a particular investor is a difficult process. The portfolio manager can hedge the risk related to a particular portfolio along the efficient frontier with partial investment in risk-free assets. The definition of the capital allocation line, and finding where the final portfolio falls on this line, if at all, is a function of:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 140,
      "section_heading": "Analyzing Portfolios",
      "captions": ""
    }
  },
  {
    "text": "• The risk/return profile of each asset\n• The risk-free rate\n• The borrowing rate\n• The degree of risk aversion characterizing an investor\nFinancial Toolbox software includes a set of portfolio optimization functions designed to find the portfolio that best meets investor requirements.\nWarning  frontcon  has been removed. Use  Portfolio  instead.\nportopt  has been partially removed and will no longer accept  ConSet  or  varargin  arguments. portopt  will only solve the portfolio problem for long-only fully invested portfolios. Use  Portfolio instead.\nSee Also portalloc  |  frontier  |  portopt  |  Portfolio  |  portcons  |  portvrisk  |  pcalims  |  pcgcomp  | pcglims  |  pcpval  |  abs2active  |  active2abs\nRelated Examples\n• “Portfolio Optimization Functions” on page 3-3\n• “Portfolio Construction Examples” on page 3-5\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “Active Returns and Tracking Error Efficient Frontier” on page 3-27",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 140,
      "section_heading": "Analyzing Portfolios",
      "captions": ""
    }
  },
  {
    "text": "• “Portfolio Construction Examples” on page 3-5\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “Active Returns and Tracking Error Efficient Frontier” on page 3-27\n• “Plotting an Efficient Frontier Using portopt” on page 10-22\nMore About\n• “Portfolio Object Workflow” on page 4-18\n3 Portfolio Analysis\n3-2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 140,
      "section_heading": "Analyzing Portfolios",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Optimization Functions\nThe portfolio optimization functions assist portfolio managers in constructing portfolios that optimize risk and return.\nCapital Allocation Description\nportalloc Computes the optimal risky portfolio on the efficient frontier, based on the risk-free rate, the borrowing rate, and the investor's degree of risk aversion. Also generates the capital allocation line, which provides the optimal allocation of funds between the risky portfolio and the risk-free asset.\nEfficient Frontier Computation\nDescription\nfrontier Computes portfolios along the efficient frontier for a given group of assets. Generates a surface of efficient frontiers showing how asset allocation influences risk and return over time.\nportopt Computes portfolios along the efficient frontier for a given group of assets. The computation is based on a set of user-specified linear constraints. Typically, these constraints are generated using the constraint specification functions described below.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 141,
      "section_heading": "Portfolio Optimization Functions",
      "captions": ""
    }
  },
  {
    "text": "Warning  portopt  has been partially removed and will no longer accept ConSet  or  varargin  arguments.  portopt  will only solve the portfolio problem for long-only fully invested portfolios. Use  Portfolio  instead. For more information on migrating  portopt  code to  Portfolio , see “portopt Migration to Portfolio Object” on page 3-11.\nConstraint Specification\nDescription\nportcons Generates the portfolio constraints matrix for a portfolio of asset investments using linear inequalities. The inequalities are of the type  A*Wts' <= b , where  Wts  is a row vector of weights.\nportvrisk Portfolio value at risk (VaR) returns the maximum potential loss in the value of a portfolio over one period of time, given the loss probability level RiskThreshold .\npcalims Asset minimum and maximum allocation. Generates a constraint set to fix the minimum and maximum weight for each individual asset.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 141,
      "section_heading": "Portfolio Optimization Functions",
      "captions": ""
    }
  },
  {
    "text": "pcalims Asset minimum and maximum allocation. Generates a constraint set to fix the minimum and maximum weight for each individual asset.\npcgcomp Group-to-group ratio constraint. Generates a constraint set specifying the maximum and minimum ratios between pairs of groups.\npcglims Asset group minimum and maximum allocation. Generates a constraint set to fix the minimum and maximum total weight for each defined group of assets.\npcpval Total portfolio value. Generates a constraint set to fix the total value of the portfolio.\nPortfolio Optimization Functions\n3-3",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 141,
      "section_heading": "Portfolio Optimization Functions",
      "captions": ""
    }
  },
  {
    "text": "Constraint Conversion\nDescription\nabs2active Transforms a constraint matrix expressed in absolute weight format to an equivalent matrix expressed in active weight format.\nactive2abs Transforms a constraint matrix expressed in active weight format to an equivalent matrix expressed in absolute weight format.\nNote  An alternative to using these portfolio optimization functions is to use the Portfolio object ( Portfolio ) for mean-variance portfolio optimization. This object supports gross or net portfolio returns as the return proxy, the variance of portfolio returns as the risk proxy, and a portfolio set that is any combination of the specified constraints to form a portfolio set. For information on the workflow when using Portfolio objects, see “Portfolio Object Workflow” on page 4-18.\nSee Also portalloc  |  frontier  |  portopt  |  Portfolio  |  portcons  |  portvrisk  |  pcalims  |  pcgcomp  | pcglims  |  pcpval  |  abs2active  |  active2abs\nRelated Examples",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 142,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "See Also portalloc  |  frontier  |  portopt  |  Portfolio  |  portcons  |  portvrisk  |  pcalims  |  pcgcomp  | pcglims  |  pcpval  |  abs2active  |  active2abs\nRelated Examples\n• “Portfolio Construction Examples” on page 3-5\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “Active Returns and Tracking Error Efficient Frontier” on page 3-27\n• “Plotting an Efficient Frontier Using portopt” on page 10-22\n• “portopt Migration to Portfolio Object” on page 3-11\nMore About\n• “Analyzing Portfolios” on page 3-2\n• “Portfolio Object Workflow” on page 4-18\n3 Portfolio Analysis\n3-4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 142,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Construction Examples\nIn this section...\n“Introduction” on page 3-5\n“Efficient Frontier Example” on page 3-5\nIntroduction\nThe efficient frontier computation functions require information about each asset in the portfolio. This data is entered into the function via two matrices: an expected return vector and a covariance matrix. The expected return vector contains the average expected return for each asset in the portfolio. The covariance matrix is a square matrix representing the interrelationships between pairs of assets. This information can be directly specified or can be estimated from an asset return time series with the function  ewstats .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 143,
      "section_heading": "Portfolio Construction Examples",
      "captions": ""
    }
  },
  {
    "text": "Note  An alternative to using these portfolio optimization functions is to use the Portfolio object ( Portfolio ) for mean-variance portfolio optimization. This object supports gross or net portfolio returns as the return proxy, the variance of portfolio returns as the risk proxy, and a portfolio set that is any combination of the specified constraints to form a portfolio set. For information on the workflow when using Portfolio objects, see “Portfolio Object Workflow” on page 4-18.\nEfficient Frontier Example\nfrontcon  has been removed. To model the efficient frontier, use the  Portfolio  object instead. For example, using the  Portfolio  object, you can model an efficient frontier:\n• “Obtaining Portfolios Along the Entire Efficient Frontier” on page 4-99\n• “Obtaining Endpoints of the Efficient Frontier” on page 4-102\n• “Obtaining Efficient Portfolios for Target Returns” on page 4-105\n• “Obtaining Efficient Portfolios for Target Risks” on page 4-108",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 143,
      "section_heading": "Portfolio Construction Examples",
      "captions": ""
    }
  },
  {
    "text": "• “Obtaining Endpoints of the Efficient Frontier” on page 4-102\n• “Obtaining Efficient Portfolios for Target Returns” on page 4-105\n• “Obtaining Efficient Portfolios for Target Risks” on page 4-108\n• “Efficient Portfolio That Maximizes Sharpe Ratio” on page 4-111\n• “Estimate Efficient Frontiers for Portfolio Object” on page 4-122\n• “Plotting the Efficient Frontier for a Portfolio Object” on page 4-125\nSee Also portalloc  |  frontier  |  portopt  |  Portfolio  |  portcons  |  portvrisk  |  pcalims  |  pcgcomp  | pcglims  |  pcpval  |  abs2active  |  active2abs\nRelated Examples\n• “Portfolio Optimization Functions” on page 3-3\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “Active Returns and Tracking Error Efficient Frontier” on page 3-27\n• “Plotting an Efficient Frontier Using portopt” on page 10-22\n• “portopt Migration to Portfolio Object” on page 3-11\nPortfolio Construction Examples\n3-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 143,
      "section_heading": "Portfolio Construction Examples",
      "captions": ""
    }
  },
  {
    "text": "More About\n• “Analyzing Portfolios” on page 3-2\n• “Portfolio Object Workflow” on page 4-18\n3 Portfolio Analysis\n3-6",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 144,
      "section_heading": "More About",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Selection and Risk Aversion\nIn this section...\n“Introduction” on page 3-7\n“Optimal Risky Portfolio” on page 3-8\nIntroduction\nOne of the factors to consider when selecting the optimal portfolio for a particular investor is the degree of risk aversion. This level of aversion to risk can be characterized by defining the investor's indifference curve. This curve consists of the family of risk/return pairs defining the trade-off between the expected return and the risk. It establishes the increment in return that a particular investor requires to make an increment in risk worthwhile. Typical risk aversion coefficients range from 2.0 through 4.0, with the higher number representing lesser tolerance to risk. The equation used to represent risk aversion in Financial Toolbox software is\nU = E(r) - 0.005*A*sig^2\nwhere:\nU  is the utility value.\nE(r)  is the expected return.\nA  is the index of investor's aversion.\nsig  is the standard deviation.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 145,
      "section_heading": "Portfolio Selection and Risk Aversion",
      "captions": ""
    }
  },
  {
    "text": "U = E(r) - 0.005*A*sig^2\nwhere:\nU  is the utility value.\nE(r)  is the expected return.\nA  is the index of investor's aversion.\nsig  is the standard deviation.\nNote  An alternative to using these portfolio optimization functions is to use the Portfolio object ( Portfolio ) for mean-variance portfolio optimization. This object supports gross or net portfolio\nPortfolio Selection and Risk Aversion\n3-7",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 145,
      "section_heading": "Portfolio Selection and Risk Aversion",
      "captions": ""
    }
  },
  {
    "text": "returns as the return proxy, the variance of portfolio returns as the risk proxy, and a portfolio set that is any combination of the specified constraints to form a portfolio set. For information on the workflow when using Portfolio objects, see “Portfolio Object Workflow” on page 4-18.\nOptimal Risky Portfolio\nThis example shows how to compute the optimal risky portfolio on the efficient frontier based on the risk-free rate, the borrowing rate, and the investor's degree of risk aversion.\nYou do this with the function  portalloc . First generate the efficient frontier data using  portopt .\nExpReturn = [0.1 0.2 0.15];\nExpCovariance  = [ 0.005   -0.010    0.004;                   -0.010    0.040   -0.002;                    0.004   -0.002    0.023];\nNumPorts = 20;  % Consider 20 different points along the efficient frontier.\n[PortRisk, PortReturn, PortWts] = portopt(ExpReturn, ...   ExpCovariance, NumPorts);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 146,
      "section_heading": "Optimal Risky Portfolio",
      "captions": ""
    }
  },
  {
    "text": "NumPorts = 20;  % Consider 20 different points along the efficient frontier.\n[PortRisk, PortReturn, PortWts] = portopt(ExpReturn, ...   ExpCovariance, NumPorts);\nCalling  portopt , while specifying output arguments, returns the corresponding vectors and arrays representing the risk, return, and weights for each of the portfolios along the efficient frontier. Use these as the first three input arguments to the function  portalloc .\nFind the optimal risky portfolio and the optimal allocation of funds between the risky portfolio and the risk-free asset, using these values for the risk-free rate, borrowing rate, and investor's degree of risk aversion.\nRisklessRate  =  0.08\nRisklessRate =  0.0800\nBorrowRate    =  0.12\nBorrowRate =  0.1200\nRiskAversion  =  3\nRiskAversion =  3\nportalloc(PortRisk, PortReturn, PortWts, RisklessRate, ...   BorrowRate, RiskAversion);\n3 Portfolio Analysis\n3-8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 146,
      "section_heading": "Optimal Risky Portfolio",
      "captions": ""
    }
  },
  {
    "text": "Calling  portalloc  while specifying the output arguments returns the variance ( RiskyRisk ), the expected return ( RiskyReturn ), and the weights ( RiskyWts ) allocated to the optimal risky portfolio. It also returns the fraction ( RiskyFraction ) of the complete portfolio allocated to the risky portfolio, and the variance ( OverallRisk ) and expected return ( OverallReturn ) of the optimal overall portfolio. The overall portfolio combines investments in the risk-free asset and in the risky portfolio. The actual proportion assigned to each of these two investments is determined by the degree of risk aversion characterizing the investor.\n[RiskyRisk, RiskyReturn, RiskyWts,RiskyFraction, OverallRisk,  ...   OverallReturn] = portalloc (PortRisk, PortReturn, PortWts,  ...   RisklessRate, BorrowRate, RiskAversion)\nRiskyRisk =  0.1288\nRiskyReturn =  0.1791\nRiskyWts =  1×3\n0.0057    0.5879    0.4064\nRiskyFraction =  1.1869\nOverallRisk =  0.1529\nOverallReturn =  0.1902",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 147,
      "section_heading": "Calling",
      "captions": ""
    }
  },
  {
    "text": "RiskyRisk =  0.1288\nRiskyReturn =  0.1791\nRiskyWts =  1×3\n0.0057    0.5879    0.4064\nRiskyFraction =  1.1869\nOverallRisk =  0.1529\nOverallReturn =  0.1902\nThe value of  RiskyFraction  exceeds  1  (100%), implying that the risk tolerance specified allows borrowing money to invest in the risky portfolio, and that no money is invested in the risk-free asset.\nPortfolio Selection and Risk Aversion\n3-9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 147,
      "section_heading": "Calling",
      "captions": ""
    }
  },
  {
    "text": "This borrowed capital is added to the original capital available for investment. In this example, the customer tolerates borrowing 18.69% of the original capital amount.\nSee Also portalloc  |  frontier  |  portopt  |  Portfolio  |  portcons  |  portvrisk  |  pcalims  |  pcgcomp  | pcglims  |  pcpval  |  abs2active  |  active2abs\nRelated Examples\n• “Portfolio Optimization Functions” on page 3-3\n• “Active Returns and Tracking Error Efficient Frontier” on page 3-27\n• “Plotting an Efficient Frontier Using portopt” on page 10-22\n• “portopt Migration to Portfolio Object” on page 3-11\nMore About\n• “Analyzing Portfolios” on page 3-2\n• “Portfolio Object Workflow” on page 4-18\n3 Portfolio Analysis\n3-10",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 148,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "portopt Migration to Portfolio Object\nIn this section...\n“Migrate portopt Without Output Arguments” on page 3-11\n“Migrate portopt with Output Arguments” on page 3-12\n“Migrate portopt for Target Returns Within Range of Efficient Portfolio Returns” on page 3-13\n“Migrate portopt for Target Return Outside Range of Efficient Portfolio Returns” on page 3-14\n“Migrate portopt Using portcons Output for ConSet” on page 3-15\n“Integrate Output from portcons, pcalims, pcglims, and pcgcomp with a Portfolio Object” on page 3- 17\nMigrate portopt Without Output Arguments\nThis example shows how to migrate  portopt  without output arguments to a Portfolio object.\nThe basic  portopt  functionality is represented as:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 149,
      "section_heading": "portopt Migration to Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "The basic  portopt  functionality is represented as:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nportopt(ExpReturn, ExpCovariance, NumPorts);\nTo migrate a  portopt  syntax without output arguments to a Portfolio object:\nportopt Migration to Portfolio Object\n3-11",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 149,
      "section_heading": "portopt Migration to Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "ExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setDefaultConstraints(p);\nplotFrontier(p, NumPorts);\nWithout output arguments,  portopt  plots the efficient frontier. The Portfolio object has similar behavior although the Portfolio object writes to the current figure window rather than create a new window each time a plot is generated.\nMigrate portopt with Output Arguments\nThis example shows how to migrate  portopt  with output arguments to a Portfolio object.\nWith output arguments, the basic functionality of  portopt  returns portfolio moments and weights. Once the Portfolio object is set up, moments and weights are obtained in separate steps.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 150,
      "section_heading": "Migrate portopt with Output Arguments",
      "captions": ""
    }
  },
  {
    "text": "With output arguments, the basic functionality of  portopt  returns portfolio moments and weights. Once the Portfolio object is set up, moments and weights are obtained in separate steps.\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;\n3 Portfolio Analysis\n3-12",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 150,
      "section_heading": "Migrate portopt with Output Arguments",
      "captions": ""
    }
  },
  {
    "text": "0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\n[PortRisk, PortReturn, PortWts] = portopt(ExpReturn, ExpCovariance, NumPorts);\ndisplay(PortWts);\nPortWts =\n0.2103    0.2746    0.1157    0.1594    0.2400     0.1744    0.2657    0.1296    0.2193    0.2110     0.1386    0.2567    0.1436    0.2791    0.1821     0.1027    0.2477    0.1575    0.3390    0.1532     0.0668    0.2387    0.1714    0.3988    0.1242     0.0309    0.2298    0.1854    0.4587    0.0953          0    0.2168    0.1993    0.5209    0.0629          0    0.1791    0.2133    0.5985    0.0091          0    0.0557    0.2183    0.7260         0          0         0         0    1.0000         0\nTo migrate a  portopt  syntax with output arguments:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 151,
      "section_heading": "Migrate portopt for Target Returns Within Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "To migrate a  portopt  syntax with output arguments:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setDefaultConstraints(p);\nPortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisplay(PortWts);\nPortWts =",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 151,
      "section_heading": "Migrate portopt for Target Returns Within Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "PortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisplay(PortWts);\nPortWts =\n0.2103    0.1744    0.1386    0.1027    0.0668    0.0309         0         0         0         0     0.2746    0.2657    0.2567    0.2477    0.2387    0.2298    0.2168    0.1791    0.0557         0     0.1157    0.1296    0.1436    0.1575    0.1714    0.1854    0.1993    0.2133    0.2183         0     0.1594    0.2193    0.2791    0.3390    0.3988    0.4587    0.5209    0.5985    0.7260    1.0000     0.2400    0.2110    0.1821    0.1532    0.1242    0.0953    0.0629    0.0091         0         0\nThe Portfolio object returns  PortWts  with portfolios going down columns, not across rows. Portfolio risks and returns are still in column format.\nMigrate portopt for Target Returns Within Range of Efficient Portfolio Returns\nThis example shows how to migrate  portopt  target returns within range of efficient portfolio returns to a Portfolio object.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 151,
      "section_heading": "Migrate portopt for Target Returns Within Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "This example shows how to migrate  portopt  target returns within range of efficient portfolio returns to a Portfolio object.\nportopt  can obtain portfolios with specific targeted levels of return but requires that the targeted returns fall within the range of efficient returns. The Portfolio object handles this by selecting portfolios at the ends of the efficient frontier.\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nportopt Migration to Portfolio Object\n3-13",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 151,
      "section_heading": "Migrate portopt for Target Returns Within Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "ExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nTargetReturn = [ 0.05; 0.06; 0.07; 0.08; 0.09 ];\n[PortRisk, PortReturn, PortWts] = portopt(ExpReturn, ExpCovariance, [], TargetReturn);\ndisp( ' Efficient    Target' ); disp([PortReturn, TargetReturn]);\nEfficient    Target     0.0500    0.0500     0.0600    0.0600     0.0700    0.0700     0.0800    0.0800     0.0900    0.0900\nTo migrate a  portopt  syntax for target returns within range of efficient portfolio returns to a Portfolio object:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 152,
      "section_heading": "Migrate portopt for Target Return Outside Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "To migrate a  portopt  syntax for target returns within range of efficient portfolio returns to a Portfolio object:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nTargetReturn = [ 0.05; 0.06; 0.07; 0.08; 0.09 ];\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setDefaultConstraints(p);\nPortWts = estimateFrontierByReturn(p, TargetReturn); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp( ' Efficient    Target' ); disp([PortReturn, TargetReturn]);\nEfficient    Target     0.0500    0.0500     0.0600    0.0600     0.0700    0.0700     0.0800    0.0800     0.0900    0.0900\nMigrate portopt for Target Return Outside Range of Efficient Portfolio Returns",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 152,
      "section_heading": "Migrate portopt for Target Return Outside Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "Migrate portopt for Target Return Outside Range of Efficient Portfolio Returns\nThis example shows how to migrate  portopt  target returns outside of range of efficient portfolio returns to a Portfolio object.\nWhen the target return is outside of the range of efficient portfolio returns,  portopt  generates an error. The Portfolio object handles this effectively by selecting portfolios at the ends of the efficient frontier.\n3 Portfolio Analysis\n3-14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 152,
      "section_heading": "Migrate portopt for Target Return Outside Range of Efficient Portfolio",
      "captions": ""
    }
  },
  {
    "text": "ExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nTargetReturn = [ 0.05; 0.06; 0.07; 0.08; 0.09; 0.10 ];\n[PortRisk, PortReturn, PortWts] = portopt(ExpReturn, ExpCovariance, [], TargetReturn);\ndisp( ' Efficient    Target' ); disp([PortReturn, TargetReturn]);\n> In portopt at 85  Error using portopt (line 297) One or more requested returns are greater than the maximum achievable return of 0.093400.\nTo migrate a  portopt  syntax for target returns outside of the range of efficient portfolio returns to a Portfolio object:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 153,
      "section_heading": "Migrate portopt Using portcons Output for ConSet",
      "captions": ""
    }
  },
  {
    "text": "To migrate a  portopt  syntax for target returns outside of the range of efficient portfolio returns to a Portfolio object:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nTargetReturn = [ 0.05; 0.06; 0.07; 0.08; 0.09; 0.10 ];\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setDefaultConstraints(p);\nPortWts = estimateFrontierByReturn(p, TargetReturn); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp( ' Efficient    Target' ); disp([PortReturn, TargetReturn]);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 153,
      "section_heading": "Migrate portopt Using portcons Output for ConSet",
      "captions": ""
    }
  },
  {
    "text": "PortWts = estimateFrontierByReturn(p, TargetReturn); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp( ' Efficient    Target' ); disp([PortReturn, TargetReturn]);\nWarning: One or more target return values are outside the feasible range [ 0.0427391, 0.0934 ].     Will return portfolios associated with endpoints of the range for these     values.  > In Portfolio/estimateFrontierByReturn (line 106)   Efficient    Target     0.0500    0.0500     0.0600    0.0600     0.0700    0.0700     0.0800    0.0800     0.0900    0.0900     0.0934    0.1000\nMigrate portopt Using portcons Output for ConSet\nThis example shows how to migrate  portopt  when the  ConSet  output from  portcons  is used with portopt .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 153,
      "section_heading": "Migrate portopt Using portcons Output for ConSet",
      "captions": ""
    }
  },
  {
    "text": "Migrate portopt Using portcons Output for ConSet\nThis example shows how to migrate  portopt  when the  ConSet  output from  portcons  is used with portopt .\nportopt  accepts as input the outputs from  portcons ,  pcalims ,  pcglims , and  pcgcomp . This example focuses on  portcons .  portcons  sets up linear constraints for  portopt  in the form  A*Port <= b . In a matrix  ConSet = [ A, b ]  and break into separate  A  and  b  arrays with  A = ConSet(:,1:end-1);  and  b = ConSet(:,end); . In addition, to illustrate default problem with additional group constraints, consider three groups. Assets 2, 3, and 4 can constitute up to 80% of portfolio, Assets 1 and 2 can constitute up to 70% of portfolio, and Assets 3, 4, and 5 can constitute up to 90% of portfolio.\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nportopt Migration to Portfolio Object\n3-15",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 153,
      "section_heading": "Migrate portopt Using portcons Output for ConSet",
      "captions": ""
    }
  },
  {
    "text": "ExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nGroups = [ 0 1 1 1 0; 1 1 0 0 0; 0 0 1 1 1 ]; GroupBounds = [ 0, 0.8; 0, 0.7; 0, 0.9 ];\nLowerGroup = GroupBounds(:,1); UpperGroup = GroupBounds(:,2);\nConSet = portcons( 'default' , 5,  'grouplims' , Groups, LowerGroup, UpperGroup);\n[PortRisk, PortReturn, PortWts] = portopt(ExpReturn, ExpCovariance, NumPorts, [], ConSet);\ndisp([PortRisk, PortReturn]);\nError using portopt (line 83) In the current and future releases, portopt will no longer accept ConSet or varargin arguments. 'It will only solve the portfolio problem for long-only fully-invested portfolios.     To solve more general problems, use the Portfolio object. See the release notes for details, including examples to make the conversion.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 154,
      "section_heading": "To migrate",
      "captions": ""
    }
  },
  {
    "text": "To migrate  portopt  to a Portfolio object when the  ConSet  output from  portcons  is used with portopt :\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nGroups = [ 0 1 1 1 0; 1 1 0 0 0; 0 0 1 1 1 ]; GroupBounds = [ 0, 0.8; 0, 0.7; 0, 0.9 ];\nLowerGroup = GroupBounds(:,1); UpperGroup = GroupBounds(:,2);\nConSet = portcons( 'default' , 5,  'grouplims' , Groups, LowerGroup, UpperGroup);\nA = ConSet(:,1:end-1); b = ConSet(:,end);\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setInequality(p, A, b);                     % implement group constraints here\nPortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp([PortRisk, PortReturn]);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 154,
      "section_heading": "To migrate",
      "captions": ""
    }
  },
  {
    "text": "PortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp([PortRisk, PortReturn]);\n0.1288    0.0427 0.1292    0.0465 0.1306    0.0503 0.1328    0.0540 0.1358    0.0578 0.1395    0.0615 0.1440    0.0653 0.1504    0.0690 0.1590    0.0728 0.1806    0.0766\n3 Portfolio Analysis\n3-16",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 154,
      "section_heading": "To migrate",
      "captions": ""
    }
  },
  {
    "text": "The constraints are entered directly into the Portfolio object with the  setInequality  or addInequality  functions.\nIntegrate Output from portcons, pcalims, pcglims, and pcgcomp with a Portfolio Object\nThis example shows how to integrate output from  pcalims ,  pcalims ,  pcglims , or  pcgcomp  with a Portfolio object implementation.\nportcons ,  pcalims ,  pcglims , and  pcgcomp  setup linear constraints for  portopt  in the form A*Port <= b . Although some functions permit two outputs, assume that the output is a single matrix  ConSet . Break into separate  A  and  b  arrays with:\n• A = ConSet(:,1:end-1);\n• b = ConSet(:,end);\nIn addition, to illustrate default problem with additional group constraints, consider three groups:\n• Assets 2, 3, and 4 can constitute up to 80% of portfolio.\n• Assets 1 and 2 can constitute up to 70% of portfolio.\n• Assets 3, 4, and 5 can constitute up to 90% of portfolio.\nGroups = [ 0 1 1 1 0; 1 1 0 0 0; 0 0 1 1 1 ]; GroupBounds = [ 0, 0.8; 0, 0.7; 0, 0.9 ];",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 155,
      "section_heading": "Integrate Output from portcons, pcalims, pcglims, and pcgcomp with",
      "captions": ""
    }
  },
  {
    "text": "• Assets 3, 4, and 5 can constitute up to 90% of portfolio.\nGroups = [ 0 1 1 1 0; 1 1 0 0 0; 0 0 1 1 1 ]; GroupBounds = [ 0, 0.8; 0, 0.7; 0, 0.9 ];\nTo integrate the  ConSet  output of  portcons  with a Portfolio object implementation:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nGroups = [ 0 1 1 1 0; 1 1 0 0 0; 0 0 1 1 1 ]; GroupBounds = [ 0, 0.8; 0, 0.7; 0, 0.9 ];\nLowerGroup = GroupBounds(:,1); UpperGroup = GroupBounds(:,2);\nConSet = portcons( 'default' , 5,  'grouplims' , Groups, LowerGroup, UpperGroup);\nA = ConSet(:,1:end-1); b = ConSet(:,end);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 155,
      "section_heading": "Integrate Output from portcons, pcalims, pcglims, and pcgcomp with",
      "captions": ""
    }
  },
  {
    "text": "LowerGroup = GroupBounds(:,1); UpperGroup = GroupBounds(:,2);\nConSet = portcons( 'default' , 5,  'grouplims' , Groups, LowerGroup, UpperGroup);\nA = ConSet(:,1:end-1); b = ConSet(:,end);\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setDefaultConstraints(p);                 % implement default constraints here p = setInequality(p, A, b);                     % implement group constraints here\nPortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp([PortRisk, PortReturn]);\n0.1288    0.0427     0.1292    0.0465     0.1306    0.0503     0.1328    0.0540     0.1358    0.0578     0.1395    0.0615\nportopt Migration to Portfolio Object\n3-17",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 155,
      "section_heading": "Integrate Output from portcons, pcalims, pcglims, and pcgcomp with",
      "captions": ""
    }
  },
  {
    "text": "0.1440    0.0653     0.1504    0.0690     0.1590    0.0728     0.1806    0.0766\nTo integrate the output of  pcalims  and  pcglims  with a Portfolio object implementation:\nExpReturn = [ 0.0054; 0.0531; 0.0779; 0.0934; 0.0130 ];\nExpCovariance = [ 0.0569,  0.0092,  0.0039,  0.0070,  0.0022;     0.0092,  0.0380,  0.0035,  0.0197,  0.0028;     0.0039,  0.0035,  0.0997,  0.0100,  0.0070;     0.0070,  0.0197,  0.0100,  0.0461,  0.0050;     0.0022,  0.0028,  0.0070,  0.0050,  0.0573 ];\nNumPorts = 10;\nGroups = [ 0 1 1 1 0; 1 1 0 0 0; 0 0 1 1 1 ]; GroupBounds = [ 0, 0.8; 0, 0.7; 0, 0.9 ];\nLowerGroup = GroupBounds(:,1); UpperGroup = GroupBounds(:,2);\nAssetMin = [ 0; 0; 0; 0; 0 ]; AssetMax = [ 0.8; 0.8; 0.8; 0.8; 0.8 ];\n[Aa, ba] = pcalims(AssetMin, AssetMax); [Ag, bg] = pcglims(Groups, LowerGroup, UpperGroup);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 156,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "AssetMin = [ 0; 0; 0; 0; 0 ]; AssetMax = [ 0.8; 0.8; 0.8; 0.8; 0.8 ];\n[Aa, ba] = pcalims(AssetMin, AssetMax); [Ag, bg] = pcglims(Groups, LowerGroup, UpperGroup);\np = Portfolio; p = setAssetMoments(p, ExpReturn, ExpCovariance); p = setDefaultConstraints(p);                 % implement default constraints first p = addInequality(p, Aa, ba);                 % implement bound constraints here p = addInequality(p, Ag, bg);                 % implement group constraints here\nPortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\ndisp([PortRisk, PortReturn]);\n0.1288    0.0427 0.1292    0.0465 0.1306    0.0503 0.1328    0.0540 0.1358    0.0578 0.1395    0.0615 0.1440    0.0653 0.1504    0.0690 0.1590    0.0728 0.1806    0.0766",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 156,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "disp([PortRisk, PortReturn]);\n0.1288    0.0427 0.1292    0.0465 0.1306    0.0503 0.1328    0.0540 0.1358    0.0578 0.1395    0.0615 0.1440    0.0653 0.1504    0.0690 0.1590    0.0728 0.1806    0.0766\nSee Also Portfolio  |  portopt  |  portcons  |  pcalims  |  pcglims  |  pcgcomp  |  estimatePortMoments  | setInequality  |  setDefaultConstraints  |  addInequality  |  setAssetMoments  | estimateFrontier  |  estimateFrontierByReturn\nMore About\n• “Portfolio Object Workflow” on page 4-18\n3 Portfolio Analysis\n3-18",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 156,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Constraint Specification Using a Portfolio Object\nWhen constructing the efficient frontier, several constraints are typically considered. You can use linear constraints that define the limits within which the portfolio optimization problem must operate and you can also use group constraints to limit the exposure to certain sectors or groups.\nConstraints for Efficient Frontier\nThis example shows how to compute the efficient frontier of portfolios consisting of three different assets, INTC, XON, and RD, given a list of constraints.\nThe expected returns for INTC, XON, and RD are respectively as follows:\nExpReturn = [0.1 0.2 0.15];\nThe covariance matrix is\nExpCovariance  =  [ 0.005   -0.010    0.004;                    -0.010    0.040   -0.002;                     0.004   -0.002    0.023];\n• Constraint 1:  Allow short selling up to 10% of the portfolio value in any asset, but limit the investment in any one asset to 110% of the portfolio value.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 157,
      "section_heading": "Constraint Specification Using a Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "• Constraint 1:  Allow short selling up to 10% of the portfolio value in any asset, but limit the investment in any one asset to 110% of the portfolio value.\n• Constraint 2:  Consider two different sectors, technology and energy, with the following table indicating the sector each asset belongs to.\nAsset INTC XON RD\nSector Technology Energy Energy\nConstrain the investment in the Energy sector to 80% of the portfolio value, and the investment in the Technology sector to 70%.To solve this problem, use  Portfolio , passing in a list of asset constraints. Consider eight different portfolios along the efficient frontier:\nNumPorts = 8;\nTo introduce the asset bounds constraints specified in  Constraint 1 , create the matrix AssetBounds , where each column represents an asset. The upper row represents the lower bounds, and the lower row represents the upper bounds. Since the bounds are the same for each asset, only one pair of bounds is needed because of scalar expansion.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 157,
      "section_heading": "Constraint Specification Using a Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "AssetBounds = [-0.1, 1.1];\nConstraint 2  must be entered in two parts, the first part defining the groups, and the second part defining the constraints for each group. Given the information above, you can build a matrix of  1 s and 0 s indicating whether a specific asset belongs to a group. Each column represents an asset, and each row represents a group. This example has two groups: the technology group, and the energy group. Create the matrix  Groups  as follows:\nGroups =  [0   1   1;             1   0   0];\nThe  GroupBounds  matrix allows you to specify an upper and lower bound for each group. Each row in this matrix represents a group. The first column represents the minimum allocation, and the\nConstraint Specification Using a Portfolio Object\n3-19",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 157,
      "section_heading": "Constraint Specification Using a Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "second column represents the maximum allocation to each group. Since the investment in the Energy sector is capped at 80% of the portfolio value, and the investment in the Technology sector is capped at 70%, create the  GroupBounds  matrix using this information.\nGroupBounds = [0   0.80;                0   0.70];\nUse the  Portfolio  object to obtain the vectors and arrays representing the risk, return, and weights for each of the eight portfolios computed along the efficient frontier. A budget constraint is added to ensure that the portfolio weights sum to  1 .\np = Portfolio( 'AssetMean' , ExpReturn,  'AssetCovar' , ExpCovariance); p = setBounds(p, AssetBounds(1), AssetBounds(2)); p = setBudget(p, 1, 1); p = setGroups(p, Groups, GroupBounds(:,1), GroupBounds(:,2));\nPortWts = estimateFrontier(p, NumPorts);\n[PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\nPortRisk\nPortRisk =  8×1\n0.0416     0.0499     0.0624     0.0767     0.0920     0.1100     0.1378     0.1716\nPortReturn",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 158,
      "section_heading": "second column represents the maximum allocation to each group. Since the investment in the Energy",
      "captions": ""
    }
  },
  {
    "text": "[PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\nPortRisk\nPortRisk =  8×1\n0.0416     0.0499     0.0624     0.0767     0.0920     0.1100     0.1378     0.1716\nPortReturn\nPortReturn =  8×1\n0.1279     0.1361     0.1442     0.1524     0.1605     0.1687     0.1768     0.1850\nPortWts\nPortWts =  3×8\n0.7000    0.6031    0.4864    0.3696    0.2529    0.2000    0.2000    0.2000     0.2582    0.3244    0.3708    0.4172    0.4636    0.5738    0.7369    0.9000     0.0418    0.0725    0.1428    0.2132    0.2835    0.2262    0.0631   -0.1000\nThe outputs are represented as columns for the portfolio's risk and return. Portfolio weights are identified as corresponding column vectors in a matrix.\n3 Portfolio Analysis\n3-20",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 158,
      "section_heading": "second column represents the maximum allocation to each group. Since the investment in the Energy",
      "captions": ""
    }
  },
  {
    "text": "Linear Constraint Equations\nThis example shows how to use the  Portfolio  object to specify the minimum and maximum investment in various groups.\nWhile the  Portfolio  object allows you to enter a fixed set of constraints related to minimum and maximum values for groups and individual assets, you often need to specify a larger and more general set of constraints when finding the optimal risky portfolio. Portfolio also addresses this need, by accepting an arbitrary set of constraints.\nMaximum and Minimum Group Exposure\nGroup Minimum Exposure Maximum Exposure\nNorth America 0.30 0.75\nEurope 0.10 0.55\nLatin America 0.20 0.50\nAsia 0.50 0.50\nThe minimum and maximum exposure in Asia is the same. This means that you require a fixed exposure for this group.\nAlso assume that the portfolio consists of three different funds. The correspondence between funds and groups is shown in the table below.\nGroup Membership\nGroup Fund 1 Fund 2 Fund 3\nNorth America X X\nEurope X\nLatin America X\nAsia X X",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 159,
      "section_heading": "Linear Constraint Equations",
      "captions": ""
    }
  },
  {
    "text": "Group Membership\nGroup Fund 1 Fund 2 Fund 3\nNorth America X X\nEurope X\nLatin America X\nAsia X X\nUsing the information in these two tables, build a mathematical representation of the constraints represented. Assume that the vector of weights representing the exposure of each asset in a portfolio is called  Wts = [W1 W2 W3] .\nSpecifically\n1. W 1 +  W 2 ≥ 0.30\n2. W 1 +  W 2 ≤ 0.75\n3. W 3 ≥ 0.10\n4. W 3 ≤ 0.55\n5. W 1 ≥ 0.20\n6. W 1 ≤ 0.50\n7. W 2 +  W 3 = 0.50\nConstraint Specification Using a Portfolio Object\n3-21",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 159,
      "section_heading": "Linear Constraint Equations",
      "captions": ""
    }
  },
  {
    "text": "Since you must represent the information in the form  A*Wts <= b , multiply equation numbers 1, 3 and 5 by –1. Also turn equation number 7 into a set of two inequalities:  W 2 +  W 3 ≥ 0.50 and  W 2 + W 3 ≤ 0.50. (The intersection of these two inequalities is the equality itself.) Thus\n1. -W 1 -  W 2 ≤ -0.30\n2. W 1 +  W 2 ≤ 0.75\n3. -W 3 ≤ -0.10\n4. W 3 ≤ 0.55\n5. -W 1 ≤ -0.20\n6. W 1 ≤ 0.50\n7. -W 2 -  W 3 ≤ -0.50\n8. W 2 +  W 3 ≤ 0.50\nBringing these equations into matrix notation gives the following:\nA = [-1    -1     0;       1     1     0;       0     0    -1;       0     0     1;      -1     0     0;       1     0     0;       0    -1    -1;       0     1     1]\nA =  8×3\n-1    -1     0      1     1     0      0     0    -1      0     0     1     -1     0     0      1     0     0      0    -1    -1      0     1     1\nb = [-0.30;       0.75;      -0.10;       0.55;      -0.20;       0.50;      -0.50;       0.50]\nb =  8×1\n-0.3000     0.7500    -0.1000     0.5500    -0.2000     0.5000",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 160,
      "section_heading": "Since you must represent the information in the form",
      "captions": ""
    }
  },
  {
    "text": "b = [-0.30;       0.75;      -0.10;       0.55;      -0.20;       0.50;      -0.50;       0.50]\nb =  8×1\n-0.3000     0.7500    -0.1000     0.5500    -0.2000     0.5000\n3 Portfolio Analysis\n3-22",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 160,
      "section_heading": "Since you must represent the information in the form",
      "captions": ""
    }
  },
  {
    "text": "-0.5000     0.5000\nOne approach to solving this portfolio problem is to explicitly use the  setInequality  function with a  Portfolio  object.\nExpReturn = [0.1 0.2 0.15]; ExpCovariance  =  [ 0.005   -0.010    0.004;                    -0.010    0.040   -0.002;                     0.004   -0.002    0.023]; NumPorts = 8; AssetBounds = [-0.1, 1.1];\np = Portfolio( 'AssetMean' , ExpReturn,  'AssetCovar' , ExpCovariance); p = setBounds(p, AssetBounds(1), AssetBounds(2)); p = setBudget(p, 1, 1); p = setInequality(p, A, b); PortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\nPortRisk\nPortRisk =  8×1\n0.0586     0.0586     0.0586     0.0586     0.0586     0.0586     0.0586     0.0586\nPortReturn\nPortReturn =  8×1\n0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375\nPortWts\nPortWts =  3×8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 161,
      "section_heading": "One approach to solving this portfolio problem is to explicitly use the",
      "captions": ""
    }
  },
  {
    "text": "PortReturn\nPortReturn =  8×1\n0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375\nPortWts\nPortWts =  3×8\n0.5000    0.5000    0.5000    0.5000    0.5000    0.5000    0.5000    0.5000     0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500     0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500\nIn this case, the constraints allow only one optimum portfolio. Since eight portfolios were requested, all eight portfolios are the same. Note that the solution to this portfolio problem using the\nConstraint Specification Using a Portfolio Object\n3-23",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 161,
      "section_heading": "One approach to solving this portfolio problem is to explicitly use the",
      "captions": ""
    }
  },
  {
    "text": "setInequality  function is the same as using the  setGroups  function in the example “Specifying Group Constraints” on page 3-24.\nSpecifying Group Constraints\nThis example shows how to solve a portfolo problem using a  Portfolio  object with group constraints.\nThe example “Linear Constraint Equations” on page 3-21 defines a constraint matrix that specifies a set of typical scenarios. It defines groups of assets, specifies upper and lower bounds for total allocation in each of these groups, and it sets the total allocation of one group to a fixed value. Constraints like these are common occurrences. The  Portfolio  object enables you to simplify the creation of the constraint matrix for these and other common portfolio requirements.\nAn alternative approach for solving the portfolio problem is to use the  Portfolio  object to define:\n• A  Group  matrix, indicating the assets that belong to each group.\n• A  GroupMin  vector, indicating the minimum bounds for each group.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 162,
      "section_heading": "Specifying Group Constraints",
      "captions": ""
    }
  },
  {
    "text": "• A  Group  matrix, indicating the assets that belong to each group.\n• A  GroupMin  vector, indicating the minimum bounds for each group.\n• A  GroupMax  vector, indicating the maximum bounds for each group.\nBased on the table Group Membership, build the Group  matrix , with each row representing a group, and each column representing an asset.\nGroup Membership\nGroup Fund 1 Fund 2 Fund 3\nNorth America X X\nEurope X\nLatin America X\nAsia X X\nGroup = [1    1    0;          0    0    1;          1    0    0;          0    1    1];\nThe table Maximum and Minimum Group Exposure has the information to build  GroupMin  and GroupMax .\nMaximum and Minimum Group Exposure\nGroup Minimum Exposure Maximum Exposure\nNorth America 0.30 0.75\nEurope 0.10 0.55\nLatin America 0.20 0.50\nAsia 0.50 0.50\nGroupMin = [0.30  0.10  0.20  0.50]; GroupMax = [0.75  0.55  0.50  0.50];\n3 Portfolio Analysis\n3-24",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 162,
      "section_heading": "Specifying Group Constraints",
      "captions": ""
    }
  },
  {
    "text": "Use the  Portfolio  object with the  setInequality  function to obtain the vectors and arrays representing the risk, return, and weights for the portfolios computed along the efficient frontier.\nExpReturn = [0.1 0.2 0.15]; ExpCovariance  =  [ 0.005   -0.010    0.004;                    -0.010    0.040   -0.002;                     0.004   -0.002    0.023]; NumPorts = 8; AssetBounds = [-0.1, 1.1];\np = Portfolio( 'AssetMean' , ExpReturn,  'AssetCovar' , ExpCovariance); p = setBounds(p, AssetBounds(1), AssetBounds(2)); p = setBudget(p, 1, 1); p = setGroups(p, Group, GroupMin, GroupMax); PortWts = estimateFrontier(p, NumPorts); [PortRisk, PortReturn] = estimatePortMoments(p, PortWts);\nPortRisk\nPortRisk =  8×1\n0.0586     0.0586     0.0586     0.0586     0.0586     0.0586     0.0586     0.0586\nPortReturn\nPortReturn =  8×1\n0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375\nPortWts\nPortWts =  3×8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 163,
      "section_heading": "Use the",
      "captions": ""
    }
  },
  {
    "text": "PortReturn\nPortReturn =  8×1\n0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375     0.1375\nPortWts\nPortWts =  3×8\n0.5000    0.5000    0.5000    0.5000    0.5000    0.5000    0.5000    0.5000     0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500     0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500    0.2500\nIn this case, the constraints allow only one optimum portfolio. Since eight portfolios were requested, all eight portfolios are the same. Note that the solution to this portfolio problem using the setGroups  function is the same as using the  setInequality  function in the example “Linear Constraint Equations” on page 3-21.\nConstraint Specification Using a Portfolio Object\n3-25",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 163,
      "section_heading": "Use the",
      "captions": ""
    }
  },
  {
    "text": "See Also Portfolio  |  estimateFrontier  |  estimatePortMoments  |  setInequality  |  setGroups\nRelated Examples\n• “Setting Default Constraints for Portfolio Weights Using Portfolio Object” on page 4-58\n• “Working with 'Simple' Bound Constraints Using Portfolio Object” on page 4-62\n• “Working with Budget Constraints Using Portfolio Object” on page 4-65\n• “Working with Group Constraints Using Portfolio Object” on page 4-69\n• “Working with Group Ratio Constraints Using Portfolio Object” on page 4-72\n• “Working with Linear Equality Constraints Using Portfolio Object” on page 4-75\n• “Working with Linear Inequality Constraints Using Portfolio Object” on page 4-78\n• “Working with Average Turnover Constraints Using Portfolio Object” on page 4-85\n• “Working with One-Way Turnover Constraints Using Portfolio Object” on page 4-88\n• “Working with Tracking Error Constraints Using Portfolio Object” on page 4-91\n• “Asset Allocation Case Study” on page 4-180",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 164,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "• “Working with Tracking Error Constraints Using Portfolio Object” on page 4-91\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\nMore About\n• Supported Constraints for Portfolio Optimization Using Portfolio Objects on page 4-9\n• “Portfolio Object Workflow” on page 4-18\n• “Setting Up a Tracking Portfolio” on page 4-40\n3 Portfolio Analysis\n3-26",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 164,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Active Returns and Tracking Error Efficient Frontier\nThis example shows how to minimize the variance of the difference in returns with respect to a given target portfolio.\nSuppose that you want to identify an efficient set of portfolios that minimize the variance of the difference in returns with respect to a given target portfolio, subject to a given expected excess return. The mean and standard deviation of this excess return are often called the  active return  and active risk , respectively. Active risk is sometimes referred to as the tracking error. Since the objective is to track a given target portfolio as closely as possible, the resulting set of portfolios is sometimes referred to as the  tracking error efficient frontier .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 165,
      "section_heading": "Active Returns and Tracking Error Efficient Frontier",
      "captions": ""
    }
  },
  {
    "text": "Specifically, assume that the target portfolio is expressed as an index weight vector, such that the index return series may be expressed as a linear combination of the available assets. This example illustrates how to construct a frontier that minimizes the active risk (tracking error) subject to attaining a given level of return. That is, it computes the tracking error efficient frontier.\nOne way to construct the tracking error efficient frontier is to explicitly form the target return series and subtract it from the return series of the individual assets. In this manner, you specify the expected mean and covariance of the active returns, and compute the efficient frontier subject to the usual portfolio constraints.\nThis example works directly with the mean and covariance of the absolute (unadjusted) returns but converts the constraints from the usual absolute weight format to active weight format.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 165,
      "section_heading": "Active Returns and Tracking Error Efficient Frontier",
      "captions": ""
    }
  },
  {
    "text": "This example works directly with the mean and covariance of the absolute (unadjusted) returns but converts the constraints from the usual absolute weight format to active weight format.\nConsider a portfolio of five assets with the following expected returns, standard deviations, and correlation matrix based on absolute weekly asset returns.\nNumAssets    =  5;\nExpReturn    = [0.2074  0.1971  0.2669  0.1323  0.2535]/100;\nSigmas       = [2.6570  3.6297  3.9916  2.7145  2.6133]/100;\nCorrelations = [1.0000  0.6092  0.6321  0.5833  0.7304                 0.6092  1.0000  0.8504  0.8038  0.7176                 0.6321  0.8504  1.0000  0.7723  0.7236                 0.5833  0.8038  0.7723  1.0000  0.7225                 0.7304  0.7176  0.7236  0.7225  1.0000];\nConvert the correlations and standard deviations to a covariance matrix using  corr2cov .\nExpCovariance = corr2cov(Sigmas, Correlations);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 165,
      "section_heading": "Active Returns and Tracking Error Efficient Frontier",
      "captions": ""
    }
  },
  {
    "text": "Convert the correlations and standard deviations to a covariance matrix using  corr2cov .\nExpCovariance = corr2cov(Sigmas, Correlations);\nAssume that the target index portfolio is an equally weighted portfolio formed from the five assets. The sum of index weights equals 1, satisfying the standard full investment budget equality constraint.\nIndex = ones(NumAssets, 1)/NumAssets;\nGenerate an asset constraint matrix using  portcons . The constraint matrix  AbsConSet  is expressed in absolute format (unadjusted for the index), and is formatted as  [A b] , corresponding to constraints of the form  A*w <= b . Each row of  AbsConSet  corresponds to a constraint, and each column corresponds to an asset. Allow no short-selling and full investment in each asset (lower and upper bounds of each asset are 0 and 1, respectively). In particular, note that the first two rows\nActive Returns and Tracking Error Efficient Frontier\n3-27",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 165,
      "section_heading": "Active Returns and Tracking Error Efficient Frontier",
      "captions": ""
    }
  },
  {
    "text": "correspond to the budget equality constraint; the remaining rows correspond to the upper/lower investment bounds.\nAbsConSet = portcons( 'PortValue' , 1, NumAssets,  ...   'AssetLims' , zeros(NumAssets,1), ones(NumAssets,1));\nTransform the absolute constraints to active constraints with  abs2active .\nActiveConSet = abs2active(AbsConSet, Index);\nAn examination of the absolute and active constraint matrices reveals that they differ only in the last column (the columns corresponding to the  b  in  A*w <= b .\n[AbsConSet(:,end)  ActiveConSet(:,end)]\nans =  12×2\n1.0000         0    -1.0000         0     1.0000    0.8000     1.0000    0.8000     1.0000    0.8000     1.0000    0.8000     1.0000    0.8000          0    0.2000          0    0.2000          0    0.2000          0    0.2000          0    0.2000        ⋮\nIn particular, note that the sum-to-one absolute budget constraint becomes a sum-to-zero active budget constraint. The general transformation is as follows:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 166,
      "section_heading": "correspond to the budget equality constraint; the remaining rows correspond to the upper/lower",
      "captions": ""
    }
  },
  {
    "text": "In particular, note that the sum-to-one absolute budget constraint becomes a sum-to-zero active budget constraint. The general transformation is as follows:\nConstruct the  Portfolio  object and plot the tracking error efficient frontier with 21 portfolios.\np = Portfolio( 'AssetMean' , ExpReturn,  'AssetCovar' , ExpCovariance); p = p.setInequality(ActiveConSet(:,1:end-1), ActiveConSet(:,end)); [ActiveRisk, ActiveReturn] = p.plotFrontier(21);\n3 Portfolio Analysis\n3-28",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 166,
      "section_heading": "correspond to the budget equality constraint; the remaining rows correspond to the upper/lower",
      "captions": ""
    }
  },
  {
    "text": "plot(ActiveRisk*100, ActiveReturn*100,  'blue' ) grid( 'on' ) xlabel( 'Active Risk (Standard Deviation in Percent)' ) ylabel( 'Active Return (Percent)' ) title( 'Tracking Error Efficient Frontier' )\nOf particular interest is the lower-left portfolio along the frontier. This zero-risk/zero-return portfolio has a practical economic significance. It represents a full investment in the index portfolio itself. Each\nActive Returns and Tracking Error Efficient Frontier\n3-29",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 167,
      "section_heading": "Of particular interest is the lower-left portfolio along the frontier. This zero-risk/zero-return portfolio",
      "captions": ""
    }
  },
  {
    "text": "tracking error efficient portfolio (each row in the array  ActiveWeights ) satisfies the active budget constraint, and thus represents portfolio investment allocations with respect to the index portfolio. To convert these allocations to absolute investment allocations, add the index to each efficient portfolio.\nActiveWeights = p.estimateFrontier(21)\nActiveWeights =  5×21\n-0.0000   -0.0038   -0.0075   -0.0113   -0.0151   -0.0188   -0.0226   -0.0264   -0.0302   -0.0     0.0000   -0.0026   -0.0052   -0.0078   -0.0104   -0.0130   -0.0156   -0.0182   -0.0209   -0.0     0.0000    0.0093    0.0186    0.0279    0.0372    0.0465    0.0559    0.0652    0.0745    0.0    -0.0000   -0.0192   -0.0384   -0.0576   -0.0768   -0.0960   -0.1152   -0.1344   -0.1536   -0.1     0.0000    0.0163    0.0325    0.0488    0.0651    0.0814    0.0976    0.1139    0.1302    0.1\nAbsoluteWeights = ActiveWeights + repmat(Index, 1, 21)\nAbsoluteWeights =  5×21",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 168,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "AbsoluteWeights = ActiveWeights + repmat(Index, 1, 21)\nAbsoluteWeights =  5×21\n0.2000    0.1962    0.1925    0.1887    0.1849    0.1812    0.1774    0.1736    0.1698    0.1     0.2000    0.1974    0.1948    0.1922    0.1896    0.1870    0.1844    0.1818    0.1791    0.1     0.2000    0.2093    0.2186    0.2279    0.2372    0.2465    0.2559    0.2652    0.2745    0.2     0.2000    0.1808    0.1616    0.1424    0.1232    0.1040    0.0848    0.0656    0.0464    0.0     0.2000    0.2163    0.2325    0.2488    0.2651    0.2814    0.2976    0.3139    0.3302    0.3\nSee Also portalloc  |  frontier  |  Portfolio  |  portcons  |  portvrisk  |  pcalims  |  pcgcomp  |  pcglims  | pcpval  |  abs2active  |  active2abs  |  plotFrontier  |  setInequality  |  estimateFrontier\nRelated Examples\n• “Portfolio Optimization Functions” on page 3-3\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “Plotting an Efficient Frontier Using portopt” on page 10-22\nMore About",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 168,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Related Examples\n• “Portfolio Optimization Functions” on page 3-3\n• “Portfolio Selection and Risk Aversion” on page 3-7\n• “Plotting an Efficient Frontier Using portopt” on page 10-22\nMore About\n• “Analyzing Portfolios” on page 3-2\n• “Portfolio Object Workflow” on page 4-18\n3 Portfolio Analysis\n3-30",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 168,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Mean-Variance Portfolio Optimization Tools\n• “Portfolio Optimization Theory” on page 4-4\n• “Supported Constraints for Portfolio Optimization Using Portfolio Objects” on page 4-9\n• “Default Portfolio Problem” on page 4-17\n• “Portfolio Object Workflow” on page 4-18\n• “Portfolio Object” on page 4-20\n• “Creating the Portfolio Object” on page 4-25\n• “Common Operations on the Portfolio Object” on page 4-33\n• “Setting Up an Initial or Current Portfolio” on page 4-37\n• “Setting Up a Tracking Portfolio” on page 4-40\n• “Asset Returns and Moments of Asset Returns Using Portfolio Object” on page 4-42\n• “Working with a Riskless Asset” on page 4-52\n• “Working with Transaction Costs” on page 4-54\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Working with 'Simple' Bound Constraints Using Portfolio Object” on page 4-62\n• “Working with Budget Constraints Using Portfolio Object” on page 4-65\n• “Working with Conditional Budget Constraints Using Portfolio Object” on page 4-67",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 169,
      "section_heading": "Mean-Variance Portfolio Optimization",
      "captions": ""
    }
  },
  {
    "text": "• “Working with Budget Constraints Using Portfolio Object” on page 4-65\n• “Working with Conditional Budget Constraints Using Portfolio Object” on page 4-67\n• “Working with Group Constraints Using Portfolio Object” on page 4-69\n• “Working with Group Ratio Constraints Using Portfolio Object” on page 4-72\n• “Working with Linear Equality Constraints Using Portfolio Object” on page 4-75\n• “Working with Linear Inequality Constraints Using Portfolio Object” on page 4-78\n• “Working with 'Conditional' BoundType, MinNumAssets, and MaxNumAssets Constraints Using Portfolio Objects” on page 4-81\n• “Working with Average Turnover Constraints Using Portfolio Object” on page 4-85\n• “Working with One-Way Turnover Constraints Using Portfolio Object” on page 4-88\n• “Working with Tracking Error Constraints Using Portfolio Object” on page 4-91\n• “Validate the Portfolio Problem for Portfolio Object” on page 4-94",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 169,
      "section_heading": "Mean-Variance Portfolio Optimization",
      "captions": ""
    }
  },
  {
    "text": "• “Working with Tracking Error Constraints Using Portfolio Object” on page 4-91\n• “Validate the Portfolio Problem for Portfolio Object” on page 4-94\n• “Estimate Efficient Portfolios for Entire Efficient Frontier for Portfolio Object” on page 4-98\n• “Obtaining Portfolios Along the Entire Efficient Frontier” on page 4-99\n• “Obtaining Endpoints of the Efficient Frontier” on page 4-102\n• “Obtaining Efficient Portfolios for Target Returns” on page 4-105\n• “Obtaining Efficient Portfolios for Target Risks” on page 4-108\n• “Efficient Portfolio That Maximizes Sharpe Ratio” on page 4-111\n• “Choosing and Controlling the Solver for Mean-Variance Portfolio Optimization” on page 4-114\n4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 169,
      "section_heading": "Mean-Variance Portfolio Optimization",
      "captions": ""
    }
  },
  {
    "text": "• “Estimate Efficient Frontiers for Portfolio Object” on page 4-122\n• “Plotting the Efficient Frontier for a Portfolio Object” on page 4-125\n• “Postprocessing Results to Set Up Tradable Portfolios” on page 4-130\n• “When to Use Portfolio Objects Over Optimization Toolbox” on page 4-132\n• “Comparison of Methods for Covariance Estimation” on page 4-138\n• “Choose MINLP Solvers for Portfolio Problems” on page 4-140\n• “Troubleshooting Portfolio Optimization Results” on page 4-145\n• “Role of Convexity in Portfolio Problems” on page 4-157\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Portfolio Optimization Against a Benchmark” on page 4-202\n• “Portfolio Analysis with Turnover Constraints” on page 4-211\n• “Leverage in Portfolio Optimization with a Risk-Free Asset” on page 4-217",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 170,
      "section_heading": "“Estimate Efficient Frontiers for Portfolio Object” on page 4-122",
      "captions": ""
    }
  },
  {
    "text": "• “Portfolio Optimization Against a Benchmark” on page 4-202\n• “Portfolio Analysis with Turnover Constraints” on page 4-211\n• “Leverage in Portfolio Optimization with a Risk-Free Asset” on page 4-217\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222\n• “Portfolio Optimization Using Factor Models” on page 4-231\n• “Backtest Investment Strategies Using Financial Toolbox” on page 4-238\n• “Backtest Investment Strategies with Trading Signals” on page 4-251\n• “Portfolio Optimization Using Social Performance Measure” on page 4-264\n• “Diversify ESG Portfolios” on page 4-271\n• “Risk Budgeting Portfolio” on page 4-286\n• “Backtest Using Risk-Based Equity Indexation” on page 4-291\n• “Create Hierarchical Risk Parity Portfolio” on page 4-296\n• “Backtest Strategies Using Deep Learning” on page 4-302\n• “Backtest with Brinson Attribution to Evaluate Portfolio Performance” on page 4-315\n• “Analyze Performance Attribution Using Brinson Model” on page 4-323",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 170,
      "section_heading": "“Estimate Efficient Frontiers for Portfolio Object” on page 4-122",
      "captions": ""
    }
  },
  {
    "text": "• “Backtest with Brinson Attribution to Evaluate Portfolio Performance” on page 4-315\n• “Analyze Performance Attribution Using Brinson Model” on page 4-323\n• “Diversify Portfolios Using Custom Objective” on page 4-331\n• “Solve Tracking Error Portfolio Problems” on page 4-343\n• “Solve Problem for Minimum Tracking Error with Net Return Constraint” on page 4-349\n• “Solve Robust Portfolio Maximum Return Problem with Ellipsoidal Uncertainty” on page 4-351\n• “Risk Parity or Budgeting with Constraints” on page 4-357\n• “Single Period Goal-Based Wealth Management” on page 4-362\n• “Dynamic Portfolio Allocation in Goal-Based Wealth Management for Multiple Time Periods” on page 4-367\n• “Multiperiod Goal-Based Wealth Management Using Reinforcement Learning” on page 4-379\n• “Compare Performance of Covariance Denoising with Factor Modeling Using Backtesting” on page 4-394\n• “Mixed-Integer Mean-Variance Portfolio Optimization Problem” on page 4-402",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 170,
      "section_heading": "“Estimate Efficient Frontiers for Portfolio Object” on page 4-122",
      "captions": ""
    }
  },
  {
    "text": "• “Compare Performance of Covariance Denoising with Factor Modeling Using Backtesting” on page 4-394\n• “Mixed-Integer Mean-Variance Portfolio Optimization Problem” on page 4-402\n• “Deep Reinforcement Learning for Optimal Trade Execution” on page 4-407\n4 Mean-Variance Portfolio Optimization Tools\n4-2",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 170,
      "section_heading": "“Estimate Efficient Frontiers for Portfolio Object” on page 4-122",
      "captions": ""
    }
  },
  {
    "text": "• “Backtest Investment Strategies Using datetime and calendarDuration” on page 4-451\n• “Adding Constraints to Satisfy UCITS Directive” on page 4-457\nActive Returns and Tracking Error Efficient Frontier\n4-3",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 171,
      "section_heading": "“Backtest Investment Strategies Using datetime and calendarDuration” on page 4-451",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Optimization Theory\nIn this section...\n“Portfolio Optimization Problems” on page 4-4\n“Portfolio Problem Specification” on page 4-4\n“Return Proxy” on page 4-5\n“Risk Proxy” on page 4-6\nPortfolio Optimization Problems\nPortfolio optimization problems involve identifying portfolios that satisfy three criteria:\n• Minimize a proxy for risk.\n• Match or exceed a proxy for return.\n• Satisfy basic feasibility requirements.\nPortfolios are points from a feasible set of assets that constitute an asset universe. A portfolio specifies either holdings or weights in each individual asset in the asset universe. The convention is to specify portfolios in terms of weights, although the portfolio optimization tools work with holdings as well.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 172,
      "section_heading": "Portfolio Optimization Theory",
      "captions": ""
    }
  },
  {
    "text": "The set of feasible portfolios is necessarily a nonempty, closed, and bounded set. The proxy for risk is a function that characterizes either the variability or losses associated with portfolio choices. The proxy for return is a function that characterizes either the gross or net benefits associated with portfolio choices. The terms “risk” and “risk proxy” and “return” and “return proxy” are interchangeable. The fundamental insight of Markowitz (see “Portfolio Optimization” on page A-5) is that the goal of the portfolio choice problem is to seek minimum risk for a given level of return and to seek maximum return for a given level of risk. Portfolios satisfying these criteria are efficient portfolios and the graph of the risks and returns of these portfolios forms a curve called the efficient frontier.\nPortfolio Problem Specification\nTo specify a portfolio optimization problem, you need the following:\n• Proxy for portfolio return ( μ )\n• Proxy for portfolio risk ( σ )",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 172,
      "section_heading": "Portfolio Optimization Theory",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Problem Specification\nTo specify a portfolio optimization problem, you need the following:\n• Proxy for portfolio return ( μ )\n• Proxy for portfolio risk ( σ )\n• Set of feasible portfolios ( X ), called a portfolio set\nFinancial Toolbox has three objects to solve specific types of portfolio optimization problems:\n• The  Portfolio  object supports mean-variance portfolio optimization (see Markowitz [46], [47] at “Portfolio Optimization” on page A-5). This object has either gross or net portfolio returns as the return proxy, the variance of portfolio returns as the risk proxy, and a portfolio set that is any combination of the specified constraints to form a portfolio set.\n• The  PortfolioCVaR  object implements what is known as conditional value-at-risk portfolio optimization (see Rockafellar and Uryasev [48], [49] at “Portfolio Optimization” on page A-5), which is referred to as CVaR portfolio optimization. CVaR portfolio optimization works with the",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 172,
      "section_heading": "Portfolio Optimization Theory",
      "captions": ""
    }
  },
  {
    "text": "4 Mean-Variance Portfolio Optimization Tools\n4-4",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 172,
      "section_heading": "Portfolio Optimization Theory",
      "captions": ""
    }
  },
  {
    "text": "same return proxies and portfolio sets as mean-variance portfolio optimization but uses conditional value-at-risk of portfolio returns as the risk proxy.\n• The  PortfolioMAD  object implements what is known as mean-absolute deviation portfolio optimization (see Konno and Yamazaki [50] at “Portfolio Optimization” on page A-5), which is referred to as MAD portfolio optimization. MAD portfolio optimization works with the same return proxies and portfolio sets as mean-variance portfolio optimization but uses mean-absolute deviation portfolio returns as the risk proxy.\nReturn Proxy\nThe proxy for portfolio return is a function  μ :  X R  on a portfolio set  X  ⊂ R n  that characterizes the rewards associated with portfolio choices. Usually, the proxy for portfolio return has two general forms, gross and net portfolio returns. Both portfolio return forms separate the risk-free rate  r 0  so that the portfolio  x  ∈ X  contains only risky assets.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 173,
      "section_heading": "Return Proxy",
      "captions": ""
    }
  },
  {
    "text": "Regardless of the underlying distribution of asset returns, a collection of  S  asset returns  y 1 ,..., y S  has a mean of asset returns\nm  =  1 S   ∑ s  = 1\nS y s ,\nand (sample) covariance of asset returns\nC  = 1 S  −1   ∑ s  = 1\nS ( y s  − m )( y s  − m ) T   .\nThese moments (or alternative estimators that characterize these moments) are used directly in mean-variance portfolio optimization to form proxies for portfolio risk and return.\nGross Portfolio Returns\nThe gross portfolio return for a portfolio  x  ∈ X  is\nμ ( x ) =  r 0  + ( m  − r 0 1) T x ,\nwhere:\nr 0  is the risk-free rate (scalar).\nm  is the mean of asset returns ( n  vector).\nIf the portfolio weights sum to  1 , the risk-free rate is irrelevant. The properties in the  Portfolio object to specify gross portfolio returns are:\n• RiskFreeRate  for  r 0 • AssetMean  for  m\nNet Portfolio Returns\nThe net portfolio return for a portfolio  x  ∈ X  is",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 173,
      "section_heading": "Return Proxy",
      "captions": ""
    }
  },
  {
    "text": "• RiskFreeRate  for  r 0 • AssetMean  for  m\nNet Portfolio Returns\nThe net portfolio return for a portfolio  x  ∈ X  is\nμ ( x ) =  r 0  + ( m  − r 0 1) T x  − b T max 0,  x  − x 0  − s T max 0,  x 0  − x  ,\nPortfolio Optimization Theory\n4-5",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 173,
      "section_heading": "Return Proxy",
      "captions": ""
    }
  },
  {
    "text": "where:\nr 0  is the risk-free rate (scalar).\nm  is the mean of asset returns ( n  vector).\nb  is the proportional cost to purchase assets ( n  vector).\ns  is the proportional cost to sell assets ( n  vector).\nYou can incorporate fixed transaction costs in this model also. Though in this case, it is necessary to incorporate prices into such costs. The properties in the  Portfolio  object to specify net portfolio returns are:\n• RiskFreeRate  for  r 0 • AssetMean  for  m\n• InitPort  for  x 0 • BuyCost  for  b\n• SellCost  for  s\nRisk Proxy\nThe proxy for portfolio risk is a function  σ :  X R  on a portfolio set  X  ⊂ R n  that characterizes the risks associated with portfolio choices.\nMean Variance\nThe mean variance of portfolio returns for a portfolio  x  ∈ X  is\nVariance x  =  x T Cx\nwhere  C  is the covariance of asset returns ( n -by- n  positive-semidefinite matrix).\nThe property in the  Portfolio  object to specify the variance of portfolio returns is  AssetCovar  for C .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 174,
      "section_heading": "Risk Proxy",
      "captions": ""
    }
  },
  {
    "text": "where  C  is the covariance of asset returns ( n -by- n  positive-semidefinite matrix).\nThe property in the  Portfolio  object to specify the variance of portfolio returns is  AssetCovar  for C .\nAlthough the risk proxy in mean-variance portfolio optimization is the variance of portfolio returns, the square root, which is the standard deviation of portfolio returns, is often reported and displayed. Moreover, this quantity is often called the “risk” of the portfolio. For details, see Markowitz (“Portfolio Optimization” on page A-5).\nConditional Value-at-Risk\nThe conditional value-at-risk for a portfolio  x  ∈ X , which is also known as expected shortfall, is defined as\nCVaR α  x  = 1 1 − α ∫ f ( x ,  y ) ≥ VaRα ( x ) f ( x ,  y ) p ( y ) dy ,\nwhere:\nα  is the probability level such that  0  <  α  <  1 .\n4 Mean-Variance Portfolio Optimization Tools\n4-6",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 174,
      "section_heading": "Risk Proxy",
      "captions": ""
    }
  },
  {
    "text": "f(x,y)  is the loss function for a portfolio  x  and asset return  y .\np(y)  is the probability density function for asset return  y .\nVaR α  is the value-at-risk of portfolio  x  at probability level  α .\nThe value-at-risk is defined as\nVaR α  x  = min  γ :Pr  f ( x ,  Y ) ≤ γ  ≥ α  .\nAn alternative formulation for CVaR has the form:\nCVaR α ( x ) =  VaR α  x  + 1 1 − α   ∫\nR n max 0, ( f ( x ,  y ) − VaR α ( x ))  p ( y ) dy\nThe choice for the probability level  α  is typically 0.9 or 0.95. Choosing  α  implies that the value-at-risk VaR α (x)  for portfolio  x  is the portfolio return such that the probability of portfolio returns falling below this level is ( 1  – α ). Given  VaR α (x)  for a portfolio  x , the conditional value-at-risk of the portfolio is the expected loss of portfolio returns above the value-at-risk return.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 175,
      "section_heading": "f(x,y)",
      "captions": ""
    }
  },
  {
    "text": "Note  Value-at-risk is a positive value for losses so that the probability level  α  indicates the probability that portfolio returns are below the negative of the value-at-risk.\nTo describe the probability distribution of returns, the  PortfolioCVaR  object takes a finite sample of return scenarios  y s , with  s  =  1 ,..., S . Each  y s  is an  n  vector that contains the returns for each of the n  assets under the scenario  s . This sample of  S  scenarios is stored as a scenario matrix of size  S -by- n . Then, the risk proxy for CVaR portfolio optimization, for a given portfolio  x  ∈ X  and  α  ∈(0, 1), is computed as\nCVaR α ( x ) =  VaR α ( x ) + 1 (1 − α ) S   ∑ s  = 1\nS max 0, − y s T x  − VaR α ( x )\nThe value-at-risk,  VaR α ( x ), is estimated whenever the CVaR is estimated. The loss function is\nf ( x ,  y s ) = − y s T x , which is the portfolio loss under scenario  s .",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 175,
      "section_heading": "f(x,y)",
      "captions": ""
    }
  },
  {
    "text": "The value-at-risk,  VaR α ( x ), is estimated whenever the CVaR is estimated. The loss function is\nf ( x ,  y s ) = − y s T x , which is the portfolio loss under scenario  s .\nUnder this definition, VaR and CVaR are sample estimators for VaR and CVaR based on the given scenarios. Better scenario samples yield more reliable estimates of VaR and CVaR.\nFor more information, see Rockafellar and Uryasev [48], [49], and Cornuejols and Tütüncü, [51], at “Portfolio Optimization” on page A-5.\nMean Absolute-Deviation\nThe mean-absolute-deviation (MAD) for a portfolio  x  ∈ X  is defined as\nMAD ( x ) =  1 S   ∑ s  = 1\nS\n( y s  − m ) T x\nwhere:\ny s  are asset returns with scenarios  s  = 1,... S  ( S  collection of  n  vectors).\nPortfolio Optimization Theory\n4-7",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 175,
      "section_heading": "f(x,y)",
      "captions": ""
    }
  },
  {
    "text": "f(x,y)  is the loss function for a portfolio  x  and asset return  y .\nm  is the mean of asset returns ( n  vector).\nsuch that\nm  =  1 S   ∑ s  = 1\nS y s\nFor more information, see Konno and Yamazaki [50] at “Portfolio Optimization” on page A-5.\nSee Also Portfolio  |  PortfolioCVaR  |  PortfolioMAD\nRelated Examples\n• “Creating the Portfolio Object” on page 4-25\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\nMore About\n• Portfolio\n• “Portfolio Object Workflow” on page 4-18\n• Supported Constraints for Portfolio Optimization Using Portfolio Objects on page 4-9\n• “Default Portfolio Problem” on page 4-17\n• “Role of Convexity in Portfolio Problems” on page 4-157\nExternal Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 176,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "External Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)\n4 Mean-Variance Portfolio Optimization Tools\n4-8",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 176,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "Supported Constraints for Portfolio Optimization Using Portfolio Objects\nThe final element for a complete specification of a portfolio optimization problem is the set of feasible\nportfolios, which is called a portfolio set. A portfolio set  X  ⊂ R n  is specified by construction as the intersection of sets formed by a collection of constraints on portfolio weights. A portfolio set necessarily and sufficiently must be a nonempty, closed, and bounded set.\nWhen setting up your portfolio set, ensure that the portfolio set satisfies these conditions. The most basic or “default” portfolio set requires portfolio weights to be nonnegative (using the lower-bound constraint) and to sum to  1  (using the budget constraint). The most general portfolio set handled by the portfolio optimization tools ( Portfolio ,  PortfolioCVaR , and  PortfolioMAD  objects) can have any of these constraints:\n• Linear inequality constraints\n• Linear equality constraints\n• 'Simple'  Bound constraints",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 177,
      "section_heading": "Supported Constraints for Portfolio Optimization Using",
      "captions": ""
    }
  },
  {
    "text": "• Linear inequality constraints\n• Linear equality constraints\n• 'Simple'  Bound constraints\n• 'Conditional'  Bound constraints\n• Budget constraints\n• Conditional budget constraints\n• Group constraints\n• Group ratio constraints\n• Average turnover constraints\n• One-way turnover constraints\n• Tracking error constraints (only for  Portfolio  object)\n• Cardinality constraints\nLinear Inequality Constraints\nLinear inequality constraints are general linear constraints that model relationships among portfolio weights that satisfy a system of inequalities. Use  setInequality  to set linear inequality constraints. Linear inequality constraints take the form\nA I x  ≤ b I\nwhere:\nx  is the portfolio ( n  vector).\nA I  is the linear inequality constraint matrix ( n I -by- n  matrix).\nb I  is the linear inequality constraint vector ( n I  vector).\nn  is the number of assets in the universe and  n I  is the number of constraints.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 177,
      "section_heading": "Supported Constraints for Portfolio Optimization Using",
      "captions": ""
    }
  },
  {
    "text": "b I  is the linear inequality constraint vector ( n I  vector).\nn  is the number of assets in the universe and  n I  is the number of constraints.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify linear inequality constraints are:\nSupported Constraints for Portfolio Optimization Using Portfolio Objects\n4-9",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 177,
      "section_heading": "Supported Constraints for Portfolio Optimization Using",
      "captions": ""
    }
  },
  {
    "text": "• AInequality  for  A I • bInequality  for  b I • NumAssets  for  n\nThe default is to ignore these constraints.\nLinear Equality Constraints\nLinear equality constraints are general linear constraints that model relationships among portfolio weights that satisfy a system of equalities. Use  setEquality  to set linear equality constraints. Linear equality constraints take the form\nA E x  =  b E\nwhere:\nx  is the portfolio ( n  vector).\nA E  is the linear equality constraint matrix ( n E -by- n  matrix).\nb E  is the linear equality constraint vector ( n E  vector).\nn  is the number of assets in the universe and  n E  is the number of constraints.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify linear equality constraints are:\n• AEquality  for  A E • bEquality  for  b E • NumAssets  for  n\nThe default is to ignore these constraints.\n'Simple' Bound Constraints",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 178,
      "section_heading": "Linear Equality Constraints",
      "captions": ""
    }
  },
  {
    "text": "• AEquality  for  A E • bEquality  for  b E • NumAssets  for  n\nThe default is to ignore these constraints.\n'Simple' Bound Constraints\n'Simple'  Bound constraints are specialized linear constraints that confine portfolio weights to fall either above or below specific bounds. Use  setBounds  to specify bound constraints with a  'Simple' BoundType . Since every portfolio set must be bounded, it is often a good practice, albeit not necessary, to set explicit bounds for the portfolio problem. To obtain explicit  'Simple'  bounds for a given portfolio set, use the  estimateBounds  function. Bound constraints take the form\nl B  ≤ x  ≤ u B\nwhere:\nx  is the portfolio ( n  vector).\nl B  is the lower-bound constraint ( n  vector).\nu B  is the upper-bound constraint ( n  vector).\nn  is the number of assets in the universe.\n4 Mean-Variance Portfolio Optimization Tools\n4-10",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 178,
      "section_heading": "Linear Equality Constraints",
      "captions": ""
    }
  },
  {
    "text": "Portfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify bound constraints are:\n• LowerBound  for  l B • UpperBound  for  u B • NumAssets  for  n\nThe default is to ignore these constraints.\nThe default portfolio optimization problem (see “Default Portfolio Problem” on page 4-17) has  l B  =  0 with  u B  set implicitly through a budget constraint.\n'Conditional' Bound Constraints\n'Conditional'  Bound constraints, also called semicontinuous constraints, are mixed-integer linear constraints that confine portfolio weights to fall either above or below specific bounds  if  the asset is selected; otherwise, the value of the asset is zero. Use  setBounds  to specify bound constraints with a  'Conditional'   BoundType . To mathematically formulate this type of constraints, a binary variable  v i  is needed.  v i  = 0 indicates that asset  i  is not selected and  v i  indicates that the asset was selected. Thus\nl i v i  ≤ x i  ≤ u i v i\nwhere",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 179,
      "section_heading": "'Conditional' Bound Constraints",
      "captions": ""
    }
  },
  {
    "text": "l i v i  ≤ x i  ≤ u i v i\nwhere\nx  is the portfolio ( n  vector).\nl  is the conditional lower-bound constraint ( n  vector).\nu  is the conditional upper-bound constraint ( n  vector).\nn  is the number of assets in the universe.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify the bound constraint are:\n• LowerBound  for  l B • UpperBound  for  u B • NumAssets  for  n\nThe default is to ignore this constraint.\nBudget Constraints\nBudget constraints are specialized linear constraints that confine the sum of portfolio weights to fall either above or below specific bounds. Use  setBudget  to set budget constraints. The constraints take the form\nl S  ≤1 T x  ≤ u S\nwhere:\nx  is the portfolio ( n  vector).\nSupported Constraints for Portfolio Optimization Using Portfolio Objects\n4-11",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 179,
      "section_heading": "'Conditional' Bound Constraints",
      "captions": ""
    }
  },
  {
    "text": "1  is the vector of ones ( n  vector).\nl S  is the lower-bound budget constraint (scalar).\nu S  is the upper-bound budget constraint (scalar).\nn  is the number of assets in the universe.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify budget constraints are:\n• LowerBudget  for  l S • UpperBudget  for  u S • NumAssets  for  n\nThe default is to ignore this constraint.\nThe default portfolio optimization problem (see “Default Portfolio Problem” on page 4-17) has  l S  =  u S =  1 , which means that the portfolio weights sum to  1 . If the portfolio optimization problem includes possible movements in and out of cash, the budget constraint specifies how far portfolios can go into cash. For example, if  l S  =  0  and  u S  =  1 , then the portfolio can have 0–100% invested in cash. If cash is to be a portfolio choice, set  RiskFreeRate  ( r 0 ) to a suitable value (see “Return Proxy” on page 4-5 and “Working with a Riskless Asset” on page 4-52).",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 180,
      "section_heading": "Conditional Budget Constraints",
      "captions": ""
    }
  },
  {
    "text": "Conditional Budget Constraints\nConditional budget constraints is a logical constraint that bounds the maximum amount of the portfolio that can be invested in assets exceeding a given threshold. This constraint supports the “Undertakings for Collective Investment in Transferable Securities” on page 15-1452 (UCITS) directive. Use  setConditionalBudget  to set conditional budget constraints. To mathematically formulate this type of constraints, a binary variable  w i  is needed. If  w i  =  0  the asset is below the specified threshold, otherwise the asset is above that threshold which is represented as\nw i  = 0 x i  ≤ α i ∑ i x i w i  ≤ γ\nwhere:\nx  is an  n  vector representing the portfolio.\nɑ  is a scalar or  n  representing the threshold above which assets are accounted for in the conditional budget (scalar or  n  vector).\nγ  is a scalar representing the maximum amount of the portfolio that can be invested in assets exceeding  ɑ .\nGroup Constraints",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 180,
      "section_heading": "Conditional Budget Constraints",
      "captions": ""
    }
  },
  {
    "text": "γ  is a scalar representing the maximum amount of the portfolio that can be invested in assets exceeding  ɑ .\nGroup Constraints\nGroup constraints are specialized linear constraints that enforce “membership” among groups of assets. Use  setGroups  to set group constraints. The constraints take the form\nl G  ≤ Gx  ≤ u G\n4 Mean-Variance Portfolio Optimization Tools\n4-12",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 180,
      "section_heading": "Conditional Budget Constraints",
      "captions": ""
    }
  },
  {
    "text": "where:\nx  is the portfolio ( n  vector).\nl G  is the lower-bound group constraint ( n G  vector).\nu G  is the upper-bound group constraint ( n G  vector).\nG  is the matrix of group membership indexes ( n G -by- n  matrix).\nEach row of  G  identifies which assets belong to a group associated with that row. Each row contains either  0 s or  1 s with  1  indicating that an asset is part of the group or  0  indicating that the asset is not part of the group.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify group constraints are:\n• GroupMatrix  for  G\n• LowerGroup  for  l G • UpperGroup  for  u G • NumAssets  for  n\nThe default is to ignore these constraints.\nGroup Ratio Constraints\nGroup ratio constraints are specialized linear constraints that enforce relationships among groups of assets. Use  setGroupRatio  to set group ratio constraints. The constraints take the form\nl Ri ( G B x ) i  ≤( G A x ) i  ≤ u Ri ( G B x ) i\nfor  i  = 1,...,  n R  where:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 181,
      "section_heading": "Group Ratio Constraints",
      "captions": ""
    }
  },
  {
    "text": "l Ri ( G B x ) i  ≤( G A x ) i  ≤ u Ri ( G B x ) i\nfor  i  = 1,...,  n R  where:\nx  is the portfolio ( n  vector).\nl R  is the vector of lower-bound group ratio constraints ( n R  vector).\nu R  is the vector matrix of upper-bound group ratio constraints ( n R  vector).\nG A  is the matrix of base group membership indexes ( n R -by- n  matrix).\nG B  is the matrix of comparison group membership indexes ( n R -by- n  matrix).\nn  is the number of assets in the universe and  n R  is the number of constraints.\nEach row of  G A  and  G B  identifies which assets belong to a base and comparison group associated with that row.\nEach row contains either  0 s or  1 s with  1  indicating that an asset is part of the group or  0  indicating that the asset is not part of the group.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify group ratio constraints are:\nSupported Constraints for Portfolio Optimization Using Portfolio Objects\n4-13",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 181,
      "section_heading": "Group Ratio Constraints",
      "captions": ""
    }
  },
  {
    "text": "• GroupA  for  G A • GroupB  for  G B • LowerRatio  for  l R • UpperRatio  for  u R • NumAssets  for  n\nThe default is to ignore these constraints.\nAverage Turnover Constraints\nTurnover constraint is a linear absolute value constraint that ensures estimated optimal portfolios differ from an initial portfolio by no more than a specified amount. Although portfolio turnover is defined in many ways, the turnover constraints implemented in Financial Toolbox compute portfolio turnover as the average of purchases and sales. Use  setTurnover  to set average turnover constraints. Average turnover constraints take the form\n1 2 1 T  x  − x 0 ≤ τ\nwhere:\nx  is the portfolio ( n  vector).\n1  is the vector of ones ( n  vector).\nx 0  is the initial portfolio ( n  vector).\nτ  is the upper bound for turnover (scalar).\nn  is the number of assets in the universe.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify the average turnover constraint are:\n• Turnover  for  τ",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 182,
      "section_heading": "Average Turnover Constraints",
      "captions": ""
    }
  },
  {
    "text": "n  is the number of assets in the universe.\nPortfolio ,  PortfolioCVaR , and  PortfolioMAD  object properties to specify the average turnover constraint are:\n• Turnover  for  τ\n• InitPort  for  x 0 • NumAssets  for  n\nThe default is to ignore this constraint.\nOne-Way Turnover Constraints\nOne-way turnover constraints ensure that estimated optimal portfolios differ from an initial portfolio by no more than specified amounts according to whether the differences are purchases or sales. Use setOneWayTurnover  to set one-way turnover constraints. The constraints take the forms\n1 T max 0,  x  − x 0 ≤ τ B\n1 T max 0,  x 0  − x ≤ τ S\nwhere:\n4 Mean-Variance Portfolio Optimization Tools\n4-14",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 182,
      "section_heading": "Average Turnover Constraints",
      "captions": ""
    }
  },
  {
    "text": "x  is the portfolio ( n  vector)\n1  is the vector of ones ( n  vector).\nx 0  is the Initial portfolio ( n  vector).\nτ B  is the upper bound for turnover constraint on purchases (scalar).\nτ S  is the upper bound for turnover constraint on sales (scalar).\nTo specify one-way turnover constraints, use the following properties in the  Portfolio , PortfolioCVaR , or  PortfolioMAD  object:\n• BuyTurnover  for τ B • SellTurnover  for τ S • InitPort  for  x 0\nThe default is to ignore this constraint.\nNote  The average turnover constraint (see “Working with Average Turnover Constraints Using Portfolio Object” on page 4-85) with τ is not a combination of the one-way turnover constraints with τ = τ B  = τ S .\nTracking Error Constraints\nTracking error constraint, within a portfolio optimization framework, is an additional constraint to specify the set of feasible portfolios known as a portfolio set. Use  setTrackingError  to set tracking error constraints. The tracking-error constraint has the form",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 183,
      "section_heading": "Tracking Error Constraints",
      "captions": ""
    }
  },
  {
    "text": "( x  − x T ) T C ( x  − x T ) ≤ τ T 2\nwhere:\nx  is the portfolio ( n  vector).\nx T  is the tracking portfolio against which risk is to be measured ( n  vector).\nC  is the covariance of asset returns.\nτ T  is the upper bound for tracking error (scalar).\nn  is the number of assets in the universe.\nPortfolio  object properties to specify the average turnover constraint are:\n• TrackingPort  for  x T • TrackingError  for  τ T\nThe default is to ignore this constraint.\nNote  The tracking error constraints can be used with any of the other supported constraints in the Portfolio  object without restrictions. However, since the portfolio set necessarily and sufficiently\nSupported Constraints for Portfolio Optimization Using Portfolio Objects\n4-15",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 183,
      "section_heading": "Tracking Error Constraints",
      "captions": ""
    }
  },
  {
    "text": "must be a non-empty compact set, the application of a tracking error constraint may result in an empty portfolio set. Use  estimateBounds  to confirm that the portfolio set is non-empty and compact.\nCardinality Constraints\nCardinality constraint limits the number of assets in the optimal allocation for an  Portfolio , PortfolioCVaR , or  PortfolioMAD  object. Use  setMinMaxNumAssets  to specify the 'MinNumAssets'  and  'MaxNumAssets'  constraints. To mathematically formulate this type of constraints, a binary variable  v i  is needed.  v i  = 0 indicates that asset  i  is not selected and  v i  = 1 indicates that the asset was selected. Thus\nMinNumAssets  ≤ ∑ i  = 1\nNumAssets v i  ≤ MaxNumAssets\nThe default is to ignore this constraint.\nSee Also Portfolio  |  PortfolioCVaR  |  PortfolioMAD\nRelated Examples\n• “Creating the Portfolio Object” on page 4-25\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Asset Allocation Case Study” on page 4-180",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 184,
      "section_heading": "Cardinality Constraints",
      "captions": ""
    }
  },
  {
    "text": "Related Examples\n• “Creating the Portfolio Object” on page 4-25\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222\n• “Portfolio Optimization Using Factor Models” on page 4-231\nMore About\n• Portfolio\n• “Portfolio Object Workflow” on page 4-18\n• “Default Portfolio Problem” on page 4-17\nExternal Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)\n4 Mean-Variance Portfolio Optimization Tools\n4-16",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 184,
      "section_heading": "Cardinality Constraints",
      "captions": ""
    }
  },
  {
    "text": "Default Portfolio Problem\nThe default portfolio optimization problem has a risk and return proxy associated with a given problem, and a portfolio set that specifies portfolio weights to be nonnegative and to sum to  1 . The lower bound combined with the budget constraint is sufficient to ensure that the portfolio set is nonempty, closed, and bounded. The default portfolio optimization problem characterizes a long-only investor who is fully invested in a collection of assets.\n• For mean-variance portfolio optimization, it is sufficient to set up the default problem. After setting up the problem, data in the form of a mean and covariance of asset returns are then used to solve portfolio optimization problems.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 185,
      "section_heading": "Default Portfolio Problem",
      "captions": ""
    }
  },
  {
    "text": "• For conditional value-at-risk portfolio optimization, the default problem requires the additional specification of a probability level that must be set explicitly. Generally, “typical” values for this level are 0.90 or 0.95. After setting up the problem, data in the form of scenarios of asset returns are then used to solve portfolio optimization problems.\n• For MAD portfolio optimization, it is sufficient to set up the default problem. After setting up the problem, data in the form of scenarios of asset returns are then used to solve portfolio optimization problems.\nSee Also Portfolio  |  PortfolioCVaR  |  PortfolioMAD\nRelated Examples\n• “Creating the Portfolio Object” on page 4-25\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 185,
      "section_heading": "Default Portfolio Problem",
      "captions": ""
    }
  },
  {
    "text": "• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222\n• “Portfolio Optimization Using Factor Models” on page 4-231\n• “Portfolio Optimization Using Social Performance Measure” on page 4-264\n• “Diversify Portfolios Using Custom Objective” on page 4-331\nMore About\n• Portfolio\n• Supported Constraints for Portfolio Optimization Using Portfolio Objects on page 4-9\n• “Portfolio Object Workflow” on page 4-18\nExternal Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)\nDefault Portfolio Problem\n4-17",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 185,
      "section_heading": "Default Portfolio Problem",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Object Workflow\nThe  Portfolio  object workflow for creating and modeling a mean-variance portfolio is:\n1 Create a Portfolio.\nCreate a  Portfolio  object for mean-variance portfolio optimization. For more information, see “Creating the Portfolio Object” on page 4-25.\n2 Estimate the mean and covariance for returns.\nEvaluate the mean and covariance for portfolio asset returns, including assets with missing data and financial time series data. For more information, see “Asset Returns and Moments of Asset Returns Using Portfolio Object” on page 4-42.\n3 Specify the Portfolio Constraints.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 186,
      "section_heading": "Portfolio Object Workflow",
      "captions": ""
    }
  },
  {
    "text": "3 Specify the Portfolio Constraints.\nDefine the constraints for portfolio assets such as linear equality and inequality, bound, budget, conditional budget, group, group ratio, turnover, tracking error,  'Conditional'   BoundType , and  MinNumAssets ,  MaxNumAssets  constraints. For more information, see “Working with Portfolio Constraints Using Defaults” on page 4-58 and “Working with 'Conditional' BoundType, MinNumAssets, and MaxNumAssets Constraints Using Portfolio Objects” on page 4-81.\n4 Validate the Portfolio.\nIdentify errors for the portfolio specification. For more information, see “Validate the Portfolio Problem for Portfolio Object” on page 4-94.\n5 Estimate the efficient portfolios and frontiers.\nAnalyze the efficient portfolios and efficient frontiers for a portfolio. For more information, see “Estimate Efficient Portfolios for Entire Efficient Frontier for Portfolio Object” on page 4-98 and “Estimate Efficient Frontiers for Portfolio Object” on page 4-122.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 186,
      "section_heading": "Portfolio Object Workflow",
      "captions": ""
    }
  },
  {
    "text": "Alternatively, you can estimate an optimal portfolio with a user-defined objective function for a Portfolio  object. For details on using  estimateCustomObjectivePortfolio  to specify a user-defined objective function, see “Solver Guidelines for Custom Objective Problems Using Portfolio Objects” on page 4-119.\n6 Postprocess the results.\nUse the efficient portfolios and efficient frontiers results to set up trades. For more information, see “Postprocessing Results to Set Up Tradable Portfolios” on page 4-130.\nFor an example of this workflow, see “Asset Allocation Case Study” on page 4-180 and “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161.\nSee Also\nRelated Examples\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 186,
      "section_heading": "Portfolio Object Workflow",
      "captions": ""
    }
  },
  {
    "text": "• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222\n4 Mean-Variance Portfolio Optimization Tools\n4-18",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 186,
      "section_heading": "Portfolio Object Workflow",
      "captions": ""
    }
  },
  {
    "text": "• “Portfolio Optimization Using Factor Models” on page 4-231\n• “Portfolio Optimization Using Social Performance Measure” on page 4-264\n• “Diversify Portfolios Using Custom Objective” on page 4-331\nMore About\n• “Portfolio Optimization Theory” on page 4-4\n• “Choosing and Controlling the Solver for Mean-Variance Portfolio Optimization” on page 4-114\nExternal Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)\nPortfolio Object Workflow\n4-19",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 187,
      "section_heading": "More About",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Object\nIn this section...\n“Portfolio Object Properties and Functions” on page 4-20\n“Working with Portfolio Objects” on page 4-20\n“Setting and Getting Properties” on page 4-20\n“Displaying Portfolio Objects” on page 4-21\n“Saving and Loading Portfolio Objects” on page 4-21\n“Estimating Efficient Portfolios and Frontiers” on page 4-21\n“Arrays of Portfolio Objects” on page 4-22\n“Subclassing Portfolio Objects” on page 4-23\n“Conventions for Representation of Data” on page 4-23\nPortfolio Object Properties and Functions",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 188,
      "section_heading": "Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "“Arrays of Portfolio Objects” on page 4-22\n“Subclassing Portfolio Objects” on page 4-23\n“Conventions for Representation of Data” on page 4-23\nPortfolio Object Properties and Functions\nThe  Portfolio  object implements mean-variance portfolio optimization. Every property and function of the  Portfolio  object is public, although some properties and functions are hidden. See Portfolio  for the properties and functions of the  Portfolio  object. The  Portfolio  object is a value object where every instance of the object is a distinct version of the object. Since the Portfolio  object is also a MATLAB object, it inherits the default functions associated with MATLAB objects.\nWorking with Portfolio Objects\nThe  Portfolio  object and its functions are an interface for mean-variance portfolio optimization. So, almost everything you do with the  Portfolio  object can be done using the associated functions. The basic workflow is:\n1 Design your portfolio problem.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 188,
      "section_heading": "Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "1 Design your portfolio problem.\n2 Use  Portfolio  to create the  Portfolio  object or use the various  set  functions to set up your portfolio problem.\n3 Use estimate functions to solve your portfolio problem.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 188,
      "section_heading": "Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "In addition, functions are available to help you view intermediate results and to diagnose your computations. Since MATLAB features are part of a  Portfolio  object, you can save and load objects from your workspace and create and manipulate arrays of objects. After settling on a problem, which, in the case of mean-variance portfolio optimization, means that you have either data or moments for asset returns and a collection of constraints on your portfolios, use  Portfolio  to set the properties for the  Portfolio  object.  Portfolio  lets you create an object from scratch or update an existing object. Since the  Portfolio  object is a value object, it is easy to create a basic object, then use functions to build upon the basic object to create new versions of the basic object. This is useful to compare a basic problem with alternatives derived from the basic problem. For details, see “Creating the Portfolio Object” on page 4-25.\nSetting and Getting Properties",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 188,
      "section_heading": "Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Setting and Getting Properties\nYou can set properties of a  Portfolio  object using either  Portfolio  or various  set  functions.\n4 Mean-Variance Portfolio Optimization Tools\n4-20",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 188,
      "section_heading": "Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "Note  Although you can also set properties directly, it is not recommended since error-checking is not performed when you set a property directly.\nThe  Portfolio  object supports setting properties with name-value pair arguments such that each argument name is a property and each value is the value to assign to that property. For example, to set the  AssetMean  and  AssetCovar  properties in an existing  Portfolio  object  p  with the values  m and  C , use the syntax:\np = Portfolio(p,  'AssetMean' , m,  'AssetCovar' , C);",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 189,
      "section_heading": "Displaying Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "p = Portfolio(p,  'AssetMean' , m,  'AssetCovar' , C);\nIn addition to  Portfolio , which lets you set individual properties one at a time, groups of properties are set in a  Portfolio  object with various “set” and “add” functions. For example, to set up an average turnover constraint, use the  setTurnover  function to specify the bound on portfolio average turnover and the initial portfolio. To get individual properties from a Portfolio object, obtain properties directly or use an assortment of “get” functions that obtain groups of properties from a Portfolio  object. The  Portfolio  object and the  set  functions have several useful features:\n• Portfolio  and the  set  functions try to determine the dimensions of your problem with either explicit or implicit inputs.\n• Portfolio  and the  set  functions try to resolve ambiguities with default choices.\n• Portfolio  and the  set  functions perform scalar expansion on arrays when possible.",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 189,
      "section_heading": "Displaying Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "• Portfolio  and the  set  functions try to resolve ambiguities with default choices.\n• Portfolio  and the  set  functions perform scalar expansion on arrays when possible.\n• The associated  Portfolio  object functions try to diagnose and warn about problems.\nDisplaying Portfolio Objects\nThe  Portfolio  object uses the default display functions provided by MATLAB, where  display  and disp  display a Portfolio object and its properties with or without the object variable name.\nSaving and Loading Portfolio Objects\nSave and load  Portfolio  objects using the MATLAB  save  and  load  commands.\nEstimating Efficient Portfolios and Frontiers",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 189,
      "section_heading": "Displaying Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "Saving and Loading Portfolio Objects\nSave and load  Portfolio  objects using the MATLAB  save  and  load  commands.\nEstimating Efficient Portfolios and Frontiers\nEstimating efficient portfolios and efficient frontiers is the primary purpose of the portfolio optimization tools. An efficient portfolio are the portfolios that satisfy the criteria of minimum risk for a given level of return and maximum return for a given level of risk. A collection of “estimate” and “plot” functions provide ways to explore the efficient frontier. The “estimate” functions obtain either efficient portfolios or risk and return proxies to form efficient frontiers. At the portfolio level, a collection of functions estimates efficient portfolios on the efficient frontier with functions to obtain efficient portfolios:\n• At the endpoints of the efficient frontier\n• That attains targeted values for return proxies\n• That attains targeted values for risk proxies\n• Along the entire efficient frontier",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 189,
      "section_heading": "Displaying Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "• At the endpoints of the efficient frontier\n• That attains targeted values for return proxies\n• That attains targeted values for risk proxies\n• Along the entire efficient frontier\nThese functions also provide purchases and sales needed to shift from an initial or current portfolio to each efficient portfolio. At the efficient frontier level, a collection of functions plot the efficient\nPortfolio Object\n4-21",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 189,
      "section_heading": "Displaying Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "frontier and estimate either risk or return proxies for efficient portfolios on the efficient frontier. You can use the resultant efficient portfolios or risk and return proxies in subsequent analyses.\nArrays of Portfolio Objects\nAlthough all functions associated with a  Portfolio  object are designed to work on a scalar Portfolio  object, the array capabilities of MATLAB enable you to set up and work with arrays of Portfolio  objects. The easiest way to do this is with the  repmat  function. For example, to create a 3-by-2 array of  Portfolio  objects:\np = repmat(Portfolio, 3, 2); disp(p)\ndisp(p)   3×2 Portfolio array with properties:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 190,
      "section_heading": "Arrays of Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "p = repmat(Portfolio, 3, 2); disp(p)\ndisp(p)   3×2 Portfolio array with properties:\nBuyCost     SellCost     RiskFreeRate     AssetMean     AssetCovar     TrackingError     TrackingPort     Turnover     BuyTurnover     SellTurnover     Name     NumAssets     AssetList     InitPort     AInequality     bInequality     AEquality     bEquality     LowerBound     UpperBound     LowerBudget     UpperBudget     GroupMatrix     LowerGroup     UpperGroup     GroupA     GroupB     LowerRatio     UpperRatio     MinNumAssets     MaxNumAssets     ConditionalBudgetThreshold     ConditionalUpperBudget     BoundType\nAfter setting up an array of  Portfolio  objects, you can work on individual  Portfolio  objects in the array by indexing. For example:\np(i,j) = Portfolio(p(i,j), ... );\nThis example calls  Portfolio  for the ( i , j ) element of a matrix of  Portfolio  objects in the variable p .\n4 Mean-Variance Portfolio Optimization Tools\n4-22",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 190,
      "section_heading": "Arrays of Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "If you set up an array of  Portfolio  objects, you can access properties of a particular  Portfolio object in the array by indexing so that you can set the lower and upper bounds  lb  and  ub  for the ( i , j , k ) element of a 3-D array of  Portfolio  objects with\np(i,j,k) = setBounds(p(i,j,k),lb, ub);\nand, once set, you can access these bounds with\n[lb, ub] = getBounds(p(i,j,k));\nPortfolio  object functions work on only one  Portfolio  object at a time.\nSubclassing Portfolio Objects",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 191,
      "section_heading": "Subclassing Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "and, once set, you can access these bounds with\n[lb, ub] = getBounds(p(i,j,k));\nPortfolio  object functions work on only one  Portfolio  object at a time.\nSubclassing Portfolio Objects\nYou can subclass the  Portfolio  object to override existing functions or to add new properties or functions. To do so, create a derived class from the  Portfolio  class. This gives you all the properties and functions of the  Portfolio  class along with any new features that you choose to add to your subclassed object. The  Portfolio  class is derived from an abstract class called AbstractPortfolio . Because of this, you can also create a derived class from AbstractPortfolio  that implements an entirely different form of portfolio optimization using properties and functions of the  AbstractPortfolio  class.\nConventions for Representation of Data\nThe portfolio optimization tools follow these conventions regarding the representation of different quantities associated with portfolio optimization:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 191,
      "section_heading": "Subclassing Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "Conventions for Representation of Data\nThe portfolio optimization tools follow these conventions regarding the representation of different quantities associated with portfolio optimization:\n• Asset returns or prices are in matrix form with samples for a given asset going down the rows and assets going across the columns. In the case of prices, the earliest dates must be at the top of the matrix, with increasing dates going down.\n• The mean and covariance of asset returns are stored in a vector and a matrix and the tools have no requirement that the mean must be either a column or row vector.\n• Portfolios are in vector or matrix form with weights for a given portfolio going down the rows and distinct portfolios going across the columns.\n• Constraints on portfolios are formed in such a way that a portfolio is a column vector.\n• Portfolio risks and returns are either scalars or column vectors (for multiple portfolio risks and returns).\nSee Also Portfolio\nRelated Examples",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 191,
      "section_heading": "Subclassing Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "• Portfolio risks and returns are either scalars or column vectors (for multiple portfolio risks and returns).\nSee Also Portfolio\nRelated Examples\n• “Creating the Portfolio Object” on page 4-25\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222\nPortfolio Object\n4-23",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 191,
      "section_heading": "Subclassing Portfolio Objects",
      "captions": ""
    }
  },
  {
    "text": "• “Portfolio Optimization Using Factor Models” on page 4-231\n• “Portfolio Optimization Using Social Performance Measure” on page 4-264\n• “Diversify Portfolios Using Custom Objective” on page 4-331\nMore About\n• “Portfolio Optimization Theory” on page 4-4\n• “Portfolio Object Workflow” on page 4-18\nExternal Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n4 Mean-Variance Portfolio Optimization Tools\n4-24",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 192,
      "section_heading": "More About",
      "captions": ""
    }
  },
  {
    "text": "Creating the Portfolio Object\nIn this section...\n“Syntax” on page 4-25\n“Portfolio Problem Sufficiency” on page 4-25\n“Portfolio Function Examples” on page 4-26\nTo create a fully specified mean-variance portfolio optimization problem, instantiate the  Portfolio object using  Portfolio . For information on the workflow when using  Portfolio  objects, see “Portfolio Object Workflow” on page 4-18.\nSyntax\nUse  Portfolio  to create an instance of an object of the  Portfolio  class. You can use  Portfolio in several ways. To set up a portfolio optimization problem in a  Portfolio  object, the simplest syntax is:\np = Portfolio;\nThis syntax creates a  Portfolio  object,  p , such that all object properties are empty.\nThe  Portfolio  object also accepts collections of argument name-value pair arguments for properties and their values. The  Portfolio  object accepts inputs for public properties with the general syntax:\np = Portfolio('property1', value1, 'property2', value2, ... );",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 193,
      "section_heading": "Creating the Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "p = Portfolio('property1', value1, 'property2', value2, ... );\nIf a  Portfolio  object already exists, the syntax permits the first (and only the first argument) of Portfolio  to be an existing object with subsequent argument name-value pair arguments for properties to be added or modified. For example, given an existing  Portfolio  object in  p , the general syntax is:\np = Portfolio(p, 'property1', value1, 'property2', value2, ... );",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 193,
      "section_heading": "Creating the Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "p = Portfolio(p, 'property1', value1, 'property2', value2, ... );\nInput argument names are not case-sensitive, but must be completely specified. In addition, several properties can be specified with alternative argument names (see “Shortcuts for Property Names” on page 4-30). The  Portfolio  object detects problem dimensions from the inputs and, once set, subsequent inputs can undergo various scalar or matrix expansion operations that simplify the overall process to formulate a problem. In addition, a  Portfolio  object is a value object so that, given portfolio  p , the following code creates two objects,  p  and  q , that are distinct:\nq = Portfolio(p, ...)\nPortfolio Problem Sufficiency\nA mean-variance portfolio optimization is completely specified with the  Portfolio  object if these two conditions are met:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 193,
      "section_heading": "Creating the Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "q = Portfolio(p, ...)\nPortfolio Problem Sufficiency\nA mean-variance portfolio optimization is completely specified with the  Portfolio  object if these two conditions are met:\n• The moments of asset returns must be specified such that the property  AssetMean  contains a valid finite mean vector of asset returns and the property  AssetCovar  contains a valid symmetric positive-semidefinite matrix for the covariance of asset returns.\nCreating the Portfolio Object\n4-25",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 193,
      "section_heading": "Creating the Portfolio Object",
      "captions": ""
    }
  },
  {
    "text": "The first condition is satisfied by setting the properties associated with the moments of asset returns.\n• The set of feasible portfolios must be a nonempty compact set, where a compact set is closed and bounded.\nThe second condition is satisfied by an extensive collection of properties that define different types of constraints to form a set of feasible portfolios. Since such sets must be bounded, either explicit or implicit constraints can be imposed, and several functions, such as  estimateBounds , provide ways to ensure that your problem is properly formulated.\nAlthough the general sufficiency conditions for mean-variance portfolio optimization go beyond these two conditions, the  Portfolio  object implemented in Financial Toolbox implicitly handles all these additional conditions. For more information on the Markowitz model for mean-variance portfolio optimization, see “Portfolio Optimization” on page A-5.\nPortfolio Function Examples",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 194,
      "section_heading": "Portfolio Function Examples",
      "captions": ""
    }
  },
  {
    "text": "Portfolio Function Examples\nIf you create a  Portfolio  object,  p , with no input arguments, you can display it using  disp :\np = Portfolio; disp(p)\nPortfolio with properties:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 194,
      "section_heading": "Portfolio Function Examples",
      "captions": ""
    }
  },
  {
    "text": "BuyCost: []                       SellCost: []                   RiskFreeRate: []                      AssetMean: []                     AssetCovar: []                  TrackingError: []                   TrackingPort: []                       Turnover: []                    BuyTurnover: []                   SellTurnover: []                           Name: []                      NumAssets: []                      AssetList: []                       InitPort: []                    AInequality: []                    bInequality: []                      AEquality: []                      bEquality: []                     LowerBound: []                     UpperBound: []                    LowerBudget: []                    UpperBudget: []                    GroupMatrix: []                     LowerGroup: []                     UpperGroup: []                         GroupA: []                         GroupB: []                     LowerRatio: []                     UpperRatio: []",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 194,
      "section_heading": "Portfolio Function Examples",
      "captions": ""
    }
  },
  {
    "text": "LowerGroup: []                     UpperGroup: []                         GroupA: []                         GroupB: []                     LowerRatio: []                     UpperRatio: []                   MinNumAssets: []                   MaxNumAssets: []     ConditionalBudgetThreshold: []",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 194,
      "section_heading": "Portfolio Function Examples",
      "captions": ""
    }
  },
  {
    "text": "4 Mean-Variance Portfolio Optimization Tools\n4-26",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 194,
      "section_heading": "Portfolio Function Examples",
      "captions": ""
    }
  },
  {
    "text": "ConditionalUpperBudget: []                      BoundType: []\nThe approaches listed provide a way to set up a portfolio optimization problem with the  Portfolio object. The  set  functions offer additional ways to set and modify collections of properties in the Portfolio  object.\nUsing the Portfolio Function for a Single-Step Setup\nYou can use the  Portfolio  object to directly set up a “standard” portfolio optimization problem, given a mean and covariance of asset returns in the variables  m  and  C :\nm = [ 0.05; 0.1; 0.12; 0.18 ]; C = [ 0.0064 0.00408 0.00192 0;      0.00408 0.0289 0.0204 0.0119;     0.00192 0.0204 0.0576 0.0336;     0 0.0119 0.0336 0.1225 ];\np = Portfolio( 'assetmean' , m,  'assetcovar' , C,  ... 'lowerbudget' , 1,  'upperbudget' , 1,  'lowerbound' , 0)\np =\nPortfolio with properties:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 195,
      "section_heading": "The approaches listed provide a way to set up a portfolio optimization problem with the",
      "captions": ""
    }
  },
  {
    "text": "BuyCost: []                       SellCost: []                   RiskFreeRate: []                      AssetMean: [4×1 double]                     AssetCovar: [4×4 double]                  TrackingError: []                   TrackingPort: []                       Turnover: []                    BuyTurnover: []                   SellTurnover: []                           Name: []                      NumAssets: 4                      AssetList: []                       InitPort: []                    AInequality: []                    bInequality: []                      AEquality: []                      bEquality: []                     LowerBound: [4×1 double]                     UpperBound: []                    LowerBudget: 1                    UpperBudget: 1                    GroupMatrix: []                     LowerGroup: []                     UpperGroup: []                         GroupA: []                         GroupB: []                     LowerRatio: []",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 195,
      "section_heading": "The approaches listed provide a way to set up a portfolio optimization problem with the",
      "captions": ""
    }
  },
  {
    "text": "[]                     LowerGroup: []                     UpperGroup: []                         GroupA: []                         GroupB: []                     LowerRatio: []                     UpperRatio: []                   MinNumAssets: []                   MaxNumAssets: []     ConditionalBudgetThreshold: []",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 195,
      "section_heading": "The approaches listed provide a way to set up a portfolio optimization problem with the",
      "captions": ""
    }
  },
  {
    "text": "Creating the Portfolio Object\n4-27",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 195,
      "section_heading": "The approaches listed provide a way to set up a portfolio optimization problem with the",
      "captions": ""
    }
  },
  {
    "text": "ConditionalUpperBudget: []                      BoundType: []\nThe  LowerBound  property value undergoes scalar expansion since  AssetMean  and  AssetCovar provide the dimensions of the problem.\nYou can use dot notation with the function  plotFrontier .\np.plotFrontier\nUsing the Portfolio Function with a Sequence of Steps\nAn alternative way to accomplish the same task of setting up a “standard” portfolio optimization problem, given a mean and covariance of asset returns in the variables  m  and  C  (which also illustrates that argument names are not case-sensitive):\nm = [ 0.05; 0.1; 0.12; 0.18 ]; C = [ 0.0064 0.00408 0.00192 0;      0.00408 0.0289 0.0204 0.0119;     0.00192 0.0204 0.0576 0.0336;     0 0.0119 0.0336 0.1225 ];\np = Portfolio; p = Portfolio(p,  'assetmean' , m,  'assetcovar' , C); p = Portfolio(p,  'lowerbudget' , 1,  'upperbudget' , 1); p = Portfolio(p,  'lowerbound' , 0);   plotFrontier(p)\n4 Mean-Variance Portfolio Optimization Tools\n4-28",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 196,
      "section_heading": "LowerBound",
      "captions": ""
    }
  },
  {
    "text": "This way works because the calls to  Portfolio  are in this particular order. In this case, the call to initialize  AssetMean  and  AssetCovar  provides the dimensions for the problem. If you were to do this step last, you would have to explicitly dimension the  LowerBound  property as follows:\nm = [ 0.05; 0.1; 0.12; 0.18 ]; C = [ 0.0064 0.00408 0.00192 0;      0.00408 0.0289 0.0204 0.0119;     0.00192 0.0204 0.0576 0.0336;     0 0.0119 0.0336 0.1225 ];\np = Portfolio; p = Portfolio(p,  'LowerBound' , zeros(size(m))); p = Portfolio(p,  'LowerBudget' , 1,  'UpperBudget' , 1); p = Portfolio(p,  'AssetMean' , m,  'AssetCovar' , C);   plotFrontier(p)\nCreating the Portfolio Object\n4-29",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 197,
      "section_heading": "This way works because the calls to",
      "captions": ""
    }
  },
  {
    "text": "If you did not specify the size of  LowerBound  but, instead, input a scalar argument, the  Portfolio object assumes that you are defining a single-asset problem and produces an error at the call to set asset moments with four assets.\nShortcuts for Property Names\nThe  Portfolio  object has shorter argument names that replace longer argument names associated with specific properties of the  Portfolio  object. For example, rather than enter  'assetcovar' , the Portfolio  object accepts the case-insensitive name  'covar'  to set the  AssetCovar  property in a Portfolio  object. Every shorter argument name corresponds with a single property in the Portfolio  object. The one exception is the alternative argument name  'budget' , which signifies both the  LowerBudget  and  UpperBudget  properties. When  'budget'  is used, then the LowerBudget  and  UpperBudget  properties are set to the same value to form an equality budget constraint.\n4 Mean-Variance Portfolio Optimization Tools\n4-30",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 198,
      "section_heading": "If you did not specify the size of",
      "captions": ""
    }
  },
  {
    "text": "Shortcuts for Property Names\nShortcut Argument Name Equivalent Argument / Property Name\nae AEquality\nai AInequality\ncovar AssetCovar\nassetnames  or  assets AssetList\nmean AssetMean\nbe bEquality\nbi bInequality\ngroup GroupMatrix\nlb LowerBound\nn  or  num NumAssets\nrfr RiskFreeRate\nub UpperBound\nbudget UpperBudget  and  LowerBudget\nFor example, this call  Portfolio  uses these shortcuts for properties and is equivalent to the previous examples:\nm = [ 0.05; 0.1; 0.12; 0.18 ]; C = [ 0.0064 0.00408 0.00192 0;      0.00408 0.0289 0.0204 0.0119;     0.00192 0.0204 0.0576 0.0336;     0 0.0119 0.0336 0.1225 ];\np = Portfolio( 'mean' , m,  'covar' , C,  'budget' , 1,  'lb' , 0); plotFrontier(p)\nDirect Setting of Portfolio Object Properties\nAlthough not recommended, you can set properties directly, however no error-checking is done on your inputs:",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 199,
      "section_heading": "Shortcuts for Property Names",
      "captions": ""
    }
  },
  {
    "text": "Direct Setting of Portfolio Object Properties\nAlthough not recommended, you can set properties directly, however no error-checking is done on your inputs:\nm = [ 0.05; 0.1; 0.12; 0.18 ]; C = [ 0.0064 0.00408 0.00192 0;      0.00408 0.0289 0.0204 0.0119;     0.00192 0.0204 0.0576 0.0336;     0 0.0119 0.0336 0.1225 ];\np = Portfolio; p.NumAssets = numel(m); p.AssetMean = m; p.AssetCovar = C; p.LowerBudget = 1; p.UpperBudget = 1; p.LowerBound = zeros(size(m));\nplotFrontier(p)\nCreating the Portfolio Object\n4-31",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 199,
      "section_heading": "Shortcuts for Property Names",
      "captions": ""
    }
  },
  {
    "text": "See Also Portfolio  |  estimateBounds\nRelated Examples\n• “Common Operations on the Portfolio Object” on page 4-33\n• “Working with Portfolio Constraints Using Defaults” on page 4-58\n• “Asset Allocation Case Study” on page 4-180\n• “Portfolio Optimization Examples Using Financial Toolbox” on page 4-161\n• “Portfolio Optimization with Semicontinuous and Cardinality Constraints” on page 4-190\n• “Black-Litterman Portfolio Optimization Using Financial Toolbox” on page 4-222\n• “Portfolio Optimization Using Factor Models” on page 4-231\n• “Diversify Portfolios Using Custom Objective” on page 4-331\n• “Portfolio Optimization Using Social Performance Measure” on page 4-264\nMore About\n• “Portfolio Object” on page 4-20\n• “Portfolio Optimization Theory” on page 4-4\n• “Portfolio Object Workflow” on page 4-18\nExternal Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 200,
      "section_heading": "See Also",
      "captions": ""
    }
  },
  {
    "text": "External Websites\n• Getting Started with Portfolio Optimization (4 min 13 sec)\n• MATLAB for Advanced Portfolio Construction and Stock Selection Models (30 min 28 sec)\n4 Mean-Variance Portfolio Optimization Tools\n4-32",
    "metadata": {
      "source": "fintbx.pdf",
      "page_number": 200,
      "section_heading": "See Also",
      "captions": ""
    }
  }
]